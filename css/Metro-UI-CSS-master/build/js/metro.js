/*
 * Metro 4 Components Library v4.5.0  (https://metroui.org.ua)
 * Copyright 2012-2021 Sergey Pimenov
 * Built at 01/08/2021 18:53:43
 * Licensed under MIT
 */
/*!
 * Datetime v1.0.0, (https://github.com/olton/DatetimeJS.git)
 * Copyright 2021 by Serhii Pimenov (https://pimenov.com.ua)
 * Datetime.js is a minimalist JavaScript library that parses, validates, manipulates, and displays dates and times for modern browsers with comfortable modern API.
 * Build at 11/01/2021 21:09:55
 * Licensed under MIT
 !*/
(function(global) {
    'use strict';

    var DEFAULT_FORMAT = "YYYY-MM-DDTHH:mm:ss.sss";
    var INVALID_DATE = "Invalid date";
    var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|m{1,2}|s{1,3}/g;

    global['DATETIME_LOCALES'] = {
        "en": {
            months: "January February March April May June July August September October November December".split(" "),
            monthsShort: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
            weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
            weekdaysShort: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
            weekdaysMin: "Su Mo Tu We Th Fr Sa".split(" "),
            weekStart: 0
        }
    }

    var M = {
        ms: "Milliseconds",
        s: "Seconds",
        m: "Minutes",
        h: "Hours",
        D: "Date",
        d: "Day",
        M: "Month",
        Y: "FullYear",
        y: "Year",
        t: "Time"
    }

    var C = {
        ms: "ms",
        s: "second",
        m: "minute",
        h: "hour",
        D: "day",
        W: "week",
        d: "weekDay",
        M: "month",
        Y: "year",
        Y2: "year2",
        t: "time",
        c: "century",
        q: "quarter"
    }

    var lpad = function(str, pad, length){
        var _str = ""+str;
        if (length && _str.length >= length) {
            return _str;
        }
        return Array((length + 1) - _str.length).join(pad) + _str;
    }

    var not = function(v){
        return typeof v === "undefined" || v === null;
    }
    var datetime = function(){
        var args;

        if (arguments[0] instanceof Datetime) {
            return datetime(arguments[0].value);
        }

        args = [].slice.call(Array.isArray(arguments[0]) ? arguments[0] : arguments);

        return new (Function.prototype.bind.apply(Datetime,  [this].concat(args) ) );
    }
    var Datetime = function(){
        var args = [].slice.call(arguments);
        this.value = new (Function.prototype.bind.apply(Date,  [this].concat(args) ) );
        this.locale = "en";
        this.weekStart = global['DATETIME_LOCALES']["en"].weekStart;
        this.utcMode = false;
        this.mutable = true;

        if (isNaN(this.value.getTime())) {
            throw new Error(INVALID_DATE);
        }
    }
    Datetime.DEFAULT_FORMAT = DEFAULT_FORMAT;
    Datetime.REGEX_FORMAT = REGEX_FORMAT;
    Datetime.INVALID_DATE = INVALID_DATE;

    Datetime.lpad = lpad;
    Datetime.not = not;

    Datetime.isDatetime = function(val){
        return val instanceof Datetime;
    }

    Datetime.now = function(asDate){
        return datetime()[asDate ? "val" : "time"]();
    }

    Datetime.locale = function(name, locale){
        global['DATETIME_LOCALES'][name] = locale;
    }

    Datetime.getLocale = function(locale){
        return global['DATETIME_LOCALES'][locale || "en"] || global['DATETIME_LOCALES']["en"];
    }

    Datetime.parse = function(str){
        return datetime(Date.parse(str));
    }

    Datetime.align = function(d, align){
        var date = d instanceof Datetime ? d : datetime(d),
            result, temp;

        switch (align) {
            case C.s:  result = date.ms(0); break; //second
            case C.m:  result = Datetime.align(date, C.s)[C.s](0); break; //minute
            case C.h:  result = Datetime.align(date, C.m)[C.m](0); break; //hour
            case C.D:  result = Datetime.align(date, C.h)[C.h](0); break; //day
            case C.M:  result = Datetime.align(date, C.D)[C.D](1); break; //month
            case C.Y:  result = Datetime.align(date, C.M)[C.M](0); break; //year
            case C.W:  {
                temp = date.weekDay();
                result = Datetime.align(date, C.D).addDay(-temp);
                break; // week
            }
            default:   result = date;
        }
        return result;
    }

    Datetime.alignEnd = function(d, align){
        var date = d instanceof Datetime ? d : datetime(d),
            result, temp;

        switch (align) {
            case C.ms: result = date.ms(999); break; //second
            case C.s:  result = Datetime.alignEnd(date, C.ms); break; //second
            case C.m:  result = Datetime.alignEnd(date, C.s)[C.s](59); break; //minute
            case C.h:  result = Datetime.alignEnd(date, C.m)[C.m](59); break; //hour
            case C.D:  result = Datetime.alignEnd(date, C.h)[C.h](23); break; //day
            case C.M:  result = Datetime.alignEnd(date, C.D)[C.D](1).add(1, C.M).add(-1, C.D); break; //month
            case C.Y:  result = Datetime.alignEnd(date, C.D)[C.M](11)[C.D](31); break; //year
            case C.W:  {
                temp = date.weekDay();
                result = Datetime.alignEnd(date, 'day').addDay(6 - temp);
                break; // week
            }

            default:   result = date;
        }

        return result;
    }
    Datetime.extend = function(where){
        var options, name,
            length = arguments.length;

        for (var i = 1; i < length; i++ ) {
            if ( ( options = arguments[ i ] ) != null ) {
                for ( name in options ) {
                    if (Object.prototype.hasOwnProperty.call(options, name))
                        where[ name ] = options[ name ];
                }
            }
        }

        return where;
    };

    Datetime.use = function(obj){
        Datetime.extend(Datetime.prototype, obj);
    }

    Datetime.useStatic = function(obj){
        Datetime.extend(Datetime, obj);
    }

    Datetime.prototype = {
        immutable: function(v){
            this.mutable = !(not(v) ? true : v);
            return this;
        },

        utc: function(){
            this.utcMode = true;
            return this;
        },

        local: function(){
            this.utcMode = false
            return this;
        },

        useLocale: function(val){
            if (!Datetime.getLocale(val)) {
                console.warn("Locale " + val + " is not defined!");
                return this;
            }
            this.locale = val;
            this.weekStart = Datetime.getLocale(val).weekStart;
            return this;
        },

        clone: function(){
            var c = datetime(this.value);
            c.locale = this.locale;
            c.weekStart = this.weekStart;
            c.mutable = this.mutable;
            return c;
        },

        align: function(to){
            if (this.mutable) {
                this.value = Datetime.align(this, to).val();
                return this;
            }

            return this.clone().immutable(false).align(to).immutable(!this.mutable);
        },

        alignEnd: function(to){
            if (this.mutable) {
                this.value = Datetime.alignEnd(this, to).val();
                return this;
            }

            return this.clone().immutable(false).alignEnd(to).immutable(!this.mutable);
        },

        val: function(val){
            if ( !(val instanceof Date) )
                return this.value;

            if (this.mutable) {
                this.value = val;
                return this;
            }

            return datetime(val);
        },

        year2: function(){
            return +(""+this.year()).substr(-2);
        },

        _set: function(m, v){
            var fn = "set" + (this.utcMode && m !== "t" ? "UTC" : "") + M[m];
            if (this.mutable) {
                this.value[fn](v);
                return this;
            }
            var clone = this.clone();
            clone.value[fn](v);
            return clone;
        },

        _get: function(m){
            var fn = "get" + (this.utcMode && m !== "t" ? "UTC" : "") + M[m];
            return this.value[fn]();
        },

        _work: function(part, val){
            if (!arguments.length || (typeof val === "undefined" || val === null)) {
                return this._get(part);
            }
            return this._set(part, val);
        },

        ms: function(val){ return this._work("ms", val);},
        second: function(val){return this._work("s", val);},
        minute: function(val){return this._work("m", val); },
        hour: function(val){return this._work("h", val);},
        day: function(val){return this._work("D", val);},
        month: function(val){return this._work("M", val);},
        year: function(val){return this._work("Y", val);},
        time: function(val){return this._work("t", val);},

        weekDay: function(val){
            if (!arguments.length || (not(val))) {
                return this.utcMode ? this.value.getUTCDay() : this.value.getDay();
            }

            var curr = this.weekDay();
            var diff = val - curr;

            this.day(this.day() + diff);

            return this;
        },

        get: function(unit){
            return typeof this[unit] !== "function" ? this : this[unit]();
        },

        set: function(unit, val){
            return typeof this[unit] !== "function" ? this : this[unit](val);
        },

        add: function(val, to){
            switch (to) {
                case C.h: return this.time(this.time() + (val * 60 * 60 * 1000));
                case C.m: return this.time(this.time() + (val * 60 * 1000));
                case C.s: return this.time(this.time() + (val * 1000));
                case C.ms: return this.time(this.time() + (val));
                case C.D: return this.day(this.day() + val);
                case C.W: return this.day(this.day() + val * 7);
                case C.M: return this.month(this.month() + val);
                case C.Y: return this.year(this.year() + val);
            }
        },

        addHour: function(v){return this.add(v,C.h);},
        addMinute: function(v){return this.add(v,C.m);},
        addSecond: function(v){return this.add(v, C.s);},
        addMs: function(v){return this.add(v, C.ms);},
        addDay: function(v){return this.add(v,C.D);},
        addWeek: function(v){return this.add(v,C.W);},
        addMonth: function(v){return this.add(v, C.M);},
        addYear: function(v){return this.add(v, C.Y);},

        format: function(fmt, locale){
            var format = fmt || DEFAULT_FORMAT;
            var names = Datetime.getLocale(locale || this.locale);
            var year = this.year(), year2 = this.year2(), month = this.month(), day = this.day(), weekDay = this.weekDay();
            var hour = this.hour(), minute = this.minute(), second = this.second(), ms = this.ms();
            var matches = {
                YY: year2,
                YYYY: year,
                M: month + 1,
                MM: lpad(month + 1, "0", 2),
                MMM: names.monthsShort[month],
                MMMM: names.months[month],
                D: day,
                DD: lpad(day, "0", 2),
                d: weekDay,
                dd: names.weekdaysMin[weekDay],
                ddd: names.weekdaysShort[weekDay],
                dddd: names.weekdays[weekDay],
                H: hour,
                HH: lpad(hour, "0", 2),
                m: minute,
                mm: lpad(minute,"0", 2),
                s: second,
                ss: lpad(second,"0", 2),
                sss: lpad(ms,"0", 3)
            };

            return format.replace(REGEX_FORMAT, function(match, $1){
                return $1 || matches[match];
            });
        },

        valueOf: function(){
            return this.value.valueOf();
        },

        toString: function(){
            return this.value.toString();
        }
    }

    global.Datetime = Datetime;
    global.datetime = datetime;

}(typeof self === "undefined" ? typeof global === "undefined" ? window : global : self));
(function() {
    'use strict';

    var fnFormat = Datetime.prototype.format;

    Datetime.use({
        buddhist: function(){
            return this.year() + 543;
        },

        format: function(format, locale){
            format = format || Datetime.DEFAULT_FORMAT;
            var matches = {
                BB: (this.buddhist()+"").slice(-2),
                BBBB: this.buddhist()
            }
            var result = format.replace(/(\[[^\]]+])|B{4}|B{2}/g, function(match, $1){
                return $1 || matches[match];
            })
            return fnFormat.bind(this)(result, locale)
        }
    });
}());(function() {
    'use strict';

    Datetime.use({
        calendar: function(iso){
            return Datetime.calendar(this, iso);
        }
    });

    Datetime.useStatic({
        calendar: function(d, iso){
            var date = d instanceof Datetime ? d.clone().align("month") : datetime(d);
            var ws = iso === 0 || iso ? iso : date.weekStart;
            var wd = ws ? date.isoWeekDay() : date.weekDay();
            var names = Datetime.getLocale(date.locale);
            var now = datetime(), i;

            var getWeekDays = function (wd, ws){
                if (ws === 0) {
                    return wd;
                }
                var su = wd[0];
                return wd.slice(1).concat([su]);
            }

            var result = {
                month: names.months[date.month()],
                days: [],
                weekstart: iso ? 1 : 0,
                weekdays: getWeekDays(names.weekdaysMin,ws),
                today: now.format("YYYY-MM-DD"),
                weekends: [],
                week: []
            };

            date.addDay(ws ? -wd+1 : -wd);

            for(i = 0; i < 42; i++) {
                result.days.push(date.format("YYYY-MM-DD"));
                date.add(1, 'day');
            }

            result.weekends = result.days.filter(function(v, i){
                var def = [0,6,7,13,14,20,21,27,28,34,35,41];
                var iso = [5,6,12,13,19,20,26,27,33,34,40,41];

                return ws === 0 ? def.indexOf(i) > -1 : iso.indexOf(i) > -1;
            });

            date = now.clone();
            wd = ws ? date.isoWeekDay() : date.weekDay();
            date.addDay(ws ? -wd+1 : -wd);
            for (i = 0; i < 7; i++) {
                result.week.push(date.format("YYYY-MM-DD"));
                date.add(1, 'day');
            }

            return result;
        }
    });
}());

(function() {
    'use strict';

    var oldFormat = Datetime.prototype.format;

    Datetime.use({
        century: function(){
            return parseInt(this.year() / 100);
        },

        format: function(format, locale){
            format = format || Datetime.DEFAULT_FORMAT;
            var matches = {
                C: this.century()
            }
            var result = format.replace(/(\[[^\]]+])|C/g, function(match, $1){
                return $1 || matches[match];
            })
            return oldFormat.bind(this)(result, locale)
        }
    })
}());
(function() {
    'use strict';

    Datetime.use({
        same: function(d){
            return this.time() === datetime(d).time();
        },
        compare: function(d, align, operator){
            var date = datetime(d);
            var curr = datetime(this.value);
            var t1, t2;

            operator = operator || "=";

            if (["<", ">", ">=", "<=", "=", "!="].indexOf(operator) === -1) {
                operator = "=";
            }

            align = (align || "ms").toLowerCase();

            t1 = curr.align(align).time();
            t2 = date.align(align).time();

            switch (operator) {
                case "<":
                    return t1 < t2;
                case ">":
                    return t1 > t2;
                case "<=":
                    return t1 <= t2;
                case ">=":
                    return t1 >= t2;
                case "=":
                    return t1 === t2;
                case "!=":
                    return t1 !== t2;
            }
        },

        between: function(d1, d2){
            return this.younger(d1) && this.older(d2);
        },

        older: function(date, align){
            return this.compare(date, align, "<");
        },

        olderOrEqual: function(date, align){
            return this.compare(date, align, "<=");
        },

        younger: function(date, align){
            return this.compare(date, align, ">");
        },

        youngerOrEqual: function(date, align){
            return this.compare(date, align, ">=");
        },

        equal: function(date, align){
            return this.compare(date, align, "=");
        },

        notEqual: function(date, align){
            return this.compare(date, align, "!=");
        },

        diff: function(d){
            var date = datetime(d);
            var diff = Math.abs(this.time() - date.time());
            var diffMonth = Math.abs(this.month() - date.month() + (12 * (this.year() - date.year())));

            return {
                "ms": diff,
                "second": Math.ceil(diff / 1000),
                "minute": Math.ceil(diff / (1000 * 60)),
                "hour": Math.ceil(diff / (1000 * 60 * 60)),
                "day": Math.ceil(diff / (1000 * 60 * 60 * 24)),
                "month": diffMonth,
                "year": Math.floor(diffMonth / 12)
            }
        },

        distance: function(d, align){
            return this.diff(d)[align];
        }
    })
}());
(function() {
    'use strict';

    Datetime.use({
        dayOfYear: function(){
            var dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            var month = this.month();
            var day = this.day();
            return dayCount[month] + day + ((month > 1 && this.isLeapYear()) ? 1 : 0);
        }
    })
}());
(function() {
    'use strict';

    Datetime.use({
        daysInMonth: function(){
            var curr = datetime(this.value);
            return curr.add(1, 'month').day(1).add(-1, 'day').day();
        },

        daysInYear: function(){
            return this.isLeapYear() ? 366 : 365;
        },

        daysInYearMap: function(){
            var result = [];
            var curr = datetime(this.value);

            curr.month(0).day(1);

            for(var i = 0; i < 12; i++) {
                curr.add(1, 'month').add(-1, 'day');
                result.push(curr.day());
                curr.day(1).add(1, 'month');
            }
            return result;
        },

        daysInYearObj: function(locale, shortName){
            var map = this.daysInYearMap();
            var result = {};
            var names = Datetime.getLocale(locale || this.locale);

            map.forEach(function(v, i){
                result[names[shortName ? 'monthsShort' : 'months'][i]] = v;
            });

            return result;
        }
    })
}());
(function() {
    'use strict';

    Datetime.use({
        decade: function(){
            return Math.floor(this.year()/10) * 10;
        },

        decadeStart: function(){
            var decade = this.decade();
            var result = this.mutable ? this : this.clone();

            return result.year(decade).month(0).day(1);
        },

        decadeEnd: function(){
            var decade = this.decade() + 9;
            var result = this.mutable ? this : this.clone();

            return result.year(decade).month(11).day(31);
        },

        decadeOfMonth: function(){
            var part = this.clone().add(1, "month").day(1).add(-1, 'day').day() / 3;
            var day = this.day();

            if (day <= part) return 1;
            if (day <= part * 2) return 2;
            return 3;
        }
    })
}());
(function() {
    'use strict';

    Datetime.useStatic({
        from: function(str, format, locale){
            var norm, normFormat, fItems, dItems;
            var iMonth, iDay, iYear, iHour, iMinute, iSecond, iMs;
            var year, month, day, hour, minute, second, ms;
            var parsedMonth;

            var getIndex = function(where, what){
                return where.map(function(el){
                    return el.toLowerCase();
                }).indexOf(what.toLowerCase());
            }

            var monthNameToNumber = function(month){
                var i = -1;
                var names = Datetime.getLocale(locale || 'en');

                if (Datetime.not(month)) return -1;

                i = getIndex(names.months, month);

                if (i === -1 && typeof names["monthsParental"] !== "undefined") {
                    i = getIndex(names.monthsParental, month);
                }

                if (i === -1) {
                    month = month.substr(0, 3);
                    i = getIndex(names.monthsShort, month);
                }

                return i === -1 ? -1 : i + 1;
            };

            var getPartIndex = function(part){
                var parts = {
                    "month": ["M", "mm", "%m"],
                    "day": ["D", "dd", "%d"],
                    "year": ["YY", "YYYY", "yy", "yyyy", "%y"],
                    "hour": ["h", "hh", "%h"],
                    "minute": ["m", "mi", "i", "ii", "%i"],
                    "second": ["s", "ss", "%s"],
                    "ms": ["sss"]
                }

                var result = -1, key, index;

                for(var i = 0; i < parts[part].length; i++) {
                    key = parts[part][i];
                    index = fItems.indexOf(key);
                    if (index !== -1) {
                        result = index;
                        break;
                    }
                }

                return result;
            }

            if (Datetime.not(format) || (""+format).trim() === "") {
                return datetime();
            }
            norm = str.replace(/[\/,.:\s]/g, '-');
            normFormat = format.toLowerCase().replace(/[^a-zA-Z0-9%]/g, '-');
            fItems = normFormat.split('-');
            dItems = norm.split('-');

            if (norm.replace(/-/g,"").trim() === "") {
                throw new Error(Datetime.INVALID_DATE);
            }

            iMonth = getPartIndex("month");
            iDay = getPartIndex("day");
            iYear = getPartIndex("year");
            iHour = getPartIndex("hour");
            iMinute = getPartIndex("minute");
            iSecond = getPartIndex("second");
            iMs = getPartIndex("ms");

            if (iMonth > -1 && dItems[iMonth]) {
                if (isNaN(parseInt(dItems[iMonth]))) {
                    dItems[iMonth] = monthNameToNumber(dItems[iMonth]);
                    if (dItems[iMonth] === -1) {
                        iMonth = -1;
                    }
                } else {
                    parsedMonth = parseInt(dItems[iMonth]);
                    if (parsedMonth < 1 || parsedMonth > 12) {
                        iMonth = -1;
                    }
                }
            } else {
                iMonth = -1;
            }

            year  = iYear > -1 && dItems[iYear] ? dItems[iYear] : 0;
            month = iMonth > -1 && dItems[iMonth] ? dItems[iMonth] : 1;
            day   = iDay > -1 && dItems[iDay] ? dItems[iDay] : 1;

            hour    = iHour > -1 && dItems[iHour] ? dItems[iHour] : 0;
            minute  = iMinute > -1 && dItems[iMinute] ? dItems[iMinute] : 0;
            second  = iSecond > -1 && dItems[iSecond] ? dItems[iSecond] : 0;
            ms  = iMs > -1 && dItems[iMs] ? dItems[iMs] : 0;

            return datetime(year, month-1, day, hour, minute, second, ms);
        }
    })
}());
(function() {
    'use strict';

    var fnFormat = Datetime.prototype.format;
    var lpad = Datetime.lpad;

    Datetime.use({
        ampm: function(isLowerCase){
            var val = this.hour() < 12 ? "AM" : "PM";
            return isLowerCase ? val.toLowerCase() : val;
        },

        hour12: function(h, p){
            var hour = h;

            if (arguments.length === 0) {
                return this.hour() % 12;
            }

            p = p || 'am';

            if (p.toLowerCase() === "pm") {
                hour += 12;
            }

            return this.hour(hour);
        },

        format: function(format, locale){
            var matches, result, h12 = this.hour12();

            format = format || Datetime.DEFAULT_FORMAT;

            matches = {
                a: "["+this.ampm(true)+"]",
                A: "["+this.ampm(false)+"]",
                h: h12,
                hh: lpad(h12, "0", 2)
            };

            result = format.replace(/(\[[^\]]+])|a|A|h{1,2}/g, function(match, $1){
                return $1 || matches[match];
            });

            return fnFormat.bind(this)(result, locale)
        }
    })
}());
(function() {
    'use strict';

    Datetime.use({
        isLeapYear: function(){
            var year = this.year();
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }
    })
}());
(function() {
    'use strict';

    var fnFormat = Datetime.prototype.format;
    var fnAlign = Datetime.align;
    var fnAlignEnd = Datetime.alignEnd;

    Datetime.useStatic({
        align: function(d, align){
            var date = d instanceof Datetime ? d : datetime(d),
                result, temp;

            switch(align) {
                case "isoWeek":
                    temp = date.isoWeekDay();
                    result = fnAlign(date, 'day').addDay(-temp + 1);
                    break; // isoWeek

                default: result = fnAlign.apply(this, [date, align]);
            }

            return result;
        },

        alignEnd: function(d, align){
            var date = d instanceof Datetime ? d : datetime(d),
                result, temp;

            switch(align) {
                case "isoWeek":
                    temp = date.isoWeekDay();
                    result = fnAlignEnd(date, 'day').addDay(7 - temp);
                    break; // isoWeek

                default: result = fnAlignEnd.apply(this, [date, align]);
            }

            return result;
        }
    })

    Datetime.use({
        isoWeekDay: function(val){
            var wd = (this.weekDay() + 6) % 7 + 1;

            if (!arguments.length || (Datetime.not(val))) {
                return wd;
            }

            return this.addDay(val - wd);
        },

        format: function(format, locale){
            format = format || Datetime.DEFAULT_FORMAT;
            var matches = {
                I: this.isoWeekDay()
            }
            var result = format.replace(/(\[[^\]]+])|I{1,2}/g, function(match, $1){
                return $1 || matches[match];
            })
            return fnFormat.bind(this)(result, locale)
        }
    })
}());
(function() {
    'use strict';

    Datetime.useStatic({
        max: function(){
            var arr = [].slice.call(arguments);

            return arr.map(function(el){
                return datetime(el);
            }).sort(function(a, b){
                return b.time() - a.time()
            })[0];
        }
    });

    Datetime.use({
        max: function(){
            return Datetime.max.apply(this, [this].concat([].slice.call(arguments)));
        }
    });
}());
(function() {
    'use strict';

    Datetime.useStatic({
        min: function(){
            var arr = [].slice.call(arguments);

            return arr.map(function(el){
                return datetime(el);
            }).sort(function(a, b){
                return a.time() - b.time()
            })[0];
        }
    });

    Datetime.use({
        min: function(){
            return Datetime.min.apply(this, [this].concat([].slice.call(arguments)));
        }
    })
}());
(function() {
    'use strict';

    var fnAlign = Datetime.align;
    var fnAlignEnd = Datetime.alignEnd;
    var fnAdd = Datetime.prototype.add;

    Datetime.useStatic({
        align: function(d, align){
            var date = d instanceof Datetime ? d : datetime(d),
                result;

            switch(align) {
                case "quarter":  result = Datetime.align(date, 'day').day(1).month(date.quarter() * 3 - 3); break; //quarter
                default: result = fnAlign.apply(this, [date, align]);
            }

            return result;
        },

        alignEnd: function(d, align){
            var date = d instanceof Datetime ? d : datetime(d),
                result;

            switch(align) {
                case "quarter":  result = Datetime.align(date, 'quarter').add(3, 'month').add(-1, 'ms'); break; //quarter
                default: result = fnAlignEnd.apply(this, [date, align]);
            }

            return result;
        }
    })

    Datetime.use({
        quarter: function(){
            var month = this.month();

            if (month <= 2) return 1;
            if (month <= 5) return 2;
            if (month <= 8) return 3;
            return 4;
        },

        add: function(val, to){
            if (to === "quarter") {
                return this.month(this.month() + val * 3);
            }
            return fnAdd.bind(this)(val, to);
        },

        addQuarter: function(v){
            return this.add(v, "quarter");
        }
    })
}());
(function() {
    'use strict';

    Datetime.useStatic({
        sort: function(arr, opt){
            var result, _arr;
            var o = {};

            if (typeof opt === "string" || typeof opt !== "object" || Datetime.not(opt)) {
                o.format = Datetime.DEFAULT_FORMAT;
                o.dir = opt && opt.toUpperCase() === "DESC" ? "DESC" : "ASC";
                o.returnAs = "datetime";
            } else {
                o.format = opt.format || Datetime.DEFAULT_FORMAT;
                o.dir = (opt.dir || "ASC").toUpperCase();
                o.returnAs = opt.format ? "string" : opt.returnAs || "datetime";
            }

            _arr =  arr.map(function(el){
                return datetime(el);
            }).sort(function(a, b){
                return a.valueOf() - b.valueOf();
            });

            if (o.dir === "DESC") {
                _arr.reverse();
            }

            switch (o.returnAs) {
                case "string":
                    result = _arr.map(function(el){
                        return el.format(o.format)
                    });
                    break;
                case "date":
                    result = _arr.map(function(el){
                        return el.val();
                    });
                    break;

                default: result = _arr;
            }

            return result;
        }
    })
}());
(function() {
    'use strict';

    var REGEX_FORMAT_STRFTIME = /(%[a-z])/gi;
    var DEFAULT_FORMAT_STRFTIME = "%Y-%m-%dT%H:%M:%S.%Q%t";

    var lpad = Datetime.lpad;

    Datetime.use({
        strftime: function(fmt, locale){
            var format = fmt || DEFAULT_FORMAT_STRFTIME;
            var names = Datetime.getLocale(locale || this.locale);
            var year = this.year(), year2 = this.year2(), month = this.month(), day = this.day(), weekDay = this.weekDay();
            var hour = this.hour(), hour12 = this.hour12(), minute = this.minute(), second = this.second(), ms = this.ms(), time = this.time();
            var aDay = lpad(day, "0", 2),
                aMonth = lpad(month + 1, "0", 2),
                aHour = lpad(hour, "0", 2),
                aHour12 = lpad(hour12, "0", 2),
                aMinute = lpad(minute, "0", 2),
                aSecond = lpad(second, "0", 2),
                aMs = lpad(ms, "0", 3);

            var that = this;

            var thursday = function(){
                var target = datetime(that.value);
                target.day(that.day() - ((that.weekDay() + 6) % 7) + 3);
                return target;
            };

            var matches = {
                '%a': names.weekdaysShort[weekDay],
                '%A': names.weekdays[weekDay],
                '%b': names.monthsShort[month],
                '%h': names.monthsShort[month],
                '%B': names.months[month],
                '%c': this.toString().substring(0, this.toString().indexOf(" (")),
                '%C': this.century(),
                '%d': aDay,
                '%D': [aDay, aMonth, year].join("/"),
                '%e': day,
                '%F': [year, aMonth, aDay].join("-"),
                '%G': thursday().year(),
                '%g': (""+thursday().year()).slice(2),
                '%H': aHour,
                '%I': aHour12,
                '%j': lpad(this.dayOfYear(), "0", 3),
                '%k': aHour,
                '%l': aHour12,
                '%m': aMonth,
                '%n': month + 1,
                '%M': aMinute,
                '%p': this.ampm(),
                '%P': this.ampm(true),
                '%s': Math.round(time / 1000),
                '%S': aSecond,
                '%u': this.isoWeekDay(),
                '%V': this.isoWeekNumber(),
                '%w': weekDay,
                '%x': this.toLocaleDateString(),
                '%X': this.toLocaleTimeString(),
                '%y': year2,
                '%Y': year,
                '%z': this.timezone().replace(":", ""),
                '%Z': this.timezoneName(),
                '%r': [aHour12, aMinute, aSecond].join(":") + " " + this.ampm(),
                '%R': [aHour, aMinute].join(":"),
                "%T": [aHour, aMinute, aSecond].join(":"),
                "%Q": aMs,
                "%q": ms,
                "%t": this.timezone()
            };

            return format.replace(REGEX_FORMAT_STRFTIME, function(match){
                return (matches[match] === 0 || matches[match] ? matches[match] : match);
            });
        }
    });
}());
(function() {
    'use strict';

    var fnFormat = Datetime.prototype.format;

    Datetime.use({
        utcOffset: function(){
            return this.value.getTimezoneOffset();
        },

        timezone: function(){
            return this.toTimeString().replace(/.+GMT([+-])(\d{2})(\d{2}).+/, '$1$2:$3');
        },

        timezoneName: function(){
            return this.toTimeString().replace(/.+\((.+?)\)$/, '$1');
        },

        format: function(format, locale){
            format = format || Datetime.DEFAULT_FORMAT;

            var matches = {
                Z: this.utcMode ? "Z" : this.timezone(),
                ZZ: this.timezone().replace(":", ""),
                ZZZ: "[GMT]"+this.timezone(),
                z: this.timezoneName()
            }
            var result = format.replace(/(\[[^\]]+])|Z{1,3}|z/g, function(match, $1){
                return $1 || matches[match];
            })

            return fnFormat.bind(this)(result, locale)
        }
    })
}());
(function() {
    'use strict';

    Datetime.useStatic({
        isToday: function(date){
            var d = datetime(date).align("day");
            var c = datetime().align('day');

            return d.time() === c.time();
        }
    })

    Datetime.use({
        isToday: function(){
            return Datetime.isToday(this);
        },

        today: function(){
            var now = datetime();
            if (!this.mutable) {
                return now;
            }
            return this.val(now.val());
        }
    })
}());
(function() {
    'use strict';

    Datetime.useStatic({
        isTomorrow: function(date){
            var d = datetime(date).align("day");
            var c = datetime().align('day').add(1, 'day');

            return d.time() === c.time();
        }
    });

    Datetime.use({
        isTomorrow: function(){
            return Datetime.isTomorrow(this);
        },

        tomorrow: function(){
            if (!this.mutable) {
                return this.clone().add(1, 'day');
            }
            return this.add(1, 'day');
        }
    });
}());
(function() {
    'use strict';

    Datetime.use({
        toDateString: function(){
            return this.value.toDateString();
        },

        toISOString: function(){
            return this.value.toISOString();
        },

        toJSON: function(){
            return this.value.toJSON();
        },

        toGMTString: function(){
            return this.value.toGMTString();
        },

        toLocaleDateString: function(){
            return this.value.toLocaleDateString();
        },

        toLocaleString: function(){
            return this.value.toLocaleString();
        },

        toLocaleTimeString: function(){
            return this.value.toLocaleTimeString();
        },

        toTimeString: function(){
            return this.value.toTimeString();
        },

        toUTCString: function(){
            return this.value.toUTCString();
        },

        toDate: function(){
            return new Date(this.value);
        }
    });
}());
(function() {
    'use strict';

    Datetime.useStatic({
        timestamp: function(){
            return new Date().getTime() / 1000;
        }
    })

    Datetime.use({
        unix: function(val) {
            var _val;

            if (!arguments.length || (Datetime.not(val))) {
                return Math.floor(this.valueOf() / 1000)
            }

            _val = val * 1000;

            if (this.mutable) {
                return this.time(_val);
            }

            return datetime(this.value).time(_val);
        },

        timestamp: function(){
            return this.unix();
        }
    });
}());
(function() {
    'use strict';

    var fnFormat = Datetime.prototype.format;
    var lpad = Datetime.lpad;

    Datetime.use({
        weekNumber: function (weekStart) {
            var nYear, nday, newYear, day, daynum, weeknum;

            weekStart = +weekStart || 0;
            newYear = datetime(this.year(), 0, 1);
            day = newYear.weekDay() - weekStart;
            day = (day >= 0 ? day : day + 7);
            daynum = Math.floor(
                (this.time() - newYear.time() - (this.utcOffset() - newYear.utcOffset()) * 60000) / 86400000
            ) + 1;

            if(day < 4) {
                weeknum = Math.floor((daynum + day - 1) / 7) + 1;
                if(weeknum > 52) {
                    nYear = datetime(this.year() + 1, 0, 1);
                    nday = nYear.weekDay() - weekStart;
                    nday = nday >= 0 ? nday : nday + 7;
                    weeknum = nday < 4 ? 1 : 53;
                }
            }
            else {
                weeknum = Math.floor((daynum + day - 1) / 7);
            }
            return weeknum;
        },

        isoWeekNumber: function(){
            return this.weekNumber(1);
        },

        weeksInYear: function(weekStart){
            var curr = datetime(this.value);
            return curr.month(11).day(31).weekNumber(weekStart);
        },

        format: function(format, locale){
            var matches, result, wn = this.weekNumber(), wni = this.isoWeekNumber();

            format = format || Datetime.DEFAULT_FORMAT;

            matches = {
                W: wn,
                WW: lpad(wn, "0", 2),
                WWW: wni,
                WWWW: lpad(wni, "0", 2)
            };

            result = format.replace(/(\[[^\]]+])|W{1,4}/g, function(match, $1){
                return $1 || matches[match];
            });

            return fnFormat.bind(this)(result, locale)
        }
    })
}());
(function() {
    'use strict';

    Datetime.useStatic({
        isYesterday: function(date){
            var d = datetime(date).align("day");
            var c = datetime().align('day').add(-1, 'day');

            return d.time() === c.time();
        }
    });

    Datetime.use({
        isYesterday: function(){
            return Datetime.isYesterday(this);
        },

        yesterday: function(){
            if (!this.mutable) {
                return this.clone().add(-1, 'day');
            }
            return this.add(-1, 'day');
        }
    })
}());


(function() {
    'use strict';

    var getLocale = Datetime.getLocale;

    Datetime.getLocale = function(locale){
        var data;

        if (!Metro) {
            locale = 'en';
            return getLocale.call(this, locale);
        }

        if (!Metro.locales[locale]) {
            locale = "en-US";
        }

        data = Metro.locales[locale]['calendar'];

        return {
            months: data.months.filter( function(el, i){ return i < 12} ),
            monthsShort: data.months.filter( function(el, i){ return i > 11} ),
            weekdays: data.days.filter( function(el, i){ return i < 7} ),
            weekdaysShort: data.days.filter( function(el, i){ return i > 13} ),
            weekdaysMin: data.days.filter( function(el, i){ return i > 6 && i < 14} ),
            weekStart: data.weekStart
        }
    }
}());

/*! 
 * Cake string library 1.0.0
 * https://github.com/olton/cake
 *
 * Copyright 2020-2021 Serhii Pimenov
 * Released under the MIT license
 */

(function () {
    'use strict';

    var isNull = function isNull(val) {
      return val === undefined || val === null;
    };

    /**
     * A regular expression string matching digits
     */
    var digit = '\\d';
    /**
     * A regular expression string matching whitespace
     */

    var whitespace = "\\s\\uFEFF\\xA0";
    /**
     * A regular expression string matching diacritical mark
     */

    var diacriticalMark = "\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F";
    /**
     * A regular expression to match the General Punctuation Unicode block
     */

    var generalPunctuationBlock = "\\u2000-\\u206F";
    /**
     * A regular expression to match non characters from from Basic Latin and Latin-1 Supplement Unicode blocks
     */

    var nonCharacter = '\\x00-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7b-\\xBF\\xD7\\xF7';
    /**
     * A regular expression to match the dingbat Unicode block
     */

    var dingbatBlock = "\\u2700-\\u27BF";
    /**
     * A regular expression string that matches lower case letters: LATIN
     */

    var lowerCaseLetter = "a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F";
    /**
     * A regular expression string that matches upper case letters: LATIN
     */

    var upperCaseLetter = "\\x41-\\x5a\\xc0-\\xd6\\xd8-\\xde\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc\\u01c4\\u01c5\\u01c7\\u01c8\\u01ca\\u01cb\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f2\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e";

    /**
     * Regular expression to match whitespaces from the left side
     */

    var REGEXP_TRIM_LEFT = new RegExp('^[' + whitespace + ']+');
    /**
     * Regular expression to match whitespaces from the right side
     */

    var REGEXP_TRIM_RIGHT = new RegExp('[' + whitespace + ']+$');
    /**
     * Regular expression to match digit characters
     */

    var REGEXP_DIGIT = new RegExp('^' + digit + '+$');
    /**
     * Regular expression to match HTML special characters.
     */

    var REGEXP_HTML_SPECIAL_CHARACTERS = /[<>&"'`]/g;
    var REGEXP_TAGS = /(<([^>]+)>)/ig;
    /**
     * Regular expression to match Unicode words
     */

    var REGEXP_WORD = new RegExp('(?:[' + upperCaseLetter + '][' + diacriticalMark + ']*)?(?:[' + lowerCaseLetter + '][' + diacriticalMark + ']*)+|\
(?:[' + upperCaseLetter + '][' + diacriticalMark + ']*)+(?![' + lowerCaseLetter + '])|\
[' + digit + ']+|\
[' + dingbatBlock + ']|\
[^' + nonCharacter + generalPunctuationBlock + whitespace + ']+', 'g');
    /**
     * Regular expression to match words from Basic Latin and Latin-1 Supplement blocks
     */

    var REGEXP_LATIN_WORD = /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g;
    /**
     * Regular expression to match alpha characters
     */

    var REGEXP_ALPHA = new RegExp('^(?:[' + lowerCaseLetter + upperCaseLetter + '][' + diacriticalMark + ']*)+$');
    /**
     * Regular expression to match alpha and digit characters
     */

    var REGEXP_ALPHA_DIGIT = new RegExp('^((?:[' + lowerCaseLetter + upperCaseLetter + '][' + diacriticalMark + ']*)|[' + digit + '])+$');
    /**
     * Regular expression to match Extended ASCII characters, i.e. the first 255
     */

    var REGEXP_EXTENDED_ASCII = /^[\x01-\xFF]*$/;

    function nvl(val, def) {
      return isNull(val) ? def : val;
    }

    function toStr(val) {
      var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      if (isNull(val)) return def;
      if (typeof val === "string") return val;
      if (Array.isArray(val)) return val.join("");
      return JSON.stringify(val);
    }

    /*
    * Split string to words. You can set specified patter to split
    * */

    function words(s, pattern, flags) {
      var regexp;

      if (isNull(pattern)) {
        regexp = REGEXP_EXTENDED_ASCII.test(s) ? REGEXP_LATIN_WORD : REGEXP_WORD;
      } else if (pattern instanceof RegExp) {
        regexp = pattern;
      } else {
        regexp = new RegExp(pattern, nvl(flags, ''));
      }

      return nvl(toStr(s).match(regexp), []);
    }

    function capitalize(s, strong) {
      var _s = toStr(s);

      var last = _s.substr(1);

      return _s.substr(0, 1).toUpperCase() + (strong ? last.toLowerCase() : last);
    }

    function camelCase(s) {
      return words(toStr(s)).map(function (el, i) {
        return i === 0 ? el.toLowerCase() : capitalize(el);
      }).join("");
    }

    function dashedName(s) {
      return words(toStr(s)).map(function (el) {
        return el.toLowerCase();
      }).join("-");
    }

    function decapitalize(s) {
      var _s = toStr(s);

      return _s.substr(0, 1).toLowerCase() + _s.substr(1);
    }

    function kebab(s) {
      return words(toStr(s)).map(function (el) {
        return el.toLowerCase();
      }).join("-");
    }

    function lower(s) {
      return toStr(s).toLowerCase();
    }

    /*
    * Split string to chars array with ignores
    * */

    function chars(s) {
      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return toStr(s).split("").filter(function (el) {
        return !ignore.includes(el);
      });
    }

    function reverse(s, ignore) {
      return chars(toStr(s), ignore).reverse().join("");
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function shuffleArray (a) {
      var _a = _toConsumableArray(a);

      var i = _a.length,
          t,
          r;

      while (0 !== i) {
        r = Math.floor(Math.random() * i);
        i -= 1;
        t = _a[i];
        _a[i] = _a[r];
        _a[r] = t;
      }

      return _a;
    }

    function shuffle(s) {
      var _s = toStr(s);

      return shuffleArray(_s.split("")).join("");
    }

    function snake(s) {
      return words(toStr(s)).map(function (el) {
        return el.toLowerCase();
      }).join("_");
    }

    var _swap = function _swap(swapped, _char) {
      var lc = _char.toLowerCase();

      var uc = _char.toUpperCase();

      return swapped + (_char === lc ? uc : lc);
    };

    function swap(s) {
      return toStr(s).split("").reduce(_swap, '');
    }

    function title(s, noSplit) {
      var _s = toStr(s);

      var regexp = REGEXP_EXTENDED_ASCII.test(_s) ? REGEXP_LATIN_WORD : REGEXP_WORD;
      var noSplitArray = Array.isArray(noSplit) ? noSplit : isNull(noSplit) ? [] : noSplit.split();
      return s.replace(regexp, function (w, i) {
        var isNoSplit = i && noSplitArray.includes(_s[i - 1]);
        return isNoSplit ? lower(w) : capitalize(w);
      });
    }

    function upper(s) {
      return toStr(s).toUpperCase();
    }

    function wrapTag(s) {
      var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "div";
      return "<".concat(tag, ">").concat(toStr(s), "</").concat(tag, ">");
    }

    function wrap(s) {
      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      return before + toStr(s) + after;
    }

    /*
    * Get string length
    * */

    function count(s) {
      return toStr(s).length;
    }

    function un (a) {
      var _a = _toConsumableArray(a);

      for (var i = 0; i < _a.length; ++i) {
        for (var j = i + 1; j < _a.length; ++j) {
          if (_a[i] === _a[j]) _a.splice(j--, 1);
        }
      }

      return _a;
    }

    function countChars(s, ignore) {
      return chars(s, ignore).length;
    }
    function countUniqueChars(s, ignore) {
      return un(chars(s, ignore)).length;
    }

    function countSubstr(s, sub) {
      var _s = toStr(s);

      var _sub = toStr(sub);

      return _s === '' || _sub === '' ? 0 : _s.split(_sub).length - 1;
    }

    function countWords(s, pattern, flags) {
      return words(s, pattern, flags).length;
    }
    function countUniqueWords(s, pattern, flags) {
      return un(words(s, pattern, flags)).length;
    }

    var escapeCharactersMap = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };

    function replaceSpecialCharacter(character) {
      return escapeCharactersMap[character];
    }

    function escapeHtml(s) {
      return toStr(s).replace(REGEXP_HTML_SPECIAL_CHARACTERS, replaceSpecialCharacter);
    }

    var unescapeCharsMap = {
      '<': /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi,
      '>': /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi,
      '&': /(&amp;)|(&#x0*26;)|(&#0*38;)/gi,
      '"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi,
      "'": /(&#x0*27;)|(&#0*39;)/gi,
      '`': /(&#x0*60;)|(&#0*96;)/gi
    };
    var chars$1 = Object.keys(unescapeCharsMap);

    function reduceUnescapedString(string, key) {
      return string.replace(unescapeCharsMap[key], key);
    }

    function unescapeHtml(s) {
      return chars$1.reduce(reduceUnescapedString, toStr(s));
    }

    function unique(s, ignore) {
      return un(chars(s, ignore)).join("");
    }

    function uniqueWords(s, pattern, flags) {
      return un(words(s, pattern, flags)).join("");
    }

    /*
    * Get substring from string.
    * */

    function substr(s, start, len) {
      var _s = toStr(s);

      return _s.substr(start, len);
    }

    /*
    * Get N first chars from string.
    * */

    function first(s, len) {
      var _s = toStr(s);

      return _s ? substr(_s, 0, len) : '';
    }

    /*
    * Get N last chars from string.
    * */

    function last(s, len) {
      var _s = toStr(s);

      return _s ? substr(_s, _s.length - len) : '';
    }

    var MAX_SAFE_INTEGER = 0x1fffffffffffff;

    function clip(val, min) {
      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_SAFE_INTEGER;
      if (val < min) return min;
      if (val > max) return max;
      return val;
    }

    function toInt(val) {
      if (val === Infinity) return MAX_SAFE_INTEGER;
      if (val === -Infinity) return -MAX_SAFE_INTEGER;
      return ~~val;
    }

    /*
    * Truncates `subject` to a new `length` with specified ending.
    * */

    function truncate(s, len) {
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';

      var _s = toStr(s);

      var _len = isNull(len) || isNaN(len) ? _s.length : clip(toInt(len), 0, MAX_SAFE_INTEGER);

      return substr(_s, 0, _len) + (_s.length === _len ? '' : end);
    }

    /*
    * Slice string to N parts.
    * */

    function slice(s) {
      var parts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var _s = toStr(s);

      var res = [];
      var len = Math.round(_s.length / parts);

      for (var i = 0; i < parts; i++) {
        res.push(substr(_s, i * len, len));
      }

      return res;
    }

    /*
    * Truncates `subject` to a new `length` and does not break the words with specified ending.
    * */

    function prune(s, len) {
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

      var _s = toStr(s);

      var _len = isNull(len) || isNaN(len) ? _s.length : clip(toInt(len), 0, MAX_SAFE_INTEGER);

      var _truncatedLen = 0;
      var pattern = REGEXP_EXTENDED_ASCII.test(_s) ? REGEXP_LATIN_WORD : REGEXP_WORD;

      _s.replace(pattern, function (word, offset) {
        var wordLength = offset + word.length;

        if (wordLength <= _len - end.length) {
          _truncatedLen = wordLength;
        }
      });

      return _s.substr(0, _truncatedLen) + end;
    }

    function repeat(s, times) {
      var _s = toStr(s);

      var _times = isNull(times) || isNaN(times) ? _s.length : clip(toInt(times), 0, MAX_SAFE_INTEGER);

      var _origin = _s;

      if (times === 0) {
        return "";
      }

      for (var i = 0; i < _times - 1; i++) {
        _s += _origin;
      }

      return _s;
    }

    function padBuilder(pad, len) {
      var padLength = pad.length;
      var length = len - padLength;
      return repeat(pad, length + 1).substr(0, len);
    }

    function pad(s, len) {
      var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';

      var _s = toStr(s);

      var _len = isNull(len) || isNaN(len) ? _s.length : clip(toInt(len), 0, MAX_SAFE_INTEGER);

      var _padLen = pad.length;

      var _paddingLen = _len - _s.length;

      var _sideLen = toInt(_paddingLen / 2); //?


      var _remainingLen = _paddingLen % 2; //?


      if (_paddingLen <= 0 || _padLen === 0) {
        return _s;
      }

      return padBuilder(pad, _sideLen) + _s + padBuilder(pad, _sideLen + _remainingLen); //?
    }

    var _pad = function _pad(s, len, pad, left) {
      var _s = toStr(s);

      var _len = isNull(len) || isNaN(len) ? _s.length : clip(toInt(len), 0, MAX_SAFE_INTEGER);

      var _padLen = pad.length;

      var _paddingLen = _len - _s.length;

      var _sideLen = _paddingLen;

      if (_paddingLen <= 0 || _padLen === 0) {
        return _s;
      }

      var pads = padBuilder(pad, _sideLen);
      return left ? pads + _s : _s + pads;
    };

    function lpad(s, len) {
      var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';
      return _pad(s, len, pad, true);
    }
    function rpad(s, len) {
      var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';
      return _pad(s, len, pad, false);
    }

    function insert(s) {
      var sbj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var _s = toStr(s);

      return _s.substr(0, pos) + sbj + _s.substr(pos);
    }

    var reduce = Array.prototype.reduce;
    var reduceRight = Array.prototype.reduceRight;
    function trim(s, ws) {
      return ltrim(rtrim(s, ws), ws);
    }
    function ltrim(s, ws) {
      var _s = toStr(s);

      if (isNull(ws)) {
        return _s.replace(REGEXP_TRIM_LEFT, '');
      }

      if (ws === '' || _s === '') {
        return _s;
      }

      if (typeof ws !== "string") {
        ws = '';
      }

      var match = true;
      return reduce.call(_s, function (trimmed, _char) {
        if (match && ws.includes(_char)) {
          return trimmed;
        }

        match = false;
        return trimmed + _char;
      }, '');
    }
    function rtrim(s, ws) {
      var _s = toStr(s);

      if (isNull(ws)) {
        return _s.replace(REGEXP_TRIM_RIGHT, '');
      }

      if (ws === '' || _s === '') {
        return _s;
      }

      if (typeof ws !== "string") {
        ws = '';
      }

      var match = true;
      return reduceRight.call(_s, function (trimmed, _char2) {
        if (match && ws.includes(_char2)) {
          return trimmed;
        }

        match = false;
        return _char2 + trimmed;
      }, '');
    }

    function endsWith(s, end, pos) {
      var _s = toStr(s);

      return _s.endsWith(end, pos);
    }

    function isAlpha(s) {
      return REGEXP_ALPHA.test(toStr(s));
    }

    function isAlphaDigit(s) {
      return REGEXP_ALPHA_DIGIT.test(toStr(s));
    }

    function isAlphaDigit$1(s) {
      return REGEXP_DIGIT.test(toStr(s));
    }

    function isBlank(s) {
      return trim(s).length === 0;
    }

    function isEmpty(s) {
      return toStr(s).length === 0;
    }

    function isLower(s) {
      var _s = toStr(s);

      return _s.toLowerCase() === _s;
    }

    function isUpper(s) {
      var _s = toStr(s);

      return _s.toUpperCase() === _s;
    }

    function startWith(s, start, pos) {
      var _s = toStr(s);

      return _s.startsWith(start, pos);
    }

    function stripTagsAll(s) {
      var _s = toStr(s);

      return _s.replace(REGEXP_TAGS, '');
    }
    function stripTags(s) {
      var allowed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var _s = toStr(s);

      var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
      return _s.replace(tags, function ($0, $1) {

        return allowed.includes($1) ? $0 : '';
      });
    }

    /*
    * Original code
    * copyright (c) 2007-present by Alexandru Mărășteanu <hello@alexei.ro>
    * Source: https://github.com/alexei/sprintf.js
    * License: BSD-3-Clause License
    * */
    var re = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };

    function sprintf_format(parse_tree, argv) {
      var cursor = 1,
          tree_length = parse_tree.length,
          arg,
          output = '',
          ph,
          pad,
          pad_character,
          pad_length,
          is_positive,
          sign;

      for (var i = 0; i < tree_length; i++) {
        if (typeof parse_tree[i] === 'string') {
          output += parse_tree[i];
        } else if (_typeof(parse_tree[i]) === 'object') {
          ph = parse_tree[i]; // convenience purposes only

          if (ph.keys) {
            // keyword argument
            arg = argv[cursor];

            for (var k = 0; k < ph.keys.length; k++) {
              if (typeof arg === "undefined") {
                throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }

              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            // positional argument (explicit)
            arg = argv[ph.param_no];
          } else {
            // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }

          if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
            throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
          }

          if (re.number.test(ph.type)) {
            is_positive = arg >= 0;
          }

          switch (ph.type) {
            case 'b':
              arg = parseInt(arg, 10).toString(2);
              break;

            case 'c':
              arg = String.fromCharCode(parseInt(arg, 10));
              break;

            case 'd':
            case 'i':
              arg = parseInt(arg, 10);
              break;

            case 'j':
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;

            case 'e':
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;

            case 'f':
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;

            case 'g':
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;

            case 'o':
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;

            case 's':
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;

            case 't':
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;

            case 'T':
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;

            case 'u':
              arg = parseInt(arg, 10) >>> 0;
              break;

            case 'v':
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;

            case 'x':
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;

            case 'X':
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }

          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign = is_positive ? '+' : '-';
              arg = arg.toString().replace(re.sign, '');
            } else {
              sign = '';
            }

            pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
            pad_length = ph.width - (sign + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
            output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
          }
        }
      }

      return output;
    }

    var sprintf_cache = Object.create(null);

    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }

      var _fmt = fmt,
          match,
          parse_tree = [],
          arg_names = 0;

      while (_fmt) {
        if ((match = re.text.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = re.modulo.exec(_fmt)) !== null) {
          parse_tree.push('%');
        } else if ((match = re.placeholder.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [],
                replacement_field = match[2],
                field_match = [];

            if ((field_match = re.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);

              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError('[sprintf] failed to parse named argument key');
                }
              }
            } else {
              throw new SyntaxError('[sprintf] failed to parse named argument key');
            }

            match[2] = field_list;
          } else {
            arg_names |= 2;
          }

          if (arg_names === 3) {
            throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
          }

          parse_tree.push({
            placeholder: match[0],
            param_no: match[1],
            keys: match[2],
            sign: match[3],
            pad_char: match[4],
            align: match[5],
            width: match[6],
            precision: match[7],
            type: match[8]
          });
        } else {
          throw new SyntaxError('[sprintf] unexpected placeholder');
        }

        _fmt = _fmt.substring(match[0].length);
      }

      return sprintf_cache[fmt] = parse_tree;
    }

    function sprintf(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf.apply(null, [fmt].concat(argv || []));
    }

    function includes(s, sub, pos) {
      var _s = toStr(s);

      return _s.includes(sub, pos);
    }

    var functions = {
      camelCase: camelCase,
      capitalize: capitalize,
      chars: chars,
      count: count,
      countChars: countChars,
      countUniqueChars: countUniqueChars,
      countSubstr: countSubstr,
      countWords: countWords,
      countUniqueWords: countUniqueWords,
      dashedName: dashedName,
      decapitalize: decapitalize,
      kebab: kebab,
      lower: lower,
      reverse: reverse,
      shuffle: shuffle,
      snake: snake,
      swap: swap,
      title: title,
      upper: upper,
      words: words,
      wrap: wrap,
      wrapTag: wrapTag,
      escapeHtml: escapeHtml,
      unescapeHtml: unescapeHtml,
      unique: unique,
      uniqueWords: uniqueWords,
      substr: substr,
      first: first,
      last: last,
      truncate: truncate,
      slice: slice,
      prune: prune,
      repeat: repeat,
      pad: pad,
      lpad: lpad,
      rpad: rpad,
      insert: insert,
      trim: trim,
      ltrim: ltrim,
      rtrim: rtrim,
      endsWith: endsWith,
      isAlpha: isAlpha,
      isAlphaDigit: isAlphaDigit,
      isDigit: isAlphaDigit$1,
      isBlank: isBlank,
      isEmpty: isEmpty,
      isLower: isLower,
      isUpper: isUpper,
      startWith: startWith,
      stripTags: stripTags,
      stripTagsAll: stripTagsAll,
      sprintf: sprintf,
      vsprintf: vsprintf,
      includes: includes
    };

    var __global = null;

    function getGlobalObject() {
      if (__global !== null) {
        return __global;
      }

      if ((typeof global === "undefined" ? "undefined" : _typeof(global)) === 'object' && global.Object === Object) {
        __global = global;
      } else if ((typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && self.Object === Object) {
        __global = self;
      } else {
        __global = new Function('return this')();
      }

      return __global;
    }

    var _Symbol$toPrimitive, _Symbol$toStringTag;
    _Symbol$toPrimitive = Symbol.toPrimitive;
    _Symbol$toStringTag = Symbol.toStringTag;

    var Cake = /*#__PURE__*/function () {
      function Cake() {
        var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

        _classCallCheck(this, Cake);

        _defineProperty(this, "_value", void 0);

        this._value = "" + s;
      }

      _createClass(Cake, [{
        key: _Symbol$toPrimitive,
        value: function value(hint) {
          if (hint === "number") {
            return +this.value;
          }

          return this.value;
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.value;
        }
        /* escape */

      }, {
        key: "escapeHtml",
        value: function escapeHtml() {
          this.value = functions.escapeHtml(this.value);
          return this;
        }
      }, {
        key: "unescapeHtml",
        value: function unescapeHtml() {
          this.value = functions.unescapeHtml(this.value);
          return this;
        }
        /* end of escape */

      }, {
        key: "camelCase",
        value: function camelCase() {
          this.value = functions.camelCase(this.value);
          return this;
        }
      }, {
        key: "capitalize",
        value: function capitalize(strong) {
          this.value = functions.capitalize(this.value, strong);
          return this;
        }
      }, {
        key: "chars",
        value: function chars() {
          return functions.chars(this.value);
        }
      }, {
        key: "count",
        value: function count() {
          return functions.count(this.value);
        }
      }, {
        key: "countChars",
        value: function countChars(ignore) {
          return functions.countChars(this.value, ignore);
        }
      }, {
        key: "countUniqueChars",
        value: function countUniqueChars(ignore) {
          return functions.countUniqueChars(this.value, ignore);
        }
      }, {
        key: "countSubstr",
        value: function countSubstr(sub) {
          return functions.countSubstr(this.value, sub);
        }
      }, {
        key: "countWords",
        value: function countWords(pattern, flags) {
          return functions.countWords(this.value, pattern, flags);
        }
      }, {
        key: "countUniqueWords",
        value: function countUniqueWords(pattern, flags) {
          return functions.countUniqueWords(this.value, pattern, flags);
        }
      }, {
        key: "dashedName",
        value: function dashedName() {
          this.value = functions.dashedName(this.value);
          return this;
        }
      }, {
        key: "decapitalize",
        value: function decapitalize() {
          this.value = functions.decapitalize(this.value);
          return this;
        }
      }, {
        key: "kebab",
        value: function kebab() {
          this.value = functions.kebab(this.value);
          return this;
        }
      }, {
        key: "lower",
        value: function lower() {
          this.value = functions.lower(this.value);
          return this;
        }
      }, {
        key: "reverse",
        value: function reverse() {
          this.value = functions.reverse(this.value);
          return this;
        }
      }, {
        key: "shuffle",
        value: function shuffle() {
          this.value = functions.shuffle(this.value);
          return this;
        }
      }, {
        key: "snake",
        value: function snake() {
          this.value = functions.snake(this.value);
          return this;
        }
      }, {
        key: "swap",
        value: function swap() {
          this.value = functions.swap(this.value);
          return this;
        }
      }, {
        key: "title",
        value: function title() {
          this.value = functions.title(this.value);
          return this;
        }
      }, {
        key: "upper",
        value: function upper() {
          this.value = functions.upper(this.value);
          return this;
        }
      }, {
        key: "words",
        value: function words(pattern, flags) {
          return functions.words(this.value, pattern, flags);
        }
      }, {
        key: "wrap",
        value: function wrap(a, b) {
          this.value = functions.wrap(this.value, a, b);
          return this;
        }
      }, {
        key: "wrapTag",
        value: function wrapTag(t) {
          this.value = functions.wrapTag(this.value, t);
          return this;
        }
      }, {
        key: "pad",
        value: function pad(len, _pad) {
          this.value = functions.pad(this.value, len, _pad);
          return this;
        }
      }, {
        key: "lpad",
        value: function lpad(len, pad) {
          this.value = functions.lpad(this.value, len, pad);
          return this;
        }
      }, {
        key: "rpad",
        value: function rpad(len, pad) {
          this.value = functions.rpad(this.value, len, pad);
          return this;
        }
      }, {
        key: "repeat",
        value: function repeat(times) {
          this.value = functions.repeat(this.value, times);
          return this;
        }
      }, {
        key: "prune",
        value: function prune(len, end) {
          this.value = functions.prune(this.value, len, end);
          return this;
        }
      }, {
        key: "slice",
        value: function slice(parts) {
          return functions.slice(this.value, parts);
        }
      }, {
        key: "truncate",
        value: function truncate(len, end) {
          this.value = functions.truncate(this.value, len, end);
          return this;
        }
      }, {
        key: "last",
        value: function last(len) {
          this.value = functions.last(this.value, len);
          return this;
        }
      }, {
        key: "first",
        value: function first(len) {
          this.value = functions.first(this.value, len);
          return this;
        }
      }, {
        key: "substr",
        value: function substr(start, len) {
          this.value = functions.substr(this.value, start, len);
          return this;
        }
      }, {
        key: "unique",
        value: function unique(ignore) {
          return functions.unique(this.value, ignore);
        }
      }, {
        key: "uniqueWords",
        value: function uniqueWords(pattern, flags) {
          return functions.uniqueWords(this.value, pattern, flags);
        }
      }, {
        key: "insert",
        value: function insert(sbj, pos) {
          this.value = functions.insert(this.value, sbj, pos);
          return this;
        }
      }, {
        key: "trim",
        value: function trim(ws) {
          this.value = functions.trim(this.value, ws);
          return this;
        }
      }, {
        key: "ltrim",
        value: function ltrim(ws) {
          this.value = functions.ltrim(this.value, ws);
          return this;
        }
      }, {
        key: "rtrim",
        value: function rtrim(ws) {
          this.value = functions.rtrim(this.value, ws);
          return this;
        }
      }, {
        key: "endsWith",
        value: function endsWith(end, pos) {
          return functions.endsWith(this.value, end, pos);
        }
      }, {
        key: "startWith",
        value: function startWith(start, pos) {
          return functions.startWith(this.value, start, pos);
        }
      }, {
        key: "isAlpha",
        value: function isAlpha() {
          return functions.isAlpha(this.value);
        }
      }, {
        key: "isAlphaDigit",
        value: function isAlphaDigit() {
          return functions.isAlphaDigit(this.value);
        }
      }, {
        key: "isDigit",
        value: function isDigit() {
          return functions.isDigit(this.value);
        }
      }, {
        key: "isBlank",
        value: function isBlank() {
          return functions.isBlank(this.value);
        }
      }, {
        key: "isEmpty",
        value: function isEmpty() {
          return functions.isEmpty(this.value);
        }
      }, {
        key: "isLower",
        value: function isLower() {
          return functions.isLower(this.value);
        }
      }, {
        key: "isUpper",
        value: function isUpper() {
          return functions.isUpper(this.value);
        }
      }, {
        key: "stripTagsAll",
        value: function stripTagsAll() {
          this.value = functions.stripTagsAll(this.value);
          return this;
        }
      }, {
        key: "stripTags",
        value: function stripTags(allowed) {
          this.value = functions.stripTags(this.value, allowed);
          return this;
        }
      }, {
        key: "sprintf",
        value: function sprintf(args) {
          return functions.sprintf(this.value, args);
        }
      }, {
        key: "vsprintf",
        value: function vsprintf(args) {
          return functions.vsprintf(this.value, args);
        }
      }, {
        key: "includes",
        value: function includes(sub, pos) {
          return functions.includes(this.value, sub, pos);
        }
      }, {
        key: _Symbol$toStringTag,
        get: function get() {
          return "Cake";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(s) {
          this._value = s;
        }
      }, {
        key: "length",
        get: function get() {
          return this._value.length;
        }
      }]);

      return Cake;
    }();

    var cake = function cake(s) {
      return new Cake(s);
    };

    var Cake$1 = Object.assign({}, functions);
    var global$1 = getGlobalObject();
    global$1.Cake = Cake$1;
    global$1.cake = cake;

}());


(function (global, undefined) {

// Source: src/mode.js

/* jshint -W097 */
'use strict';

// Source: src/func.js

/* global dataSet */
/* exported isDark, isTouch, isSimple, isHidden, isPlainObject, isEmptyObject, isArrayLike, str2arr, parseUnit, getUnit, setStyleProp, acceptData, dataAttr, normName, strip, dashedName, isLocalhost */

var numProps = ['opacity', 'zIndex', "order", "zoom"];

function isSimple(v){
    return typeof v === "string" || typeof v === "boolean" || typeof v === "number";
}

function isVisible(elem) {
    return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
}

function isHidden(elem) {
    var s = getComputedStyle(elem);
    return !isVisible(elem) || +s.opacity === 0 || elem.hidden || s.visibility === "hidden";
}

function not(value){
    return value === undefined || value === null;
}

function camelCase(string){
    return string.replace( /-([a-z])/g, function(all, letter){
        return letter.toUpperCase();
    });
}

function dashedName(str){
    return str.replace(/([A-Z])/g, function(u) { return "-" + u.toLowerCase(); });
}

function isPlainObject( obj ) {
    var proto;
    if ( !obj || Object.prototype.toString.call( obj ) !== "[object Object]" ) {
        return false;
    }
    proto = obj.prototype !== undefined;
    if ( !proto ) {
        return true;
    }
    return proto.constructor && typeof proto.constructor === "function";
}

function isEmptyObject( obj ) {
    for (var name in obj ) {
        if (hasProp(obj, name)) return false;
    }
    return true;
}

function isArrayLike (o){
    return o instanceof Object && 'length' in o;
}

function str2arr (str, sep) {
    sep = sep || " ";
    return str.split(sep).map(function(el){
        return  (""+el).trim();
    }).filter(function(el){
        return el !== "";
    });
}

function parseUnit(str, out) {
    if (!out) out = [ 0, '' ];
    str = String(str);
    out[0] = parseFloat(str);
    out[1] = str.match(/[\d.\-+]*\s*(.*)/)[1] || '';
    return out;
}

function getUnit(val, und){
    var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
    return typeof split[1] !== "undefined" ? split[1] : und;
}

function setStyleProp(el, key, val){
    key = camelCase(key);

    if (["scrollLeft", "scrollTop"].indexOf(key) > -1) {
        el[key] = (parseInt(val));
    } else {
        el.style[key] = isNaN(val) || numProps.indexOf(""+key) > -1 ? val : val + 'px';
    }
}

function acceptData(owner){
    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
}

function getData(data){
    try {
        return JSON.parse(data);
    } catch (e) {
        return data;
    }
}

function dataAttr(elem, key, data){
    var name;

    if ( not(data) && elem.nodeType === 1 ) {
        name = "data-" + key.replace( /[A-Z]/g, "-$&" ).toLowerCase();
        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            data = getData( data );
            dataSet.set( elem, key, data );
        } else {
            data = undefined;
        }
    }
    return data;
}

function normName(name) {
    return typeof name !== "string" ? undefined : name.replace(/-/g, "").toLowerCase();
}

function strip(name, what) {
    return typeof name !== "string" ? undefined : name.replace(what, "");
}

function hasProp(obj, prop){
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

function isLocalhost(host){
    var hostname = host || window.location.hostname;
    return (
        hostname === "localhost" ||
        hostname === "127.0.0.1" ||
        hostname === "[::1]" ||
        hostname === "" ||
        hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) !== null
    );
}

function isTouch() {
    return (('ontouchstart' in window)
        || (navigator.maxTouchPoints > 0)
        || (navigator.msMaxTouchPoints > 0));
}

function isDark(){
    var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)")
    return prefersDarkScheme.matches
}

// Source: src/setimmediate.js

/* global global */
/*
 * setImmediate polyfill
 * Version 1.0.5
 * Url: https://github.com/YuzuJS/setImmediate
 * Copyright (c) 2016 Yuzu (https://github.com/YuzuJS)
 * Licensed under MIT
 */
(function (global) {

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var registerImmediate;

    function setImmediate(callback) {
        if (typeof callback !== "function") {
            /* jshint -W054 */
            callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        tasksByHandle[nextHandle] = { callback: callback, args: args };
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    // global.process
    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            global.process.nextTick(function () { runIfPresent(handle); });
        };
    }

    // web workers
    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    // Browsers
    function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        global.addEventListener("message", onGlobalMessage, false);

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    if ({}.toString.call(global.process) === "[object process]") {

        installNextTickImplementation();

    } else if (global.MessageChannel) {

        installMessageChannelImplementation();

    } else {

        installPostMessageImplementation();

    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;

}(typeof self === "undefined" ? typeof global === "undefined" ? window : global : self));

// Source: src/core.js

/* global hasProp */

var m4qVersion = "v1.1.0. Built at 05/05/2021 22:47:56";

/* eslint-disable-next-line */
var matches = Element.prototype.matches
    || Element.prototype.matchesSelector
    || Element.prototype.webkitMatchesSelector
    || Element.prototype.mozMatchesSelector
    || Element.prototype.msMatchesSelector
    || Element.prototype.oMatchesSelector;

var $ = function(selector, context){
    return new $.init(selector, context);
};

$.version = m4qVersion;

$.fn = $.prototype = {
    version: m4qVersion,
    constructor: $,
    length: 0,
    uid: "",

    push: [].push,
    sort: [].sort,
    splice: [].splice,
    indexOf: [].indexOf,
    reverse: [].reverse
};

$.extend = $.fn.extend = function(){
    var options, name,
        target = arguments[ 0 ] || {},
        i = 1,
        length = arguments.length;

    if ( typeof target !== "object" && typeof target !== "function" ) {
        target = {};
    }

    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        if ( ( options = arguments[ i ] ) != null ) {
            for ( name in options ) {
                if (hasProp(options, name))
                    target[ name ] = options[ name ];
            }
        }
    }

    return target;
};

$.assign = function(){
    var options, name,
        target = arguments[ 0 ] || {},
        i = 1,
        length = arguments.length;

    if ( typeof target !== "object" && typeof target !== "function" ) {
        target = {};
    }

    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        if ( ( options = arguments[ i ] ) != null ) {
            for ( name in options ) {
                if (hasProp(options, name) && options[name] !== undefined)
                    target[ name ] = options[ name ];
            }
        }
    }

    return target;
};

// if (typeof window["hideM4QVersion"] === "undefined") console.info("m4q " + $.version);

// Source: src/interval.js

/* global $ */

var now = function(){
    return Date.now();
};

$.extend({

    intervalId: -1,
    intervalQueue: [],
    intervalTicking: false,
    intervalTickId: null,

    setInterval: function(fn, int){
        var that = this;

        this.intervalId++;

        this.intervalQueue.push({
            id: this.intervalId,
            fn: fn,
            interval: int,
            lastTime: now()
        });

        if (!this.intervalTicking) {
            var tick = function(){
                that.intervalTickId = requestAnimationFrame(tick);
                $.each(that.intervalQueue, function(){
                    var item = this;
                    if (item.interval < 17 || now() - item.lastTime >= item.interval) {
                        item.fn();
                        item.lastTime = now();
                    }
                });
            };
            this.intervalTicking = true;
            tick();
        }

        return this.intervalId;
    },

    clearInterval: function(id){
        for(var i = 0; i < this.intervalQueue.length; i++){
            if (id === this.intervalQueue[i].id) {
                this.intervalQueue.splice(i, 1);
                break;
            }
        }
        if (this.intervalQueue.length === 0) {
            cancelAnimationFrame(this.intervalTickId);
            this.intervalTicking = false;
        }
    },

    setTimeout: function(fn, interval){
        var that = this, id = this.setInterval(function(){
            that.clearInterval(id);
            fn();
        }, interval);

        return id;
    },

    clearTimeout: function(id){
        return this.clearInterval(id);
    }
});

// Source: src/contains.js

/* global $, not, matches, isArrayLike, isVisible */

$.fn.extend({
    index: function(sel){
        var el, _index = -1;

        if (this.length === 0) {
            return _index;
        }

        if (not(sel)) {
            el = this[0];
        } else if (sel instanceof $ && sel.length > 0) {
            el = sel[0];
        } else if (typeof sel === "string") {
            el = $(sel)[0];
        } else {
            el = undefined;
        }

        if (not(el)) {
            return _index;
        }

        if (el && el.parentNode) $.each(el.parentNode.children, function(i){
            if (this === el) {
                _index = i;
            }
        });
        return _index;
    },

    get: function(i){
        if (i === undefined) {
            return this.items();
        }
        return i < 0 ? this[ i + this.length ] : this[ i ];
    },

    eq: function(i){
        return !not(i) && this.length > 0 ? $.extend($(this.get(i)), {_prevObj: this}) : this;
    },

    is: function(s){
        var result = false;

        if (this.length === 0) {
            return false;
        }

        if (s instanceof $) {
            return this.same(s);
        }

        if (s === ":selected") {
            this.each(function(){
                if (this.selected) result = true;
            });
        } else

        if (s === ":checked") {
            this.each(function(){
                if (this.checked) result = true;
            });
        } else

        if (s === ":visible") {
            this.each(function(){
                if (isVisible(this)) result = true;
            });
        } else

        if (s === ":hidden") {
            this.each(function(){
                var styles = getComputedStyle(this);
                if (
                    this.getAttribute('type') === 'hidden'
                        || this.hidden
                        || styles.display === 'none'
                        || styles.visibility === 'hidden'
                        || parseInt(styles.opacity) === 0
                ) result = true;
            });
        } else

        if (typeof  s === "string" && [':selected'].indexOf(s) === -1) {
            this.each(function(){
                if (matches.call(this, s)) {
                    result = true;
                }
            });
        } else

        if (isArrayLike(s)) {
            this.each(function(){
                var el = this;
                $.each(s, function(){
                    var sel = this;
                    if (el === sel) {
                        result = true;
                    }
                });
            });
        } else

        if (typeof s === "object" && s.nodeType === 1) {
            this.each(function(){
                if  (this === s) {
                    result = true;
                }
            });
        }

        return result;
    },

    same: function(o){
        var result = true;

        if (!(o instanceof $)) {
            o = $(o);
        }

        if (this.length !== o.length) return false;

        this.each(function(){
            if (o.items().indexOf(this) === -1) {
                result = false;
            }
        });

        return result;
    },

    last: function(){
        return this.eq(this.length - 1);
    },

    first: function(){
        return this.eq(0);
    },

    odd: function(){
        var result = this.filter(function(el, i){
            return i % 2 === 0;
        });
        return $.extend(result, {_prevObj: this});
    },

    even: function(){
        var result = this.filter(function(el, i){
            return i % 2 !== 0;
        });
        return $.extend(result, {_prevObj: this});
    },

    filter: function(fn){
        if (typeof fn === "string") {
            var sel = fn;
            fn = function(el){
                return matches.call(el, sel);
            };
        }

        return $.extend($.merge($(), [].filter.call(this, fn)), {_prevObj: this});
    },

    find: function(s){
        var res = [], result;

        if (s instanceof $) return s;

        if (this.length === 0) {
            result = this;
        } else {
            this.each(function () {
                var el = this;
                if (typeof el.querySelectorAll === "undefined") {
                    return ;
                }
                res = res.concat([].slice.call(el.querySelectorAll(s)));
            });
            result = $.merge($(), res);
        }

        return $.extend(result, {_prevObj: this});
    },

    contains: function(s){
        return this.find(s).length > 0;
    },

    children: function(s){
        var i, res = [];

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            for(i = 0; i < el.children.length; i++) {
                if (el.children[i].nodeType === 1)
                    res.push(el.children[i]);
            }
        });
        res = s ? res.filter(function(el){
            return matches.call(el, s);
        }) : res;

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    parent: function(s){
        var res = [];
        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            if (this.parentNode) {
                if (res.indexOf(this.parentNode) === -1) res.push(this.parentNode);
            }
        });
        res = s ? res.filter(function(el){
            return matches.call(el, s);
        }) : res;

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    parents: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var par = this.parentNode;
            while (par) {
                if (par.nodeType === 1 && res.indexOf(par) === -1) {
                    if (!not(s)) {
                        if (matches.call(par, s)) {
                            res.push(par);
                        }
                    } else {
                        res.push(par);
                    }
                }
                par = par.parentNode;
            }
        });

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    siblings: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            if (el.parentNode) {
                $.each(el.parentNode.children, function(){
                    if (el !== this) res.push(this);
                });
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    _siblingAll: function(dir, s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this;
            while (el) {
                el = el[dir];
                if (!el) break;
                res.push(el);
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    _sibling: function(dir, s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        this.each(function(){
            var el = this[dir];
            if (el && el.nodeType === 1) {
                res.push(el);
            }
        });

        if (s) {
            res = res.filter(function(el){
                return matches.call(el, s);
            });
        }

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    prev: function(s){
        return this._sibling('previousElementSibling', s);
    },

    next: function(s){
        return this._sibling('nextElementSibling', s);
    },

    prevAll: function(s){
        return this._siblingAll('previousElementSibling', s);
    },

    nextAll: function(s){
        return this._siblingAll('nextElementSibling', s);
    },

    closest: function(s){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        if (s instanceof $) return s;

        if (!s) {
            return this.parent(s);
        }

        this.each(function(){
            var el = this;
            while (el) {
                if (!el) break;
                if (matches.call(el, s)) {
                    res.push(el);
                    return ;
                }
                el = el.parentElement;
            }
        });

        return $.extend($.merge($(), res.reverse()), {_prevObj: this});
    },

    has: function(selector){
        var res = [];

        if (this.length === 0) {
            return ;
        }

        this.each(function(){
            var el = $(this);
            var child = el.children(selector);
            if (child.length > 0) {
                res.push(this);
            }
        });

        return $.extend($.merge($(), res), {_prevObj: this});
    },

    back: function(to_start){
        var ret;
        if (to_start === true) {
            ret = this._prevObj;
            while (ret) {
                if (!ret._prevObj) break;
                ret = ret._prevObj;
            }
        } else {
            ret = this._prevObj ? this._prevObj : this;
        }
        return ret;
    }
});

// Source: src/script.js

/* global $, not */

function createScript(script){
    var s = document.createElement('script');
    s.type = 'text/javascript';

    if (not(script)) return $(s);

    var _script = $(script)[0];

    if (_script.src) {
        s.src = _script.src;
    } else {
        s.textContent = _script.innerText;
    }

    document.body.appendChild(s);

    if (_script.parentNode) _script.parentNode.removeChild(_script);

    return s;
}

$.extend({
    script: function(el){

        if (not(el)) {
            return createScript();
        }

        var _el = $(el)[0];

        if (_el.tagName && _el.tagName === "SCRIPT") {
            createScript(_el);
        } else $.each($(_el).find("script"), function(){
            createScript(this);
        });
    }
});

$.fn.extend({
    script: function(){
        return this.each(function(){
            $.script(this);
        });
    }
});

// Source: src/prop.js

/* global $, not */

$.fn.extend({
    _prop: function(prop, value){
        if (arguments.length === 1) {
            return this.length === 0 ? undefined : this[0][prop];
        }

        if (not(value)) {
            value = '';
        }

        return this.each(function(){
            var el = this;

            el[prop] = value;

            if (prop === "innerHTML") {
                $.script(el);
            }
        });
    },

    prop: function(prop, value){
        return arguments.length === 1 ? this._prop(prop) : this._prop(prop, typeof value === "undefined" ? "" : value);
    },

    val: function(value){
        if (not(value)) {
            return this.length === 0 ? undefined : this[0].value;
        }

        return this.each(function(){
            var el = $(this);
            if (typeof this.value !== "undefined") {
                this.value = value;
            } else {
                el.html(value);
            }
        });
    },

    html: function(value){
        var that = this, v = [];

        if (arguments.length === 0) {
            return this._prop('innerHTML');
        }

        if (value instanceof $) {
            value.each(function(){
                v.push($(this).outerHTML());
            });
        } else {
            v.push(value);
        }

        that._prop('innerHTML', v.length === 1 && not(v[0]) ? "" : v.join("\n"));

        return this;
    },

    outerHTML: function(){
        return this._prop('outerHTML');
    },

    text: function(value){
        return arguments.length === 0 ? this._prop('textContent') : this._prop('textContent', typeof value === "undefined" ? "" : value);
    },

    innerText: function(value){
        return arguments.length === 0 ? this._prop('innerText') : this._prop('innerText', typeof value === "undefined" ? "" : value);
    },

    empty: function(){
        return this.each(function(){
            if (typeof this.innerHTML !== "undefined") this.innerHTML = "";
        });
    },

    clear: function(){
        return this.empty();
    }
});

// Source: src/each.js

/* global $, isArrayLike, hasProp */

$.each = function(ctx, cb){
    var index = 0;
    if (isArrayLike(ctx)) {
        [].forEach.call(ctx, function(val, key) {
            cb.apply(val, [key, val]);
        });
    } else {
        for(var key in ctx) {
            if (hasProp(ctx, key))
                cb.apply(ctx[key], [key, ctx[key],  index++]);
        }
    }

    return ctx;
};

$.fn.extend({
    each: function(cb){
        return $.each(this, cb);
    }
});


// Source: src/data.js

/* global acceptData, camelCase, $, not, dataAttr, isEmptyObject, hasProp */

/*
 * Data routines
 * Url: https://jquery.com
 * Copyright (c) Copyright JS Foundation and other contributors, https://js.foundation/
 * Licensed under MIT
 */
var Data = function(ns){
    this.expando = "DATASET:UID:" + ns.toUpperCase();
    Data.uid++;
};

Data.uid = -1;

Data.prototype = {
    cache: function(owner){
        var value = owner[this.expando];
        if (!value) {
            value = {};
            if (acceptData(owner)) {
                if (owner.nodeType) {
                    owner[this.expando] = value;
                } else {
                    Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true
                    });
                }
            }
        }
        return value;
    },

    set: function(owner, data, value){
        var prop, cache = this.cache(owner);

        if (typeof data === "string") {
            cache[camelCase(data)] = value;
        } else {
            for (prop in data) {
                if (hasProp(data, prop))
                    cache[camelCase(prop)] = data[prop];
            }
        }
        return cache;
    },

    get: function(owner, key){
        return key === undefined ? this.cache(owner) : owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
    },

    access: function(owner, key, value){
        if (key === undefined || ((key && typeof key === "string") && value === undefined) ) {
            return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== undefined ? value : key;
    },

    remove: function(owner, key){
        var i, cache = owner[this.expando];
        if (cache === undefined) {
            return ;
        }
        if (key !== undefined) {
            if ( Array.isArray( key ) ) {
                key = key.map( camelCase );
            } else {
                key = camelCase( key );

                key = key in cache ? [ key ] : ( key.match( /[^\x20\t\r\n\f]+/g ) || [] ); // ???
            }

            i = key.length;

            while ( i-- ) {
                delete cache[ key[ i ] ];
            }
        }
        if ( key === undefined || isEmptyObject( cache ) ) {
            if ( owner.nodeType ) {
                owner[ this.expando ] = undefined;
            } else {
                delete owner[ this.expando ];
            }
        }
        return true;
    },

    hasData: function(owner){
        var cache = owner[ this.expando ];
        return cache !== undefined && !isEmptyObject( cache );
    }
};

var dataSet = new Data('m4q');

$.extend({
    hasData: function(elem){
        return dataSet.hasData(elem);
    },

    data: function(elem, key, val){
        return dataSet.access(elem, key, val);
    },

    removeData: function(elem, key){
        return dataSet.remove(elem, key);
    },

    dataSet: function(ns){
        if (not(ns)) return dataSet;
        if (['INTERNAL', 'M4Q'].indexOf(ns.toUpperCase()) > -1) {
            throw Error("You can not use reserved name for your dataset");
        }
        return new Data(ns);
    }
});

$.fn.extend({
    data: function(key, val){
        var res, elem, data, attrs, name, i;

        if (this.length === 0) {
            return ;
        }

        elem = this[0];

        if ( arguments.length === 0 ) {
            if ( this.length ) {
                data = dataSet.get( elem );

                if ( elem.nodeType === 1) {
                    attrs = elem.attributes;
                    i = attrs.length;
                    while ( i-- ) {
                        if ( attrs[ i ] ) {
                            name = attrs[ i ].name;
                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = camelCase( name.slice( 5 ) );
                                dataAttr( elem, name, data[ name ] );
                            }
                        }
                    }
                }
            }

            return data;
        }

        if ( arguments.length === 1 ) {
            res = dataSet.get(elem, key);
            if (res === undefined) {
                if ( elem.nodeType === 1) {
                    if (elem.hasAttribute("data-"+key)) {
                        res = elem.getAttribute("data-"+key);
                    }
                }
            }
            return res;
        }

        return this.each( function() {
            dataSet.set( this, key, val );
        } );
    },

    removeData: function( key ) {
        return this.each( function() {
            dataSet.remove( this, key );
        } );
    },

    origin: function(name, value, def){

        if (this.length === 0) {
            return this;
        }

        if (not(name) && not(value)) {
            return $.data(this[0]);
        }

        if (not(value)) {
            var res = $.data(this[0], "origin-"+name);
            return !not(res) ? res : def;
        }

        this.data("origin-"+name, value);

        return this;
    }
});

// Source: src/utils.js

/* global $, not, isDark, camelCase, dashedName, isPlainObject, isEmptyObject, isArrayLike, acceptData, parseUnit, getUnit, isVisible, isHidden, matches, strip, normName, hasProp, isLocalhost, isTouch */

$.extend({

    device: (/android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase())),
    localhost: isLocalhost(),
    isLocalhost: isLocalhost,
    touchable: isTouch(),
    dark: isDark(),

    uniqueId: function (prefix) {
        var d = new Date().getTime();
        if (not(prefix)) {
            prefix = 'm4q';
        }
        return (prefix !== '' ? prefix + '-' : '') + 'xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    },

    toArray: function(n){
        var i, out = [];

        for (i = 0 ; i < n.length; i++ ) {
            out.push(n[i]);
        }

        return out;
    },

    import: function(ctx){
        var res = [];
        this.each(ctx, function(){
            res.push(this);
        });
        return this.merge($(), res);
    },

    merge: function( first, second ) {
        var len = +second.length,
            j = 0,
            i = first.length;

        for ( ; j < len; j++ ) {
            first[ i++ ] = second[ j ];
        }

        first.length = i;

        return first;
    },

    type: function(obj){
        return Object.prototype.toString.call(obj).replace(/^\[object (.+)]$/, '$1').toLowerCase();
    },

    sleep: function(ms) {
        ms += new Date().getTime();
        /* eslint-disable-next-line */
        while (new Date() < ms){}
    },

    isSelector: function(selector){
        if (typeof selector !== 'string') {
            return false;
        }
        try {
            document.querySelector(selector);
        } catch(error) {
            return false;
        }
        return true;
    },

    remove: function(s){
        return $(s).remove();
    },

    camelCase: camelCase,
    dashedName: dashedName,
    isPlainObject: isPlainObject,
    isEmptyObject: isEmptyObject,
    isArrayLike: isArrayLike,
    acceptData: acceptData,
    not: not,
    parseUnit: parseUnit,
    getUnit: getUnit,
    unit: parseUnit,
    isVisible: isVisible,
    isHidden: isHidden,
    matches: function(el, s) {return matches.call(el, s);},
    random: function(from, to) {
        if (arguments.length === 1 && isArrayLike(from)) {
            return from[Math.floor(Math.random()*(from.length))];
        }
        return Math.floor(Math.random()*(to-from+1)+from);
    },
    strip: strip,
    normName: normName,
    hasProp: hasProp,

    serializeToArray: function(form){
        var _form = $(form)[0];
        if (!_form || _form.nodeName !== "FORM") {
            console.warn("Element is not a HTMLFromElement");
            return;
        }
        var i, j, q = [];
        for (i = _form.elements.length - 1; i >= 0; i = i - 1) {
            if (_form.elements[i].name === "") {
                continue;
            }
            switch (_form.elements[i].nodeName) {
                case 'INPUT':
                    switch (_form.elements[i].type) {
                        case 'checkbox':
                        case 'radio':
                            if (_form.elements[i].checked) {
                                q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            }
                            break;
                        case 'file':
                            break;
                        default: q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                    }
                    break;
                case 'TEXTAREA':
                    q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                    break;
                case 'SELECT':
                    switch (_form.elements[i].type) {
                        case 'select-one':
                            q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            break;
                        case 'select-multiple':
                            for (j = _form.elements[i].options.length - 1; j >= 0; j = j - 1) {
                                if (_form.elements[i].options[j].selected) {
                                    q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].options[j].value));
                                }
                            }
                            break;
                    }
                    break;
                case 'BUTTON':
                    switch (_form.elements[i].type) {
                        case 'reset':
                        case 'submit':
                        case 'button':
                            q.push(_form.elements[i].name + "=" + encodeURIComponent(_form.elements[i].value));
                            break;
                    }
                    break;
            }
        }
        return q;
    },
    serialize: function(form){
        return $.serializeToArray(form).join("&");
    }
});

$.fn.extend({
    items: function(){
        return $.toArray(this);
    }
});

// Source: src/events.js

/* global $, not, camelCase, str2arr, normName, matches, isEmptyObject, isPlainObject */

// (function () {
//     if ( typeof window.CustomEvent === "function" ) return false;
//
//     function CustomEvent ( event, params ) {
//         params = params || { bubbles: false, cancelable: false, detail: null };
//         var evt = document.createEvent( 'CustomEvent' );
//         evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
//         return evt;
//     }
//
//     CustomEvent.prototype = window.Event.prototype;
//
//     window.CustomEvent = CustomEvent;
// })();

var overriddenStop =  Event.prototype.stopPropagation;
var overriddenPrevent =  Event.prototype.preventDefault;

Event.prototype.stopPropagation = function(){
    this.isPropagationStopped = true;
    overriddenStop.apply(this, arguments);
};
Event.prototype.preventDefault = function(){
    this.isPreventedDefault = true;
    overriddenPrevent.apply(this, arguments);
};

Event.prototype.stop = function(immediate){
    return immediate ? this.stopImmediatePropagation() : this.stopPropagation();
};

$.extend({
    events: [],
    eventHooks: {},

    eventUID: -1,

    /*
    * el, eventName, handler, selector, ns, id, options
    * */
    setEventHandler: function(obj){
        var i, freeIndex = -1, eventObj, resultIndex;
        if (this.events.length > 0) {
            for(i = 0; i < this.events.length; i++) {
                if (this.events[i].handler === null) {
                    freeIndex = i;
                    break;
                }
            }
        }

        eventObj = {
            element: obj.el,
            event: obj.event,
            handler: obj.handler,
            selector: obj.selector,
            ns: obj.ns,
            id: obj.id,
            options: obj.options
        };

        if (freeIndex === -1) {
            this.events.push(eventObj);
            resultIndex = this.events.length - 1;
        } else {
            this.events[freeIndex] = eventObj;
            resultIndex = freeIndex;
        }

        return resultIndex;
    },

    getEventHandler: function(index){
        if (this.events[index] !== undefined && this.events[index] !== null) {
            this.events[index] = null;
            return this.events[index].handler;
        }
        return undefined;
    },

    off: function(){
        $.each(this.events, function(){
            this.element.removeEventListener(this.event, this.handler, true);
        });
        this.events = [];
        return this;
    },

    getEvents: function(){
        return this.events;
    },

    getEventHooks: function(){
        return this.eventHooks;
    },

    addEventHook: function(event, handler, type){
        if (not(type)) {
            type = "before";
        }
        $.each(str2arr(event), function(){
            this.eventHooks[camelCase(type+"-"+this)] = handler;
        });
        return this;
    },

    removeEventHook: function(event, type){
        if (not(type)) {
            type = "before";
        }
        $.each(str2arr(event), function(){
            delete this.eventHooks[camelCase(type+"-"+this)];
        });
        return this;
    },

    removeEventHooks: function(event){
        var that = this;
        if (not(event)) {
            this.eventHooks = {};
        } else {
            $.each(str2arr(event), function(){
                delete that.eventHooks[camelCase("before-"+this)];
                delete that.eventHooks[camelCase("after-"+this)];
            });
        }
        return this;
    }
});

$.fn.extend({
    on: function(eventsList, sel, handler, options){
        if (this.length === 0) {
            return ;
        }

        if (typeof sel === 'function') {
            options = handler;
            handler = sel;
            sel = undefined;
        }

        if (!isPlainObject(options)) {
            options = {};
        }

        return this.each(function(){
            var el = this;
            $.each(str2arr(eventsList), function(){
                var h, ev = this,
                    event = ev.split("."),
                    name = normName(event[0]),
                    ns = options.ns ? options.ns : event[1],
                    index, originEvent;

                $.eventUID++;

                h = function(e){
                    var target = e.target;
                    var beforeHook = $.eventHooks[camelCase("before-"+name)];
                    var afterHook = $.eventHooks[camelCase("after-"+name)];

                    if (typeof beforeHook === "function") {
                        beforeHook.call(target, e);
                    }

                    if (!sel) {
                        handler.call(el, e);
                    } else {
                        while (target && target !== el) {
                            if (matches.call(target, sel)) {
                                handler.call(target, e);
                                if (e.isPropagationStopped) {
                                    e.stopImmediatePropagation();
                                    break;
                                }
                            }
                            target = target.parentNode;
                        }
                    }

                    if (typeof afterHook === "function") {
                        afterHook.call(target, e);
                    }

                    if (options.once) {
                        index = +$(el).origin( "event-"+e.type+(sel ? ":"+sel:"")+(ns ? ":"+ns:"") );
                        if (!isNaN(index)) $.events.splice(index, 1);
                    }
                };

                Object.defineProperty(h, "name", {
                    value: handler.name && handler.name !== "" ? handler.name : "func_event_"+name+"_"+$.eventUID
                });

                originEvent = name+(sel ? ":"+sel:"")+(ns ? ":"+ns:"");

                el.addEventListener(name, h, !isEmptyObject(options) ? options : false);

                index = $.setEventHandler({
                    el: el,
                    event: name,
                    handler: h,
                    selector: sel,
                    ns: ns,
                    id: $.eventUID,
                    options: !isEmptyObject(options) ? options : false
                });
                $(el).origin('event-'+originEvent, index);
            });
        });
    },

    one: function(events, sel, handler, options){
        if (!isPlainObject(options)) {
            options = {};
        }

        options.once = true;

        return this.on.apply(this, [events, sel, handler, options]);
    },

    off: function(eventsList, sel, options){

        if (isPlainObject(sel)) {
            options = sel;
            sel = null;
        }

        if (!isPlainObject(options)) {
            options = {};
        }

        if (not(eventsList) || eventsList.toLowerCase() === 'all') {
            return this.each(function(){
                var el = this;
                $.each($.events, function(){
                    var e = this;
                    if (e.element === el) {
                        el.removeEventListener(e.event, e.handler, e.options);
                        e.handler = null;
                        $(el).origin("event-"+name+(e.selector ? ":"+e.selector:"")+(e.ns ? ":"+e.ns:""), null);
                    }
                });
            });
        }

        return this.each(function(){
            var el = this;
            $.each(str2arr(eventsList), function(){
                var evMap = this.split("."),
                    name = normName(evMap[0]),
                    ns = options.ns ? options.ns : evMap[1],
                    originEvent, index;

                originEvent = "event-"+name+(sel ? ":"+sel:"")+(ns ? ":"+ns:"");
                index = $(el).origin(originEvent);

                if (index !== undefined && $.events[index].handler) {
                    el.removeEventListener(name, $.events[index].handler, $.events[index].options);
                    $.events[index].handler = null;
                }

                $(el).origin(originEvent, null);
            });
        });
    },

    trigger: function(name, data){
        return this.fire(name, data);
    },

    fire: function(name, data){
        var _name, e;

        if (this.length === 0) {
            return ;
        }

        _name = normName(name);

        if (['focus', 'blur'].indexOf(_name) > -1) {
            this[0][_name]();
            return this;
        }

        if (typeof CustomEvent !== "undefined") {
            e = new CustomEvent(_name, {
                bubbles: true,
                cancelable: true,
                detail: data
            });
        } else {
            e = document.createEvent('Events');
            e.detail = data;
            e.initEvent(_name, true, true);
        }

        return this.each(function(){
            this.dispatchEvent(e);
        });
    }
});

( "blur focus resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu touchstart touchend touchmove touchcancel" )
    .split( " " )
    .forEach(
    function( name ) {
        $.fn[ name ] = function( sel, fn, opt ) {
            return arguments.length > 0 ?
                this.on( name, sel, fn, opt ) :
                this.fire( name );
        };
});

$.fn.extend( {
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    }
});

$.ready = function(fn, options){
    document.addEventListener('DOMContentLoaded', fn, (options || false));
};

$.load = function(fn){
    return $(window).on("load", fn);
};

$.unload = function(fn){
    return $(window).on("unload", fn);
};

$.fn.extend({
    unload: function(fn){
        return (this.length === 0 || this[0].self !== window) ? undefined : $.unload(fn);
    }
});

$.beforeunload = function(fn){
    if (typeof fn === "string") {
        return $(window).on("beforeunload", function(e){
            e.returnValue = fn;
            return fn;
        });
    } else {
        return $(window).on("beforeunload", fn);
    }
};

$.fn.extend({
    beforeunload: function(fn){
        return (this.length === 0 || this[0].self !== window) ? undefined : $.beforeunload(fn);
    }
});

$.fn.extend({
    ready: function(fn){
        if (this.length && this[0] === document && typeof fn === 'function') {
            return $.ready(fn);
        }
    }
});

// Source: src/ajax.js

/* global $, Promise, not, isSimple, isPlainObject, isEmptyObject, camelCase */
/* can be changed to fetch */
$.ajax = function(p){
    return new Promise(function(resolve, reject){
        var xhr = new XMLHttpRequest(), data;
        var method = (p.method || "GET").toUpperCase();
        var headers = [];
        var async = not(p.async) ? true : p.async;
        var url = p.url;
        var urlWithParams = url.indexOf("?") > -1;
        var joinParamsSymbol = urlWithParams ? "&" : "?";

        var exec = function(fn, params){
            if (typeof fn === "function") {
                fn.apply(null, params);
            }
        };

        var isGet = function(method){
            return ["GET", "JSON"].indexOf(method) !== -1;
        };

        var plainObjectToData = function(obj){
            var _data = [];
            $.each(obj, function(k, v){
                var _v = isSimple(v) ? v : JSON.stringify(v);
                _data.push(k+"=" + _v);
            });
            return _data.join("&");
        };

        if (p.data instanceof HTMLFormElement) {
            var _action = p.data.getAttribute("action");
            var _method = p.data.getAttribute("method");

            if (not(url) && _action && _action.trim() !== "") {url = _action;}
            if (_method && _method.trim() !== "") {method = _method.toUpperCase();}
        }


        if (p.timeout) {
            xhr.timeout = p.timeout;
        }

        if (p.withCredentials) {
            xhr.withCredentials = p.withCredentials;
        }

        if (p.data instanceof HTMLFormElement) {
            data = $.serialize(p.data);
        } else if (p.data instanceof HTMLElement && p.data.getAttribute("type") && p.data.getAttribute("type").toLowerCase() === "file") {
            var _name = p.data.getAttribute("name");
            data = new FormData();
            for (var i = 0; i < p.data.files.length; i++) {
                data.append(_name, p.data.files[i]);
            }
        } else if (isPlainObject(p.data)) {
            data = plainObjectToData(p.data);
        } else if (p.data instanceof FormData) {
            data = p.data;
        } else if (typeof p.data === "string") {
            data = p.data;
        } else {
            data = new FormData();
            data.append("_data", JSON.stringify(p.data));
        }

        if (isGet(method)) {
            url += (typeof data === "string" ? joinParamsSymbol + data : isEmptyObject(data) ? "" : joinParamsSymbol + JSON.stringify(data));
        }

        xhr.open(method, url, async, p.user, p.password);
        if (p.headers) {
            $.each(p.headers, function(k, v){
                xhr.setRequestHeader(k, v);
                headers.push(k);
            });
        }
        if (!isGet(method)) {
            if (headers.indexOf("Content-type") === -1 && p.contentType !== false) {
                xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            }
        }
        xhr.send(data);

        xhr.addEventListener("load", function(e){
            if (xhr.readyState === 4 && xhr.status < 300) {
                var _return = p.returnValue && p.returnValue === 'xhr' ? xhr : xhr.response;
                if (p.parseJson) {
                    try {
                        _return = JSON.parse(_return);
                    } catch (ex) {
                        _return = {};
                    }
                }
                exec(resolve, [_return]);
                exec(p.onSuccess, [e, xhr]);
            } else {
                exec(reject, [xhr]);
                exec(p.onFail, [e, xhr]);
            }
            exec(p.onLoad, [e, xhr]);
        });

        $.each(["readystatechange", "error", "timeout", "progress", "loadstart", "loadend", "abort"], function(){
            var ev = camelCase("on-"+(this === 'readystatechange' ? 'state' : this));
            xhr.addEventListener(ev, function(e){
                exec(p[ev], [e, xhr]);
            });
        });
    });
};

['get', 'post', 'put', 'patch', 'delete', 'json'].forEach(function(method){
    $[method] = function(url, data, options){
        var _method = method.toUpperCase();
        var _options = {
            method: _method === 'JSON' ? 'GET' : _method,
            url: url,
            data: data,
            parseJson: _method === 'JSON'
        };
        return $.ajax($.extend({}, _options, options));
    };
});

$.fn.extend({
    load: function(url, data, options){
        var that = this;

        if (this.length && this[0].self === window ) {
            return $.load(url);
        }

        return $.get(url, data, options).then(function(data){
            that.each(function(){
                this.innerHTML = data;
            });
        });
    }
});

// Source: src/css.js

/* global $, not, setStyleProp */

$.fn.extend({

    style: function(name, pseudo){
        var el;

        function _getStyle(el, prop, pseudo){
            return ["scrollLeft", "scrollTop"].indexOf(prop) > -1 ? $(el)[prop]() : getComputedStyle(el, pseudo)[prop];
        }

        if (typeof name === 'string' && this.length === 0) {
            return undefined;
        }

        if (this.length === 0) {
            return this;
        }

        el = this[0];

        if (not(name) || name === "all") {
            return getComputedStyle(el, pseudo);
        } else {
            var result = {}, names = name.split(", ").map(function(el){
                return (""+el).trim();
            });
            if (names.length === 1)  {
                return _getStyle(el, names[0], pseudo);
            } else {
                $.each(names, function () {
                    var prop = this;
                    result[this] = _getStyle(el, prop, pseudo);
                });
                return result;
            }
        }
    },

    removeStyleProperty: function(name){
        if (not(name) || this.length === 0) return this;
        var names = name.split(", ").map(function(el){
            return (""+el).trim();
        });

        return this.each(function(){
            var el = this;
            $.each(names, function(){
                el.style.removeProperty(this);
            });
        });
    },

    css: function(key, val){
        key = key || 'all';

        if (typeof key === "string" && not(val)) {
            return  this.style(key);
        }

        return this.each(function(){
            var el = this;
            if (typeof key === "object") {
                $.each(key, function(key, val){
                    setStyleProp(el, key, val);
                });
            } else if (typeof key === "string") {
                setStyleProp(el, key, val);
            }
        });
    },

    scrollTop: function(val){
        if (not(val)) {
            return this.length === 0 ? undefined : this[0] === window ? pageYOffset : this[0].scrollTop;
        }
        return this.each(function(){
            this.scrollTop = val;
        });
    },

    scrollLeft: function(val){
        if (not(val)) {
            return this.length === 0 ? undefined : this[0] === window ? pageXOffset : this[0].scrollLeft;
        }
        return this.each(function(){
            this.scrollLeft = val;
        });
    }
});



// Source: src/classes.js

/* global $, not */

$.fn.extend({
    addClass: function(){},
    removeClass: function(){},
    toggleClass: function(){},

    containsClass: function(cls){
        return this.hasClass(cls);
    },

    hasClass: function(cls){
        var result = false;
        var classes = cls.split(" ").filter(function(v){
            return (""+v).trim() !== "";
        });

        if (not(cls)) {
            return false;
        }

        this.each(function(){
            var el = this;

            $.each(classes, function(){
                if (!result && el.classList && el.classList.contains(this)) {
                    result = true;
                }
            });
        });

        return result;
    },

    clearClasses: function(){
        return this.each(function(){
            this.className = "";
        });
    },

    cls: function(array){
        return this.length === 0 ? undefined : array ? this[0].className.split(" ") : this[0].className;
    },

    removeClassBy: function(mask){
        return this.each(function(){
            var el = $(this);
            var classes = el.cls(true);
            $.each(classes, function(){
                var elClass = this;
                if (elClass.indexOf(mask) > -1) {
                    el.removeClass(elClass);
                }
            });
        });
    }
});

['add', 'remove', 'toggle'].forEach(function (method) {
    $.fn[method + "Class"] = function(cls){
        if (not(cls) || (""+cls).trim() === "") return this;
        return this.each(function(){
            var el = this;
            var hasClassList = typeof el.classList !== "undefined";
            $.each(cls.split(" ").filter(function(v){
                return (""+v).trim() !== "";
            }), function(){
                if (hasClassList) el.classList[method](this);
            });
        });
    };
});


// Source: src/parser.js

/* global $ */

$.parseHTML = function(data){
    var base, singleTag, result = [], ctx, _context;
    var regexpSingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // eslint-disable-line

    if (typeof data !== "string") {
        return [];
    }

    data = data.trim();

    ctx = document.implementation.createHTMLDocument("");
    base = ctx.createElement( "base" );
    base.href = document.location.href;
    ctx.head.appendChild( base );
    _context = ctx.body;

    singleTag = regexpSingleTag.exec(data);

    if (singleTag) {
        result.push(document.createElement(singleTag[1]));
    } else {
        _context.innerHTML = data;
        for(var i = 0; i < _context.childNodes.length; i++) {
            result.push(_context.childNodes[i]);
        }
    }

    return result;
};


// Source: src/size.js

/* global $, not */

$.fn.extend({
    _size: function(prop, val){
        if (this.length === 0) return ;

        if (not(val)) {

            var el = this[0];

            if (prop === 'height') {
                return el === window ? window.innerHeight : el === document ? el.body.clientHeight : parseInt(getComputedStyle(el).height);
            }
            if (prop === 'width') {
                return el === window ? window.innerWidth : el === document ? el.body.clientWidth : parseInt(getComputedStyle(el).width);
            }
        }

        return this.each(function(){
            var el = this;
            if (el === window || el === document) {return ;}
            el.style[prop] = isNaN(val) ? val : val + 'px';
        });
    },

    height: function(val){
        return this._size('height', val);
    },

    width: function(val){
        return this._size('width', val);
    },

    _sizeOut: function(prop, val){
        var el, size, style, result;

        if (this.length === 0) {
            return ;
        }

        if (!not(val) && typeof val !== "boolean") {
            return this.each(function(){
                var el = this;
                if (el === window || el === document) {return ;}
                var h, style = getComputedStyle(el),
                    bs = prop === 'width' ? parseInt(style['border-left-width']) + parseInt(style['border-right-width']) : parseInt(style['border-top-width']) + parseInt(style['border-bottom-width']),
                    pa = prop === 'width' ? parseInt(style['padding-left']) + parseInt(style['padding-right']) : parseInt(style['padding-top']) + parseInt(style['padding-bottom']);

                h = $(this)[prop](val)[prop]() - bs - pa;
                el.style[prop] = h + 'px';
            });
        }

        el = this[0];
        size = el[prop === 'width' ? 'offsetWidth' : 'offsetHeight'];
        style = getComputedStyle(el);
        result = size + parseInt(style[prop === 'width' ? 'margin-left' : 'margin-top']) + parseInt(style[prop === 'width' ? 'margin-right' : 'margin-bottom']);
        return val === true ? result : size;
    },

    outerWidth: function(val){
        return this._sizeOut('width', val);
    },

    outerHeight: function(val){
        return this._sizeOut('height', val);
    },

    padding: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["padding-top"]),
            right: parseInt(s["padding-right"]),
            bottom: parseInt(s["padding-bottom"]),
            left: parseInt(s["padding-left"])
        };
    },

    margin: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["margin-top"]),
            right: parseInt(s["margin-right"]),
            bottom: parseInt(s["margin-bottom"]),
            left: parseInt(s["margin-left"])
        };
    },

    border: function(p){
        if (this.length === 0) return;
        var s = getComputedStyle(this[0], p);

        return {
            top: parseInt(s["border-top-width"]),
            right: parseInt(s["border-right-width"]),
            bottom: parseInt(s["border-bottom-width"]),
            left: parseInt(s["border-left-width"])
        };
    }
});

// Source: src/position.js

/* global $, not */

$.fn.extend({
    offset: function(val){
        var rect;

        if (not(val)) {
            if (this.length === 0) return undefined;
            rect = this[0].getBoundingClientRect();
            return {
                top: rect.top + pageYOffset,
                left: rect.left + pageXOffset
            };
        }

        return this.each(function(){ //?
            var el = $(this),
                top = val.top,
                left = val.left,
                position = getComputedStyle(this).position,
                offset = el.offset();

            if (position === "static") {
                el.css("position", "relative");
            }

            if (["absolute", "fixed"].indexOf(position) === -1) {
                top = top - offset.top;
                left = left - offset.left;
            }

            el.css({
                top: top,
                left: left
            });
        });
    },

    position: function(margin){
        var ml = 0, mt = 0, el, style;

        if (not(margin) || typeof margin !== "boolean") {
            margin = false;
        }

        if (this.length === 0) {
            return undefined;
        }

        el = this[0];
        style = getComputedStyle(el);

        if (margin) {
            ml = parseInt(style['margin-left']);
            mt = parseInt(style['margin-top']);
        }

        return {
            left: el.offsetLeft - ml,
            top: el.offsetTop - mt
        };
    },

    left: function(val, margin){
        if (this.length === 0) return ;
        if (not(val)) {
            return this.position(margin).left;
        }
        if (typeof val === "boolean") {
            margin = val;
            return this.position(margin).left;
        }
        return this.each(function(){
            $(this).css({
                left: val
            });
        });
    },

    top: function(val, margin){
        if (this.length === 0) return ;
        if (not(val)) {
            return this.position(margin).top;
        }
        if (typeof val === "boolean") {
            margin = val;
            return this.position(margin).top;
        }
        return this.each(function(){
            $(this).css({
                top: val
            });
        });
    },

    coord: function(){
        return this.length === 0 ? undefined : this[0].getBoundingClientRect();
    },

    pos: function(){
        if (this.length === 0) return ;
        return {
            top: parseInt($(this[0]).style("top")),
            left: parseInt($(this[0]).style("left"))
        };
    }
});

// Source: src/attr.js

/* global $, not, isPlainObject */

$.fn.extend({
    attr: function(name, val){
        var attributes = {};

        if (this.length === 0 && arguments.length === 0) {
            return undefined;
        }

        if (this.length && arguments.length === 0) {
            $.each(this[0].attributes, function(){
                attributes[this.nodeName] = this.nodeValue;
            });
            return attributes;
        }

        if (arguments.length === 1 && typeof name === "string") {
            return this.length && this[0].nodeType === 1 && this[0].hasAttribute(name) ? this[0].getAttribute(name) : undefined;
        }

        return this.each(function(){
            var el = this;
            if (isPlainObject(name)) {
                $.each(name, function(k, v){
                    el.setAttribute(k, v);
                });
            } else {
                el.setAttribute(name, val);
                // 
            }
        });
    },

    removeAttr: function(name){
        var attributes;

        if (not(name)) {
            return this.each(function(){
                var el = this;
                $.each(this.attributes, function(){
                    el.removeAttribute(this);
                });
            });
        }

        attributes = typeof name === "string" ? name.split(",").map(function(el){
            return el.trim();
        }) : name;

        return this.each(function(){
            var el = this;
            $.each(attributes, function(){
                if (el.hasAttribute(this)) el.removeAttribute(this);
            });
        });
    },

    toggleAttr: function(name, val){
        return this.each(function(){
            var el = this;

            if (not(val)) {
                el.removeAttribute(name);
            } else {
                el.setAttribute(name, val);
            }

        });
    },

    id: function(val){
        return this.length ? $(this[0]).attr("id", val) : undefined;
    }
});

$.extend({
    meta: function(name){
        return not(name) ? $("meta") : $("meta[name='$name']".replace("$name", name));
    },

    metaBy: function(name){
        return not(name) ? $("meta") : $("meta[$name]".replace("$name", name));
    },

    doctype: function(){
        return $("doctype");
    },

    html: function(){
        return $("html");
    },

    head: function(){
        return $("html").find("head");
    },

    body: function(){
        return $("body");
    },

    document: function(){
        return $(document);
    },

    window: function(){
        return $(window);
    },

    charset: function(val){
        var meta = $("meta[charset]");
        if (val) {
            meta.attr("charset", val);
        }
        return meta.attr("charset");
    }
});

// Source: src/proxy.js

/* global $ */

$.extend({
    proxy: function(fn, ctx){
        return typeof fn !== "function" ? undefined : fn.bind(ctx);
    },

    bind: function(fn, ctx){
        return this.proxy(fn, ctx);
    }
});


// Source: src/manipulation.js

/* global $, isArrayLike, not, matches, hasProp */

(function (arr) {
    arr.forEach(function (item) {
        ['append', 'prepend'].forEach(function(where){
            if (hasProp(item, where)) {
                return;
            }

            Object.defineProperty(item, where, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: function () {
                    var argArr = Array.prototype.slice.call(arguments),
                        docFrag = document.createDocumentFragment();

                    argArr.forEach(function (argItem) {
                        var isNode = argItem instanceof Node;
                        docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
                    });

                    if (where === 'prepend')
                        this.insertBefore(docFrag, this.firstChild);
                    else
                        this.appendChild(docFrag);
                }
            });
        });
    });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]);

var normalizeElements = function(s){
    var result;

    if (typeof s === "string") result = $.isSelector(s) ? $(s) : $.parseHTML(s);
    else if (s instanceof HTMLElement) result = [s];
    else if (isArrayLike(s)) result = s;
    return result;
};

$.fn.extend({

    appendText: function(text){
        return this.each(function(elIndex, el){
            el.innerHTML += text;
        });
    },

    prependText: function(text){
        return this.each(function(elIndex, el){
            el.innerHTML = text + el.innerHTML;
        });
    },

    append: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(elIndex, el){
            $.each(_elements, function(){
                if (el === this) return ;
                var child = elIndex === 0 ? this : this.cloneNode(true);
                $.script(child);
                if (child.tagName && child.tagName !== "SCRIPT") el.append(child);
            });
        });
    },

    appendTo: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(parIndex, parent){
                if (el === this) return ;
                parent.append(parIndex === 0 ? el : el.cloneNode(true));
            });
        });
    },

    prepend: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function (elIndex, el) {
            $.each(_elements, function(){
                if (el === this) return ;
                var child = elIndex === 0 ? this : this.cloneNode(true);
                $.script(child);
                if (child.tagName && child.tagName !== "SCRIPT") el.prepend(child);
            });
        });
    },

    prependTo: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(parIndex, parent){
                if (el === this) return ;
                $(parent).prepend(parIndex === 0 ? el : el.cloneNode(true));
            });
        });
    },

    insertBefore: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(elIndex){
                if (el === this) return ;
                var parent = this.parentNode;
                if (parent) {
                    parent.insertBefore(elIndex === 0 ? el : el.cloneNode(true), this);
                }
            });
        });
    },

    insertAfter: function(elements){
        var _elements = normalizeElements(elements);

        return this.each(function(){
            var el = this;
            $.each(_elements, function(elIndex, element){
                if (el === this) return ;
                var parent = this.parentNode;
                if (parent) {
                    parent.insertBefore(elIndex === 0 ? el : el.cloneNode(true), element.nextSibling);
                }
            });
        });
    },

    after: function(html){
        return this.each(function(){
            var el = this;
            if (typeof html === "string") {
                el.insertAdjacentHTML('afterend', html);
            } else {
                $(html).insertAfter(el);
            }
        });
    },

    before: function(html){
        return this.each(function(){
            var el = this;
            if (typeof html === "string") {
                el.insertAdjacentHTML('beforebegin', html);
            } else {
                $(html).insertBefore(el);
            }
        });
    },

    clone: function(deep, withData){
        var res = [];
        if (not(deep)) {
            deep = false;
        }
        if (not(withData)) {
            withData = false;
        }
        this.each(function(){
            var el = this.cloneNode(deep);
            var $el = $(el);
            var data;
            if (withData && $.hasData(this)) {
                data = $(this).data();
                $.each(data, function(k, v){
                    $el.data(k, v);
                });
            }
            res.push(el);
        });
        return $.merge($(), res);
    },

    import: function(deep){
        var res = [];
        if (not(deep)) {
            deep = false;
        }
        this.each(function(){
            res.push(document.importNode(this, deep));
        });
        return $.merge($(), res);
    },

    adopt: function(){
        var res = [];
        this.each(function(){
            res.push(document.adoptNode(this));
        });
        return $.merge($(), res);
    },

    remove: function(selector){
        var i = 0, node, out, res = [];

        if (this.length === 0) {
            return ;
        }

        out = selector ? this.filter(function(el){
            return matches.call(el, selector);
        }) : this.items();

        for ( ; ( node = out[ i ] ) != null; i++ ) {
            if (node.parentNode) {
                res.push(node.parentNode.removeChild(node));
                $.removeData(node);
            }
        }

        return $.merge($(), res);
    },

    wrap: function( el ){
        if (this.length === 0) {
            return ;
        }

        var wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        var res = [];

        this.each(function(){
            var _target, _wrapper;

            _wrapper = wrapper.clone(true, true);
            _wrapper.insertBefore(this);

            _target = _wrapper;
            while (_target.children().length) {
                _target = _target.children().eq(0);
            }
            _target.append(this);

            res.push(_wrapper);
        });

        return $(res);
    },

    wrapAll: function( el ){
        var wrapper, _wrapper, _target;

        if (this.length === 0) {
            return ;
        }

        wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        _wrapper = wrapper.clone(true, true);
        _wrapper.insertBefore(this[0]);

        _target = _wrapper;
        while (_target.children().length) {
            _target = _target.children().eq(0);
        }

        this.each(function(){
            _target.append(this);
        })

        return _wrapper;
    },

    wrapInner: function( el ){
        if (this.length === 0) {
            return ;
        }

        var wrapper = $(normalizeElements(el));

        if (!wrapper.length) {
            return ;
        }

        var res = [];

        this.each(function(){
            var elem = $(this);
            var html = elem.html();
            var wrp = wrapper.clone(true, true);
            elem.html(wrp.html(html));
            res.push(wrp);
        });

        return $(res);
    }
});

// Source: src/animation.js

/* global $, not, camelCase, parseUnit, Promise, getUnit, matches */

$.extend({
    animation: {
        duration: 1000,
        ease: "linear",
        elements: {}
    }
});

if (typeof window["setupAnimation"] === 'object') {
    $.each(window["setupAnimation"], function(key, val){
        if (typeof $.animation[key] !== "undefined" && !not(val))
            $.animation[key] = val;
    });
}

var transformProps = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY'];
var numberProps = ['opacity', 'zIndex'];
var floatProps = ['opacity', 'volume'];
var scrollProps = ["scrollLeft", "scrollTop"];
var reverseProps = ["opacity", "volume"];

function _validElement(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
}

/**
 *
 * @param to
 * @param from
 * @returns {*}
 * @private
 */
function _getRelativeValue (to, from) {
    var operator = /^(\*=|\+=|-=)/.exec(to);
    if (!operator) return to;
    var u = getUnit(to) || 0;
    var x = parseFloat(from);
    var y = parseFloat(to.replace(operator[0], ''));
    switch (operator[0][0]) {
        case '+':
            return x + y + u;
        case '-':
            return x - y + u;
        case '*':
            return x * y + u;
        case '/':
            return x / y + u;
    }
}

/**
 *
 * @param el
 * @param prop
 * @param pseudo
 * @returns {*|number|string}
 * @private
 */
function _getStyle (el, prop, pseudo){
    if (typeof el[prop] !== "undefined") {
        if (scrollProps.indexOf(prop) > -1) {
            return prop === "scrollLeft" ? el === window ? pageXOffset : el.scrollLeft : el === window ? pageYOffset : el.scrollTop;
        } else {
            return el[prop] || 0;
        }
    }

    return el.style[prop] || getComputedStyle(el, pseudo)[prop];
}

/**
 *
 * @param el
 * @param key
 * @param val
 * @param unit
 * @param toInt
 * @private
 */
function _setStyle (el, key, val, unit, toInt) {

    if (not(toInt)) {
        toInt = false;
    }

    key = camelCase(key);

    if (toInt) {
        val  = parseInt(val);
    }

    if (_validElement(el)) {
        if (typeof el[key] !== "undefined") {
            el[key] = val;
        } else {
            el.style[key] = key === "transform" || key.toLowerCase().indexOf('color') > -1 ? val : val + unit;
        }
    } else {
        el[key] = val;
    }
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyStyles (el, mapProps, p) {
    $.each(mapProps, function (key, val) {
        _setStyle(el, key, val[0] + (val[2] * p), val[3], val[4]);
    });
}

/**
 *
 * @param el
 * @returns {{}}
 * @private
 */
function _getElementTransforms (el) {
    if (!_validElement(el)) return {};
    var str = el.style.transform || '';
    var reg = /(\w+)\(([^)]*)\)/g;
    var transforms = {};
    var m;

    /* jshint ignore:start */
    // eslint-disable-next-line
    while (m = reg.exec(str))
        transforms[m[1]] = m[2];
    /* jshint ignore:end */

    return transforms;
}

/**
 *
 * @param val
 * @returns {number[]}
 * @private
 */
function _getColorArrayFromHex (val){
    var a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(val ? val : "#000000");
    return a.slice(1).map(function(v) {
            return parseInt(v, 16);
    });
}

/**
 *
 * @param el
 * @param key
 * @returns {number[]}
 * @private
 */
function _getColorArrayFromElement (el, key) {
    return getComputedStyle(el)[key].replace(/[^\d.,]/g, '').split(',').map(function(v) {
        return parseInt(v);
    });
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyTransform (el, mapProps, p) {
    var t = [];
    var elTransforms = _getElementTransforms(el);

    $.each(mapProps, function(key, val) {
        var from = val[0], to = val[1], delta = val[2], unit = val[3];
        key = "" + key;

        if ( key.indexOf("rotate") > -1 || key.indexOf("skew") > -1) {
            if (unit === "") unit = "deg";
        }

        if (key.indexOf('scale') > -1) {
            unit = '';
        }

        if (key.indexOf('translate') > -1 && unit === '') {
            unit = 'px';
        }

        if (unit === "turn") {
            t.push(key+"(" + (to * p) + unit + ")");
        } else {
            t.push(key +"(" + (from + (delta * p)) + unit+")");
        }
    });

    $.each(elTransforms, function(key, val) {
        if (mapProps[key] === undefined) {
            t.push(key+"("+val+")");
        }
    });

    el.style.transform = t.join(" ");
}

/**
 *
 * @param el
 * @param mapProps
 * @param p
 * @private
 */
function _applyColors (el, mapProps, p) {
    $.each(mapProps, function (key, val) {
        var i, result = [0, 0, 0], v;
        for (i = 0; i < 3; i++) {
            result[i] = Math.floor(val[0][i] + (val[2][i] * p));
        }
        v = "rgb("+(result.join(","))+")";
        el.style[key] = v;
    });
}

/**
 *
 * @param val
 * @returns {string|*}
 * @private
 */
function _expandColorValue (val) {
    var regExp = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (val[0] === "#" && val.length === 4) {
        return "#" + val.replace(regExp, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
    }
    return val[0] === "#" ? val : "#"+val;
}

/**
 *
 * @param el
 * @param map
 * @param p
 */
function applyProps (el, map, p) {
    _applyStyles(el, map.props, p);
    _applyTransform(el, map.transform, p);
    _applyColors(el, map.color, p);
}

/**
 *
 * @param el
 * @param draw
 * @param dir
 * @returns {{transform: {}, color: {}, props: {}}}
 */
function createAnimationMap (el, draw, dir) {
    var map = {
        props: {},
        transform: {},
        color: {}
    };
    var i, from, to, delta, unit, temp;
    var elTransforms = _getElementTransforms(el);

    if (not(dir)) {
        dir = "normal";
    }

    $.each(draw, function(key, val) {

        var isTransformProp = transformProps.indexOf(""+key) > -1;
        var isNumProp = numberProps.indexOf(""+key) > -1;
        var isColorProp = (""+key).toLowerCase().indexOf("color") > -1;

        if (Array.isArray(val) && val.length === 1) {
            val = val[0];
        }

        if (!Array.isArray(val)) {
            if (isTransformProp) {
                from = elTransforms[key] || 0;
            } else if (isColorProp) {
                from = _getColorArrayFromElement(el, key);
            } else {
                from = _getStyle(el, key);
            }
            from = !isColorProp ? parseUnit(from) : from;
            to = !isColorProp ? parseUnit(_getRelativeValue(val, Array.isArray(from) ? from[0] : from)) : _getColorArrayFromHex(val);
        } else {
            from = !isColorProp ? parseUnit(val[0]) : _getColorArrayFromHex(_expandColorValue(val[0]));
            to = !isColorProp ? parseUnit(val[1]) : _getColorArrayFromHex(_expandColorValue(val[1]));
        }

        if (reverseProps.indexOf(""+key) > -1 && from[0] === to[0]) {
            from[0] = to[0] > 0 ? 0 : 1;
        }

        if (dir === "reverse") {
            temp = from;
            from = to;
            to = temp;
        }

        unit = el instanceof HTMLElement && to[1] === '' && !isNumProp && !isTransformProp ? 'px' : to[1];

        if (isColorProp) {
            delta = [0, 0, 0];
            for (i = 0; i < 3; i++) {
                delta[i] = to[i] - from[i];
            }
        } else {
            delta = to[0] - from[0];
        }

        if (isTransformProp) {
            map.transform[key] = [from[0], to[0], delta, unit];
        } else if (isColorProp) {
            map.color[key] = [from, to, delta, unit];
        } else {
            map.props[key] = [from[0], to[0], delta, unit, floatProps.indexOf(""+key) === -1];
        }
    });

    return map;
}

function minMax(val, min, max) {
    return Math.min(Math.max(val, min), max);
}

var Easing = {
    linear: function(){return function(t) {return t;};}
};

Easing.default = Easing.linear;

var eases = {
    Sine: function(){
        return function(t){
            return 1 - Math.cos(t * Math.PI / 2);
        };
    },
    Circ: function(){
        return function(t){
            return 1 - Math.sqrt(1 - t * t);
        };
    },
    Back: function(){
        return function(t){
            return t * t * (3 * t - 2);
        };
    },
    Bounce: function(){
        return function(t){
            var pow2, b = 4;
            // eslint-disable-next-line
            while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
            return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2);
        };
    },
    Elastic: function(amplitude, period){
        if (not(amplitude)) {
            amplitude = 1;
        }

        if (not(period)) {
            period = 0.5;
        }
        var a = minMax(amplitude, 1, 10);
        var p = minMax(period, 0.1, 2);
        return function(t){
            return (t === 0 || t === 1) ? t :
                -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
        };
    }
};

['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'].forEach(function(name, i) {
    eases[name] = function(){
        return function(t){
            return Math.pow(t, i + 2);
        };
    };
});

Object.keys(eases).forEach(function(name) {
    var easeIn = eases[name];
    Easing['easeIn' + name] = easeIn;
    Easing['easeOut' + name] = function(a, b){
        return function(t){
            return 1 - easeIn(a, b)(1 - t);
        };
    };
    Easing['easeInOut' + name] = function(a, b){
        return function(t){
            return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
        };
    };
});

var defaultAnimationProps = {
    id: null,
    el: null,
    draw: {},
    dur: $.animation.duration,
    ease: $.animation.ease,
    loop: 0,
    pause: 0,
    dir: "normal",
    defer: 0,
    onStart: function(){},
    onStop: function(){},
    onStopAll: function(){},
    onPause: function(){},
    onPauseAll: function(){},
    onResume: function(){},
    onResumeAll: function(){},
    onFrame: function(){},
    onDone: function(){}
};

function animate(args){
    return new Promise(function(resolve){
        var that = this;
        var props = $.assign({}, defaultAnimationProps, {dur: $.animation.duration, ease: $.animation.ease}, args);
        var id = props.id, el = props.el, draw = props.draw, dur = props.dur, ease = props.ease, loop = props.loop,
            onStart = props.onStart, onFrame = props.onFrame, onDone = props.onDone,
            pauseStart = props.pause, dir = props.dir, defer = props.defer;
        var map = {};
        var easeName = "linear", easeArgs = [], easeFn = Easing.linear, matchArgs;
        var direction = dir === "alternate" ? "normal" : dir;
        var replay = false;
        var animationID = id ? id : +(performance.now() * Math.pow(10, 14));

        if (not(el)) {
            throw new Error("Unknown element!");
        }

        if (typeof el === "string") {
            el = document.querySelector(el);
        }

        if (typeof draw !== "function" && typeof draw !== "object") {
            throw new Error("Unknown draw object. Must be a function or object!");
        }

        if (dur === 0) {
            dur = 1;
        }

        if (dir === "alternate" && typeof loop === "number") {
            loop *= 2;
        }

        if (typeof ease === "string") {
            matchArgs = /\(([^)]+)\)/.exec(ease);
            easeName = ease.split("(")[0];
            easeArgs = matchArgs ? matchArgs[1].split(',').map(function(p){return parseFloat(p);}) : [];
            easeFn = Easing[easeName] || Easing.linear;
        } else if (typeof ease === "function") {
            easeFn = ease;
        } else {
            easeFn = Easing.linear;
        }

        $.animation.elements[animationID] = {
            element: el,
            id: null,
            stop: 0,
            pause: 0,
            loop: 0,
            t: -1,
            started: 0,
            paused: 0
        };

        var play = function() {
            if (typeof draw === "object") {
                map = createAnimationMap(el, draw, direction);
            }

            if (typeof onStart === "function") {
                onStart.apply(el);
            }

            // start = performance.now();
            $.animation.elements[animationID].loop += 1;
            $.animation.elements[animationID].started = performance.now();
            $.animation.elements[animationID].duration = dur;
            $.animation.elements[animationID].id = requestAnimationFrame(animate);
        };

        var done = function() {
            cancelAnimationFrame($.animation.elements[animationID].id);
            delete $.animation.elements[id];

            if (typeof onDone === "function") {
                onDone.apply(el);
            }

            resolve(that);
        };

        var animate = function(time) {
            var p, t;
            var stop = $.animation.elements[animationID].stop;
            var pause = $.animation.elements[animationID].pause;
            var start = $.animation.elements[animationID].started;

            if ($.animation.elements[animationID].paused) {
                start = time - $.animation.elements[animationID].t * dur;
                $.animation.elements[animationID].started = start;
            }

            t = ((time - start) / dur).toFixed(4);

            if (t > 1) t = 1;
            if (t < 0) t = 0;

            p = easeFn.apply(null, easeArgs)(t);

            $.animation.elements[animationID].t = t;
            $.animation.elements[animationID].p = p;

            if (pause) {
                $.animation.elements[animationID].id = requestAnimationFrame(animate);
                // $.animation.elements[animationID].started = performance.now();
                return;
            }

            if ( stop > 0) {
                if (stop === 2) {
                    if (typeof draw === "function") {
                        draw.bind(el)(1, 1);
                    } else {
                        applyProps(el, map, 1);
                    }
                }
                done();
                return;
            }

            if (typeof draw === "function") {
                draw.bind(el)(t, p);
            } else {
                applyProps(el, map, p);
            }

            if (typeof onFrame === 'function') {
                onFrame.apply(el, [t, p]);
            }

            if (t < 1) {
                $.animation.elements[animationID].id = requestAnimationFrame(animate);
            }

            if (parseInt(t) === 1) {
                if (loop) {
                    if (dir === "alternate") {
                        direction = direction === "normal" ? "reverse" : "normal";
                    }

                    if (typeof loop === "boolean") {
                        setTimeout(function () {
                            play();
                        }, pauseStart);
                    } else {
                        if (loop > $.animation.elements[animationID].loop) {
                            setTimeout(function () {
                                play();
                            }, pauseStart);
                        } else {
                            done();
                        }
                    }
                } else {
                    if (dir === "alternate" && !replay) {
                        direction = direction === "normal" ? "reverse" : "normal";
                        replay = true;
                        play();
                    } else {
                        done();
                    }
                }
            }
        };
        if (defer > 0) {
            setTimeout(function() {
                play();
            }, defer);
        } else {
            play();
        }
    });
}

// Stop animation
function stopAnimation(id, done){
    var an = $.animation.elements[id];

    if (typeof an === "undefined") {
        return ;
    }

    if (not(done)) {
        done = true;
    }

    an.stop = done === true ? 2 : 1;

    if (typeof an.onStop === "function") {
        an.onStop.apply(an.element);
    }
}

function stopAnimationAll(done, filter){
    $.each($.animation.elements, function(k, v){
        if (filter) {
            if (typeof filter === "string") {
                if (matches.call(v.element, filter)) stopAnimation(k, done);
            } else if (filter.length) {
                $.each(filter, function(){
                    if (v.element === this) stopAnimation(k, done);
                });
            } else if (filter instanceof Element) {
                if (v.element === filter) stopAnimation(k, done);
            }
        } else {
            stopAnimation(k, done);
        }
    });
}
// end of stop

// Pause and resume animation
function pauseAnimation(id){
    var an = $.animation.elements[id];

    if (typeof an === "undefined") {
        return ;
    }

    an.pause = 1;
    an.paused = performance.now();

    if (typeof an.onPause === "function") {
        an.onPause.apply(an.element);
    }
}

function pauseAnimationAll(filter){
    $.each($.animation.elements, function(k, v){
        if (filter) {
            if (typeof filter === "string") {
                if (matches.call(v.element, filter)) pauseAnimation(k);
            } else if (filter.length) {
                $.each(filter, function(){
                    if (v.element === this) pauseAnimation(k);
                });
            } else if (filter instanceof Element) {
                if (v.element === filter) pauseAnimation(k);
            }
        } else {
            pauseAnimation(k);
        }
    });
}
// end of pause

function resumeAnimation(id){
    var an = $.animation.elements[id];

    if (typeof an === "undefined") {
        return ;
    }

    an.pause = 0;
    an.paused = 0;

    if (typeof an.onResume === "function") {
        an.onResume.apply(an.element);
    }
}

function resumeAnimationAll(filter){
    $.each($.animation.elements, function(k, v){
        if (filter) {
            if (typeof filter === "string") {
                if (matches.call(v.element, filter)) resumeAnimation(k);
            } else if (filter.length) {
                $.each(filter, function(){
                    if (v.element === this) resumeAnimation(k);
                });
            } else if (filter instanceof Element) {
                if (v.element === filter) resumeAnimation(k);
            }
        } else {
            resumeAnimation(k);
        }
    });
}

/* eslint-enable */

var defaultChainOptions = {
    loop: false,
    onChainItem: null,
    onChainItemComplete: null,
    onChainComplete: null
}

function chain(arr, opt){
    var o = $.extend({}, defaultChainOptions, opt);

    if (typeof o.loop !== "boolean") {
        o.loop--;
    }

    if (!Array.isArray(arr)) {
        console.warn("Chain array is not defined!");
        return false;
    }

    var reducer = function(acc, item){
        return acc.then(function(){
            if (typeof o["onChainItem"] === "function") {
                o["onChainItem"](item);
            }
            return animate(item).then(function(){
                if (typeof o["onChainItemComplete"] === "function") {
                    o["onChainItemComplete"](item);
                }
            });
        });
    };

    arr.reduce(reducer, Promise.resolve()).then(function(){
        if (typeof o["onChainComplete"] === "function") {
            o["onChainComplete"]();
        }

        if (o.loop) {
            chain(arr, o);
        }
    });
}

$.easing = {};

$.extend($.easing, Easing);

$.extend({
    animate: function(args){
        var el, draw, dur, ease, cb;

        if (arguments.length > 1) {
            el = $(arguments[0])[0];
            draw = arguments[1];
            dur = arguments[2] || $.animation.duration;
            ease = arguments[3] || $.animation.ease;
            cb = arguments[4];

            if (typeof dur === 'function') {
                cb = dur;
                ease = $.animation.ease;
                dur = $.animation.duration;
            }

            if (typeof ease === 'function') {
                cb = ease;
                ease = $.animation.ease;
            }

            return animate({
                el: el,
                draw: draw,
                dur: dur,
                ease: ease,
                onDone: cb
            });
        }

        return animate(args);
    },
    chain: chain,
    stop: stopAnimation,
    stopAll: stopAnimationAll,
    resume: resumeAnimation,
    resumeAll: resumeAnimationAll,
    pause: pauseAnimation,
    pauseAll: pauseAnimationAll
});

$.fn.extend({
    /**
     *

     args = {
         draw: {} | function,
         dur: 1000,
         ease: "linear",
         loop: 0,
         pause: 0,
         dir: "normal",
         defer: 0,
         onFrame: function,
         onDone: function
     }

     * @returns {this}
     */
    animate: function(args){
        var that = this;
        var draw, dur, easing, cb;
        var a = args;
        var compatibilityMode;

        compatibilityMode = !Array.isArray(args) && (arguments.length > 1 || (arguments.length === 1 && typeof arguments[0].draw === 'undefined'));

        if ( compatibilityMode ) {
            draw = arguments[0];
            dur = arguments[1] || $.animation.duration;
            easing = arguments[2] || $.animation.ease;
            cb = arguments[3];

            if (typeof dur === 'function') {
                cb = dur;
                dur = $.animation.duration;
                easing = $.animation.ease;
            }

            if (typeof easing === 'function') {
                cb = easing;
                easing = $.animation.ease;
            }

            return this.each(function(){
                return $.animate({
                    el: this,
                    draw: draw,
                    dur: dur,
                    ease: easing,
                    onDone: cb
                });
            });
        }

        if (Array.isArray(args)) {
            $.each(args, function(){
                var a = this;
                that.each(function(){
                    a.el = this;
                    $.animate(a);
                });
            });
            return this;
        }

        return this.each(function(){
            a.el = this;
            $.animate(a);
        });
    },

    chain: function(arr, loop){
        return this.each(function(){
            var el = this;
            $.each(arr, function(){
                this.el = el;
            });
            $.chain(arr, loop);
        });
    },

    /**
     *
     * @param done
     * @returns {this}
     */
    stop: function(done){
        return this.each(function(){
            var el = this;
            $.each($.animation.elements, function(k, o){
                if (o.element === el) {
                    stopAnimation(k, done);
                }
            });
        });
    },

    pause: function(){
        return this.each(function(){
            var el = this;
            $.each($.animation.elements, function(k, o){
                if (o.element === el) {
                    pauseAnimation(k);
                }
            });
        });
    },

    resume: function(){
        return this.each(function(){
            var el = this;
            $.each($.animation.elements, function(k, o){
                if (o.element === el) {
                    resumeAnimation(k);
                }
            });
        });
    }
});


// Source: src/visibility.js

/* global $ */

$.extend({
    hidden: function(el, val, cb){
        el = $(el)[0];

        if (typeof val === "string") {
            val = val.toLowerCase() === "true";
        }

        if (typeof val === "function") {
            cb = val;
            val = !el.hidden;
        }

        el.hidden = val;

        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }

        return this;
    },

    hide: function(el, cb){
        var $el = $(el);

        $el.origin('display', (el.style.display ? el.style.display : getComputedStyle(el, null).display));
        el.style.display = 'none';

        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }

        return this;
    },

    show: function(el, cb){
        var display = $(el).origin('display', undefined, "block");
        el.style.display = display ? display === 'none' ? 'block' : display : '';
        if (parseInt(el.style.opacity) === 0) {
            el.style.opacity = "1";
        }
        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }
        return this;
    },

    visible: function(el, mode, cb){
        if (mode === undefined) {
            mode = true;
        }
        el.style.visibility = mode ? 'visible' : 'hidden';
        if (typeof cb === "function") {
            $.bind(cb, el);
            cb.call(el, arguments);
        }
        return this;
    },

    toggle: function(el, cb){
        var func = getComputedStyle(el, null).display !== 'none' ? 'hide' : 'show';
        return $[func](el, cb);
    }
});

$.fn.extend({
    hide: function(){
        var callback;

        $.each(arguments, function(){
            if (typeof this === 'function') {
                callback = this;
            }
        });

        return this.each(function(){
            $.hide(this, callback);
        });
    },

    show: function(){
        var callback;

        $.each(arguments, function(){
            if (typeof this === 'function') {
                callback = this;
            }
        });

        return this.each(function(){
            $.show(this, callback);
        });
    },

    visible: function(mode, cb){
        return this.each(function(){
            $.visible(this, mode, cb);
        });
    },

    toggle: function(cb){
        return this.each(function(){
            $.toggle(this, cb);
        });
    },

    hidden: function(val, cb){
        return this.each(function(){
            $.hidden(this, val, cb);
        });
    }
});



// Source: src/effects.js

/* global $, not, isVisible */

$.extend({
    fx: {
        off: false
    }
});

$.fn.extend({
    fadeIn: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var visible = !(!isVisible(el) || (isVisible(el) && +($el.style('opacity')) === 0));

            if (visible) {
                return this;
            }

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }

            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            if ($.fx.off) {
                dur = 0;
            }

            var originDisplay = $el.origin("display", undefined, 'block');

            el.style.opacity = "0";
            el.style.display = originDisplay;

            return $.animate({
                el: el,
                draw: {
                    opacity: 1
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    fadeOut: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);

            if ( !isVisible(el) ) return ;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            $el.origin("display", $el.style('display'));

            return $.animate({
                el: el,
                draw: {
                    opacity: 0
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    this.style.display = 'none';

                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    slideUp: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var currHeight;

            if ($el.height() === 0) return ;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            currHeight = $el.height();
            $el.origin("height", currHeight);
            $el.origin("display", $(el).style('display'));

            $el.css({
                overflow: "hidden"
            });

            return $.animate({
                el: el,
                draw: {
                    height: 0
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    $el.hide().removeStyleProperty("overflow, height");
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    slideDown: function(dur, easing, cb){
        return this.each(function(){
            var el = this;
            var $el = $(el);
            var targetHeight, originDisplay;

            if (not(dur) && not(easing) && not(cb)) {
                cb = null;
                dur = $.animation.duration;
            } else
            if (typeof dur === "function") {
                cb = dur;
                dur = $.animation.duration;
            }
            if (typeof easing === "function") {
                cb = easing;
                easing = $.animation.ease;
            }

            $el.show().visible(false);
            targetHeight = +$el.origin("height", undefined, $el.height());
            if (parseInt(targetHeight) === 0) {
                targetHeight = el.scrollHeight;
            }
            originDisplay = $el.origin("display", $el.style('display'), "block");
            $el.height(0).visible(true);

            $el.css({
                overflow: "hidden",
                display: originDisplay === "none" ? "block" : originDisplay
            });

            return $.animate({
                el: el,
                draw: {
                    height: targetHeight
                },
                dur: dur,
                ease: easing,
                onDone: function(){
                    $(el).removeStyleProperty("overflow, height, visibility");
                    if (typeof cb === 'function') {
                        $.proxy(cb, this)();
                    }
                }
            });
        });
    },

    moveTo: function(x, y, dur, easing, cb){
        var draw = {
            top: y,
            left: x
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    centerTo: function(x, y, dur, easing, cb){
        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            var draw = {
                left: x - this.clientWidth / 2,
                top: y - this.clientHeight / 2
            };
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    colorTo: function(color, dur, easing, cb){
        var draw = {
            color: color
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    },

    backgroundTo: function(color, dur, easing, cb){
        var draw = {
            backgroundColor: color
        };

        if (typeof dur === "function") {
            cb = dur;
            dur = $.animation.duration;
            easing = $.animation.ease;
        }

        if (typeof easing === "function") {
            cb = easing;
            easing = $.animation.ease;
        }

        return this.each(function(){
            $.animate({
                el: this,
                draw: draw,
                dur: dur,
                ease: easing,
                onDone: cb
            });
        });
    }
});

// Source: src/init.js

/* global $, isArrayLike, isPlainObject, hasProp, str2arr */

$.init = function(sel, ctx){
    var parsed;
    var that = this;

    if (typeof sel === "string") {
        sel = sel.trim();
    }

    this.uid = $.uniqueId();

    if (!sel) {
        return this;
    }

    if (typeof sel === "function") {
        return $.ready(sel);
    }

    if (sel instanceof Element) {
        this.push(sel);
        return this;
    }

    if (sel instanceof $) {
        $.each(sel, function(){
            that.push(this);
        });
        return this;
    }

    if (sel === "window") sel = window;
    if (sel === "document") sel = document;
    if (sel === "body") sel = document.body;
    if (sel === "html") sel = document.documentElement;
    if (sel === "doctype") sel = document.doctype;
    if (sel && (sel.nodeType || sel.self === window)) {
        this.push(sel);
        return this;
    }

    if (isArrayLike(sel)) {
        $.each(sel, function(){
            $(this).each(function(){
                that.push(this);
            });
        });
        return this;
    }

    if (typeof sel !== "string" && (sel.self && sel.self !== window)) {
        return this;
    }

    if (sel === "#" || sel === ".") {
        console.error("Selector can't be # or .") ;
        return this;
    }

    if (sel[0] === "@") {

        $("[data-role]").each(function(){
            var roles = str2arr($(this).attr("data-role"), ",");
            if (roles.indexOf(sel.slice(1)) > -1) {
                that.push(this);
            }
        });

    } else {

        parsed = $.parseHTML(sel);

        if (parsed.length === 1 && parsed[0].nodeType === 3) { // Must be a text node -> css sel
            try {
                [].push.apply(this, document.querySelectorAll(sel));
            } catch (e) {
                //console.error(sel + " is not a valid selector");
            }
        } else {
            $.merge(this, parsed);
        }
    }

    if (ctx !== undefined) {
        if (ctx instanceof $) {
            this.each(function () {
                $(ctx).append(that);
            });
        } else if (ctx instanceof HTMLElement) {
            $(ctx).append(that);
        } else {
            if (isPlainObject(ctx)) {
                $.each(this,function(){
                    for(var name in ctx) {
                        if (hasProp(ctx, name))
                            this.setAttribute(name, ctx[name]);
                    }
                });
            }
        }
    }

    return this;
};

$.init.prototype = $.fn;


// Source: src/populate.js

/* global Promise, $ */

var _$ = window.$;

$.Promise = Promise;

window.m4q = $;

if (typeof window.$ === "undefined") {
    window.$ = $;
}

$.global = function(){
    _$ = window.$;
    window.$ = $;
};

$.noConflict = function() {
    if ( window.$ === $ ) {
        window.$ = _$;
    }

    return $;
};

}(window));


(function($) {
    'use strict';

    var meta_init = $.meta('metro4:init').attr("content");
    var meta_locale = $.meta('metro4:locale').attr("content");
    var meta_week_start = $.meta('metro4:week_start').attr("content");
    var meta_date_format = $.meta('metro4:date_format').attr("content");
    var meta_date_format_input = $.meta('metro4:date_format_input').attr("content");
    var meta_animation_duration = $.meta('metro4:animation_duration').attr("content");
    var meta_callback_timeout = $.meta('metro4:callback_timeout').attr("content");
    var meta_timeout = $.meta('metro4:timeout').attr("content");
    var meta_scroll_multiple = $.meta('metro4:scroll_multiple').attr("content");
    var meta_cloak = $.meta('metro4:cloak').attr("content");
    var meta_cloak_duration = $.meta('metro4:cloak_duration').attr("content");
    var meta_global_common = $.meta('metro4:global_common').attr("content");
    var meta_blur_image = $.meta('metro4:blur_image').attr("content");

    if (window.METRO_BLUR_IMAGE === undefined) {
        window.METRO_BLUR_IMAGE = meta_blur_image !== undefined ? JSON.parse(meta_global_common) : false;
    }

    if (window.METRO_GLOBAL_COMMON === undefined) {
        window.METRO_GLOBAL_COMMON = meta_global_common !== undefined ? JSON.parse(meta_global_common) : false;
    }

    var meta_jquery = $.meta('metro4:jquery').attr("content"); //undefined
    window.jquery_present = typeof jQuery !== "undefined";
    if (window.METRO_JQUERY === undefined) {
        window.METRO_JQUERY = meta_jquery !== undefined ? JSON.parse(meta_jquery) : true;
    }
    window.useJQuery = window.jquery_present && window.METRO_JQUERY;


    /* Added by Ken Kitay https://github.com/kens-code*/
    var meta_about = $.meta('metro4:about').attr("content");
    if (window.METRO_SHOW_ABOUT === undefined) {
        window.METRO_SHOW_ABOUT = meta_about !== undefined ? JSON.parse(meta_about) : true;
    }
    /* --- end ---*/

    var meta_compile = $.meta('metro4:compile').attr("content");
    if (window.METRO_SHOW_COMPILE_TIME === undefined) {
        window.METRO_SHOW_COMPILE_TIME = meta_compile !== undefined ? JSON.parse(meta_compile) : true;
    }

    if (window.METRO_INIT === undefined) {
        window.METRO_INIT = meta_init !== undefined ? JSON.parse(meta_init) : true;
    }

    if (window.METRO_DEBUG === undefined) {window.METRO_DEBUG = true;}

    if (window.METRO_WEEK_START === undefined) {
        window.METRO_WEEK_START = meta_week_start !== undefined ? parseInt(meta_week_start) : 0;
    }
    if (window.METRO_DATE_FORMAT === undefined) {
        window.METRO_DATE_FORMAT = meta_date_format !== undefined ? meta_date_format : "YYYY-MM-DD";
    }
    if (window.METRO_DATE_FORMAT_INPUT === undefined) {
        window.METRO_DATE_FORMAT_INPUT = meta_date_format_input !== undefined ? meta_date_format_input : "YYYY-MM-DD";
    }
    if (window.METRO_LOCALE === undefined) {
        window.METRO_LOCALE = meta_locale !== undefined ? meta_locale : 'en-US';
    }
    if (window.METRO_ANIMATION_DURATION === undefined) {
        window.METRO_ANIMATION_DURATION = meta_animation_duration !== undefined ? parseInt(meta_animation_duration) : 100;
    }
    if (window.METRO_CALLBACK_TIMEOUT === undefined) {
        window.METRO_CALLBACK_TIMEOUT = meta_callback_timeout !== undefined ? parseInt(meta_callback_timeout) : 500;
    }
    if (window.METRO_TIMEOUT === undefined) {
        window.METRO_TIMEOUT = meta_timeout !== undefined ? parseInt(meta_timeout) : 2000;
    }
    if (window.METRO_SCROLL_MULTIPLE === undefined) {
        window.METRO_SCROLL_MULTIPLE = meta_scroll_multiple !== undefined ? parseInt(meta_scroll_multiple) : 20;
    }
    if (window.METRO_CLOAK_REMOVE === undefined) {
        window.METRO_CLOAK_REMOVE = meta_cloak !== undefined ? (""+meta_cloak).toLowerCase() : "fade";
    }
    if (window.METRO_CLOAK_DURATION === undefined) {
        window.METRO_CLOAK_DURATION = meta_cloak_duration !== undefined ? parseInt(meta_cloak_duration) : 300;
    }

    if (window.METRO_HOTKEYS_FILTER_CONTENT_EDITABLE === undefined) {window.METRO_HOTKEYS_FILTER_CONTENT_EDITABLE = true;}
    if (window.METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS === undefined) {window.METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS = true;}
    if (window.METRO_HOTKEYS_FILTER_TEXT_INPUTS === undefined) {window.METRO_HOTKEYS_FILTER_TEXT_INPUTS = true;}
    if (window.METRO_HOTKEYS_BUBBLE_UP === undefined) {window.METRO_HOTKEYS_BUBBLE_UP = false;}
    if (window.METRO_THROWS === undefined) {window.METRO_THROWS = true;}

    window.METRO_MEDIA = [];

}(m4q));

/* Metro 4 Core */
(function() {
    'use strict';

    var $ = m4q;

    if (typeof m4q === 'undefined') {
        throw new Error('Metro 4 requires m4q helper!');
    }

    if (!('MutationObserver' in window)) {
        throw new Error('Metro 4 requires MutationObserver!');
    }

    var isTouch = (('ontouchstart' in window) || (navigator["MaxTouchPoints"] > 0) || (navigator["msMaxTouchPoints"] > 0));

    var normalizeComponentName = function(name){
        return typeof name !== "string" ? undefined : name.replace(/-/g, "").toLowerCase();
    };

    var Metro = {

        version: "4.5.0",
        compileTime: "01/08/2021 18:53:43",
        buildNumber: "755",
        isTouchable: isTouch,
        fullScreenEnabled: document.fullscreenEnabled,
        sheet: null,


        controlsPosition: {
            INSIDE: "inside",
            OUTSIDE: "outside"
        },

        groupMode: {
            ONE: "one",
            MULTI: "multi"
        },

        aspectRatio: {
            HD: "hd",
            SD: "sd",
            CINEMA: "cinema"
        },

        fullScreenMode: {
            WINDOW: "window",
            DESKTOP: "desktop"
        },

        position: {
            TOP: "top",
            BOTTOM: "bottom",
            LEFT: "left",
            RIGHT: "right",
            TOP_RIGHT: "top-right",
            TOP_LEFT: "top-left",
            BOTTOM_LEFT: "bottom-left",
            BOTTOM_RIGHT: "bottom-right",
            LEFT_BOTTOM: "left-bottom",
            LEFT_TOP: "left-top",
            RIGHT_TOP: "right-top",
            RIGHT_BOTTOM: "right-bottom"
        },

        popoverEvents: {
            CLICK: "click",
            HOVER: "hover",
            FOCUS: "focus"
        },

        stepperView: {
            SQUARE: "square",
            CYCLE: "cycle",
            DIAMOND: "diamond"
        },

        listView: {
            LIST: "list",
            CONTENT: "content",
            ICONS: "icons",
            ICONS_MEDIUM: "icons-medium",
            ICONS_LARGE: "icons-large",
            TILES: "tiles",
            TABLE: "table"
        },

        events: {
            click: 'click',
            start: isTouch ? 'touchstart' : 'mousedown',
            stop: isTouch ? 'touchend' : 'mouseup',
            move: isTouch ? 'touchmove' : 'mousemove',
            enter: isTouch ? 'touchstart' : 'mouseenter',

            startAll: 'mousedown touchstart',
            stopAll: 'mouseup touchend',
            moveAll: 'mousemove touchmove',

            leave: 'mouseleave',
            focus: 'focus',
            blur: 'blur',
            resize: 'resize',
            keyup: 'keyup',
            keydown: 'keydown',
            keypress: 'keypress',
            dblclick: 'dblclick',
            input: 'input',
            change: 'change',
            cut: 'cut',
            paste: 'paste',
            scroll: 'scroll',
            mousewheel: 'mousewheel',
            inputchange: "change input propertychange cut paste copy drop",
            dragstart: "dragstart",
            dragend: "dragend",
            dragenter: "dragenter",
            dragover: "dragover",
            dragleave: "dragleave",
            drop: 'drop',
            drag: 'drag'
        },

        keyCode: {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            BREAK: 19,
            CAPS: 20,
            ESCAPE: 27,
            SPACE: 32,
            PAGEUP: 33,
            PAGEDOWN: 34,
            END: 35,
            HOME: 36,
            LEFT_ARROW: 37,
            UP_ARROW: 38,
            RIGHT_ARROW: 39,
            DOWN_ARROW: 40,
            COMMA: 188
        },

        media_queries: {
            FS: "(min-width: 0px)",
            XS: "(min-width: 360px)",
            SM: "(min-width: 576px)",
            MD: "(min-width: 768px)",
            LG: "(min-width: 992px)",
            XL: "(min-width: 1200px)",
            XXL: "(min-width: 1452px)"
        },

        media_sizes: {
            FS: 0,
            XS: 360,
            SM: 576,
            LD: 640,
            MD: 768,
            LG: 992,
            XL: 1200,
            XXL: 1452
        },

        media_mode: {
            FS: "fs",
            XS: "xs",
            SM: "sm",
            MD: "md",
            LG: "lg",
            XL: "xl",
            XXL: "xxl"
        },

        media_modes: ["fs","xs","sm","md","lg","xl","xxl"],

        actions: {
            REMOVE: 1,
            HIDE: 2
        },

        hotkeys: {},
        locales: {},
        utils: {},
        colors: {},
        dialog: null,
        pagination: null,
        md5: null,
        storage: null,
        export: null,
        animations: null,
        cookie: null,
        template: null,
        defaults: {},

        about: function(){
            var content =
                "<h3>About</h3>" +
                "<hr>" +
                "<div><b>Metro 4</b> - v" + Metro.version +". "+ Metro.showCompileTime() + "</div>" +
                "<div><b>M4Q</b> - " + m4q.version + "</div>";
            Metro.infobox.create(content)
        },

        info: function(){
            console.info("Metro 4 - v" + Metro.version +". "+ Metro.showCompileTime());
            console.info("m4q - " + m4q.version);
        },

        showCompileTime: function(){
            return "Built at: " + Metro.compileTime;
        },

        aboutDlg: function(){
            alert("Metro 4 - v" + Metro.version +". "+ Metro.showCompileTime());
        },

        ver: function(){
            return Metro.version;
        },

        build: function(){
            return Metro.build;
        },

        compile: function(){
            return Metro.compileTime;
        },

        observe: function(){
            var observer, observerCallback;
            var observerConfig = {
                childList: true,
                attributes: true,
                subtree: true
            };
            observerCallback = function(mutations){
                mutations.map(function(mutation){
                    if (mutation.type === 'attributes' && mutation.attributeName !== "data-role") {
                        if (mutation.attributeName === 'data-hotkey') {
                            Metro.initHotkeys([mutation.target], true);
                        } else {
                            var element = $(mutation.target);
                            var mc = element.data('metroComponent');
                            var attr = mutation.attributeName, newValue = element.attr(attr), oldValue = mutation.oldValue;

                            if (mc !== undefined) {
                                element.fire("attr-change", {
                                    attr: attr,
                                    newValue: newValue,
                                    oldValue: oldValue,
                                    __this: element[0]
                                });

                                $.each(mc, function(){
                                    var plug = Metro.getPlugin(element, this);
                                    if (plug && typeof plug.changeAttribute === "function") {
                                        plug.changeAttribute(attr, newValue, oldValue);
                                    }
                                });
                            }
                        }
                    } else

                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        var i, widgets = [];
                        var $node, node, nodes = mutation.addedNodes;

                        if (nodes.length) {
                            for(i = 0; i < nodes.length; i++) {
                                node = nodes[i];
                                $node = $(node);

                                if ($node.attr("data-role") !== undefined) {
                                    widgets.push(node);
                                }

                                $.each($node.find("[data-role]"), function(){
                                    var o = this;
                                    if (widgets.indexOf(o) !== -1) {
                                        return;
                                    }
                                    widgets.push(o);
                                });
                            }

                            if (widgets.length) Metro.initWidgets(widgets, "observe");
                        }

                    } else  {
                        //
                    }
                });
            };
            observer = new MutationObserver(observerCallback);
            observer.observe($("html")[0], observerConfig);
        },

        init: function(){
            var widgets = $("[data-role]");
            var hotkeys = $("[data-hotkey]");
            var html = $("html");
            var that = this;

            if (window.METRO_BLUR_IMAGE) {
                html.addClass("use-blur-image");
            }

            if (window.METRO_SHOW_ABOUT) Metro.info(true);

            if (isTouch === true) {
                html.addClass("metro-touch-device");
            } else {
                html.addClass("metro-no-touch-device");
            }

            Metro.sheet = this.utils.newCssSheet();

            this.utils.addCssRule(Metro.sheet, "*, *::before, *::after", "box-sizing: border-box;");

            window.METRO_MEDIA = [];
            $.each(Metro.media_queries, function(key, query){
                if (that.utils.media(query)) {
                    window.METRO_MEDIA.push(Metro.media_mode[key]);
                }
            });

            Metro.observe();

            Metro.initHotkeys(hotkeys);
            Metro.initWidgets(widgets, "init");

            if (window.METRO_CLOAK_REMOVE !== "fade") {
                $(".m4-cloak").removeClass("m4-cloak");
                $(window).fire("metro-initiated");
            } else {
                $(".m4-cloak").animate({
                    draw: {
                        opacity: 1
                    },
                    dur: 300,
                    onDone: function(){
                        $(".m4-cloak").removeClass("m4-cloak");
                        $(window).fire("metro-initiated");
                    }
                });
            }
        },

        initHotkeys: function(hotkeys, redefine){
            $.each(hotkeys, function(){
                var element = $(this);
                var hotkey = element.attr('data-hotkey') ? element.attr('data-hotkey').toLowerCase() : false;
                var fn = element.attr('data-hotkey-func') ? element.attr('data-hotkey-func') : false;

                if (hotkey === false) {
                    return;
                }

                if (element.data('hotKeyBonded') === true && redefine !== true) {
                    return;
                }

                Metro.hotkeys[hotkey] = [this, fn];
                element.data('hotKeyBonded', true);
                element.fire("hot-key-bonded", {
                    __this: element[0],
                    hotkey: hotkey,
                    fn: fn
                });
            });
        },

        initWidgets: function(widgets) {
            var that = this;

            $.each(widgets, function () {
                var $this = $(this), roles;

                if (!this.hasAttribute("data-role")) {
                    return ;
                }

                roles = $this.attr('data-role').split(/\s*,\s*/);

                roles.map(function (func) {

                    var $$ = that.utils.$();
                    var _func = normalizeComponentName(func);

                    if ($$.fn[_func] !== undefined && $this.attr("data-role-"+_func) === undefined) {
                        try {
                            $$.fn[_func].call($this);
                            $this.attr("data-role-"+_func, true);

                            var mc = $this.data('metroComponent');

                            if (mc === undefined) {
                                mc = [_func];
                            } else {
                                mc.push(_func);
                            }
                            $this.data('metroComponent', mc);

                            $this.fire("create", {
                                __this: $this[0],
                                name: _func
                            });
                            $(document).fire("component-create", {
                                element: $this[0],
                                name: _func
                            });
                        } catch (e) {
                            console.error("Error creating component " + func + " for ", $this[0]);
                            throw e;
                        }
                    }
                });
            });
        },

        plugin: function(name, object){
            var _name = normalizeComponentName(name);

            var register = function($){
                $.fn[_name] = function( options ) {
                    return this.each(function() {
                        $.data( this, _name, Object.create(object).init(options, this ));
                    });
                };
            }

            register(m4q);

            if (window.useJQuery) {
                register(jQuery);
            }
        },

        pluginExists: function(name){
            var $ = window.useJQuery ? jQuery : m4q;
            return typeof $.fn[normalizeComponentName(name)] === "function";
        },

        destroyPlugin: function(element, name){
            var p, mc;
            var el = $(element);
            var _name = normalizeComponentName(name);

            p = Metro.getPlugin(el, _name);

            if (typeof p === 'undefined') {
                console.warn("Component "+name+" can not be destroyed: the element is not a Metro 4 component.");
                return ;
            }

            if (typeof p['destroy'] !== 'function') {
                console.warn("Component "+name+" can not be destroyed: method destroy not found.");
                return ;
            }

            p['destroy']();
            mc = el.data("metroComponent");
            this.utils.arrayDelete(mc, _name);
            el.data("metroComponent", mc);
            $.removeData(el[0], _name);
            el.removeAttr("data-role-"+_name);
        },

        destroyPluginAll: function(element){
            var el = $(element);
            var mc = el.data("metroComponent");

            if (mc !== undefined && mc.length > 0) $.each(mc, function(){
                Metro.destroyPlugin(el[0], this);
            });
        },

        noop: function(){},
        noop_true: function(){return true;},
        noop_false: function(){return false;},

        requestFullScreen: function(element){
            if (element["mozRequestFullScreen"]) {
                element["mozRequestFullScreen"]();
            } else if (element["webkitRequestFullScreen"]) {
                element["webkitRequestFullScreen"]();
            } else if (element["msRequestFullscreen"]) {
                element["msRequestFullscreen"]();
            } else {
                element.requestFullscreen().catch( function(err){
                    console.warn("Error attempting to enable full-screen mode: "+err.message+" "+err.name);
                });
            }
        },

        exitFullScreen: function(){
            if (document["mozCancelFullScreen"]) {
                document["mozCancelFullScreen"]();
            }
            else if (document["webkitCancelFullScreen"]) {
                document["webkitCancelFullScreen"]();
            }
            else if (document["msExitFullscreen"]) {
                document["msExitFullscreen"]();
            } else {
                document.exitFullscreen().catch( function(err){
                    console.warn("Error attempting to disable full-screen mode: "+err.message+" "+err.name);
                });
            }
        },

        inFullScreen: function(){
            var fsm = (document.fullscreenElement || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"]);
            return fsm !== undefined;
        },

        $: function(){
            return window.useJQuery ? jQuery : m4q;
        },

        get$el: function(el){
            return Metro.$()($(el)[0]);
        },

        get$elements: function(el){
            return Metro.$()($(el));
        },

        // TODO add if name is not defined, return one or array of plugins
        getPlugin: function(el, name){
            var _name = normalizeComponentName(name);
            var $el = Metro.get$el(el);
            return $el.length ? $el.data(_name) : undefined;
        },

        makePlugin: function(el, name, options){
            var _name = normalizeComponentName(name);
            var $el = Metro.get$elements(el);
            return $el.length && typeof $el[_name] === "function" ? $el[_name](options) : undefined;
        },

        Component: function(nameName, compObj){
            var name = normalizeComponentName(nameName);
            var Utils = Metro.utils;
            var component = $.extend({name: name}, {
                _super: function(el, options, defaults, setup){
                    var self = this;

                    this.elem = el;
                    this.element = $(el);
                    this.options = $.extend( {}, defaults, options );
                    this.component = this.elem;

                    this._setOptionsFromDOM();
                    this._runtime();

                    if (setup && typeof setup === 'object') {
                        $.each(setup, function(key, val){
                            self[key] = val;
                        })
                    }

                    this._createExec();
                },

                _setOptionsFromDOM: function(){
                    var element = this.element, o = this.options;

                    $.each(element.data(), function(key, value){
                        if (key in o) {
                            try {
                                o[key] = JSON.parse(value);
                            } catch (e) {
                                o[key] = value;
                            }
                        }
                    });
                },

                _runtime: function(){
                    var element = this.element, mc;
                    var roles = (element.attr("data-role") || "").toArray(",").map(function(v){
                        return normalizeComponentName(v);
                    }).filter(function(v){
                        return v.trim() !== "";
                    });

                    if (!element.attr('data-role-'+this.name)) {
                        element.attr("data-role-"+this.name, true);
                        if (roles.indexOf(this.name) === -1) {
                            roles.push(this.name);
                            element.attr("data-role", roles.join(","));
                        }

                        mc = element.data('metroComponent');
                        if (mc === undefined) {
                            mc = [this.name];
                        } else {
                            mc.push(this.name);
                        }
                        element.data('metroComponent', mc);
                    }
                },

                _createExec: function(){
                    var that = this, timeout = this.options[this.name+'Deferred'];

                    if (timeout) {
                        setTimeout(function(){
                            that._create();
                        }, timeout)
                    } else {
                        that._create();
                    }
                },

                _fireEvent: function(eventName, data, log, noFire){
                    var element = this.element, o = this.options;
                    var _data;
                    var event = $.camelCase(eventName).capitalize();

                    data = $.extend({}, data, {__this: element[0]});

                    _data = data ? Object.values(data) : {};

                    if (log) {
                        console.warn(log);
                        console.warn("Event: " + "on"+event);
                        console.warn("Data: ", data);
                        console.warn("Element: ", element[0]);
                    }

                    if (noFire !== true)
                        element.fire(event.toLowerCase(), data);

                    return Utils.exec(o["on"+event], _data, element[0]);
                },

                _fireEvents: function(events, data, log, noFire){
                    var that = this, _events;

                    if (arguments.length === 0) {
                        return ;
                    }

                    if (arguments.length === 1) {

                        $.each(events, function () {
                            var ev = this;
                            that._fireEvent(ev.name, ev.data, ev.log, ev.noFire);
                        });

                        return Utils.objectLength(events);
                    }

                    if (!Array.isArray(events) && typeof events !== "string") {
                        return ;
                    }

                    _events = Array.isArray(events) ? events : events.toArray(",");

                    $.each(_events, function(){
                        that._fireEvent(this, data, log, noFire);
                    });
                },

                getComponent: function(){
                    return this.component;
                },

                getComponentName: function(){
                    return this.name;
                }
            }, compObj);

            Metro.plugin(name, component);

            return component;
        },

        fetch: {
            status: function(response){
                return response.ok ? Promise.resolve(response) : Promise.reject(new Error(response.statusText));
            },

            json: function(response){
                return response.json();
            },

            text: function(response){
                return response.text();
            },

            form: function(response){
                return response.formData();
            },

            blob: function(response){
                return response.blob();
            },

            buffer: function(response){
                return response.arrayBuffer();
            }
        }
    };

    $(window).on(Metro.events.resize, function(){
        window.METRO_MEDIA = [];
        $.each(Metro.media_queries, function(key, query){
            if (Metro.utils.media(query)) {
                window.METRO_MEDIA.push(Metro.media_mode[key]);
            }
        });
    });

    window.Metro = Metro;

    if (window.METRO_INIT ===  true) {
        $(function(){
            Metro.init()
        });
    }

    return Metro;
}());


(function(Metro, $) {
    $.extend(Metro['locales'], {
        'da-DK': {
            "calendar": {
                "months": [
                    "Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December",
                    "Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"
                ],
                "days": [
                    "Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag",
                    "Sø", "Ma", "Ti", "On", "To", "Fr", "Lø",
                    "Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
                ],
                "time": {
                    "days": "DAGE",
                    "hours": "TIMER",
                    "minutes": "MIN",
                    "seconds": "SEK",
                    "month": "MON",
                    "day": "DAG",
                    "year": "ÅR"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annuller",
                "done": "Færdig",
                "today": "Idag",
                "now": "Nu",
                "clear": "Ryd",
                "help": "Hjælp",
                "yes": "Ja",
                "no": "Nej",
                "random": "Tilfældig",
                "save": "Gem",
                "reset": "Nulstil"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'de-DE': {
            "calendar": {
                "months": [
                    "Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember",
                    "Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"
                ],
                "days": [
                    "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag",
                    "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa",
                    "Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam"
                ],
                "time": {
                    "days": "TAGE",
                    "hours": "STD",
                    "minutes": "MIN",
                    "seconds": "SEK"
                },
                "weekStart": 2
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Abbrechen",
                "done": "Fertig",
                "today": "Heute",
                "now": "Jetzt",
                "clear": "Löschen",
                "help": "Hilfe",
                "yes": "Ja",
                "no": "Nein",
                "random": "Zufällig",
                "save": "Speichern",
                "reset": "Zurücksetzen"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'en-US': {
            "calendar": {
                "months": [
                    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December",
                    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                ],
                "days": [
                    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday",
                    "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa",
                    "Sun", "Mon", "Tus", "Wen", "Thu", "Fri", "Sat"
                ],
                "time": {
                    "days": "DAYS",
                    "hours": "HOURS",
                    "minutes": "MINS",
                    "seconds": "SECS",
                    "month": "MON",
                    "day": "DAY",
                    "year": "YEAR"
                },
                "weekStart": 0
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Cancel",
                "done": "Done",
                "today": "Today",
                "now": "Now",
                "clear": "Clear",
                "help": "Help",
                "yes": "Yes",
                "no": "No",
                "random": "Random",
                "save": "Save",
                "reset": "Reset"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'es-MX': {
            "calendar": {
                "months": [
                    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre",
                    "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"
                ],
                "days": [
                    "Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado",
                    "Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa",
                    "Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"
                ],
                "time": {
                    "days": "DÍAS",
                    "hours": "HORAS",
                    "minutes": "MINS",
                    "seconds": "SEGS",
                    "month": "MES",
                    "day": "DÍA",
                    "year": "AÑO"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "Aceptar",
                "cancel": "Cancelar",
                "done": "Hecho",
                "today": "Hoy",
                "now": "Ahora",
                "clear": "Limpiar",
                "help": "Ayuda",
                "yes": "Si",
                "no": "No",
                "random": "Aleatorio",
                "save": "Salvar",
                "reset": "Reiniciar"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'fr-FR': {
            "calendar": {
                "months": [
                    "Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre",
                    "Janv", "Févr", "Mars", "Avr", "Mai", "Juin", "Juil", "Août", "Sept", "Oct", "Nov", "Déc"
                ],
                "days": [
                    "Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi",
                    "Di", "Lu", "Ma", "Me", "Je", "Ve", "Sa",
                    "Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
                ],
                "time": {
                    "days": "JOURS",
                    "hours": "HEURES",
                    "minutes": "MINS",
                    "seconds": "SECS",
                    "month": "MOIS",
                    "day": "JOUR",
                    "year": "ANNEE"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annulé",
                "done": "Fait",
                "today": "Aujourd'hui",
                "now": "Maintenant",
                "clear": "Effacé",
                "help": "Aide",
                "yes": "Oui",
                "no": "Non",
                "random": "Aléatoire",
                "save": "Sauvegarder",
                "reset": "Réinitialiser"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'hr-HR': {
            "calendar": {
                "months": [
                    "Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac",
                    "Sij", "Velj", "Ožu", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"
                ],
                "days": [
                    "Nedjelja","Ponedjeljak","Utorak", "Srijeda", "Četvrtak", "Petak", "Subota",  
                    "Ne","Po", "Ut", "Sr", "Če", "Pe", "Su", 
                    "Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub" 
                ],
                "time": {
                    "days": "DANI",
                    "hours": "SATI",
                    "minutes": "MINUTE",
                    "seconds": "SEKUNDE",
                    "month": "MJESEC",
                    "day": "DAN",
                    "year": "GODINA"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Otkaži",
                "done": "Gotovo",
                "today": "Danas",
                "now": "Sada",
                "clear": "Izbriši",
                "help": "Pomoć",
                "yes": "Da",
                "no": "Ne",
                "random": "Nasumično",
                "save": "Spremi",
                "reset": "Reset"
            },
            "table": {
                "rowsCount": "Broj redaka:",
                "search": "Pretraga:",
                "info": "Prikazujem $1 do $2 od $3",
                "prev": "Nazad",
                "next": "Naprijed",
                "all": "Sve",
                "inspector": "Inspektor",
                "skip": "Idi na stranicu",
                "empty": "Prazno"
            },
            "colorSelector": {
                addUserColorButton: "Dodaj uzorcima",
                userColorsTitle: "Korisničke boje"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));


(function(Metro, $) {
    $.extend(Metro.locales, {
        'hu-HU': {
            "calendar": {
                "months": [
                    'Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December',
                    'Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'
                ],
                "days": [
                    'Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat',
                    'V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz',
                    'Vas', 'Hét', 'Ke', 'Sze', 'Csü', 'Pén', 'Szom'
                ],
                "time": {
                    "days": "NAP",
                    "hours": "ÓRA",
                    "minutes": "PERC",
                    "seconds": "MP"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Mégse",
                "done": "Kész",
                "today": "Ma",
                "now": "Most",
                "clear": "Törlés",
                "help": "Segítség",
                "yes": "Igen",
                "no": "Nem",
                "random": "Véletlen",
                "save": "Mentés",
                "reset": "Visszaállítás"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'it-IT': {
            "calendar": {
                "months": [
                    "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre",
                    "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"
                ],
                "days": [
                    "Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato",
                    "Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa",
                    "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
                ],
                "time": {
                    "days": "GIORNI",
                    "hours": "ORE",
                    "minutes": "MIN",
                    "seconds": "SEC",
                    "month": "MESE",
                    "day": "GIORNO",
                    "year": "ANNO"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Annulla",
                "done": "Fatto",
                "today": "Oggi",
                "now": "Adesso",
                "clear": "Cancella",
                "help": "Aiuto",
                "yes": "Sì",
                "no": "No",
                "random": "Random",
                "save": "Salvare",
                "reset": "Reset"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'pt-BR': {
            "calendar": {
                "months": [
                    "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro",
                    "Jan", "Fev", "Mar", "Abr", "Maio", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"
                ],
                "days": [
                    "Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado",
                    "Do", "Se", "Te", "Qa", "Qi", "Se", "Sa",
                    "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
                ],
                "time": {
                    "days": "DIAS",
                    "hours": "HORAS",
                    "minutes": "MINUTOS",
                    "seconds": "SEGUNDOS",
                    "month": "MÊS",
                    "day": "DIA",
                    "year": "ANO"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "OK",
                "cancel": "Cancelar",
                "done": "Feito",
                "today": "Hoje",
                "now": "Agora",
                "clear": "Limpar",
                "help": "Ajuda",
                "yes": "Sim",
                "no": "Não",
                "random": "Aleatório",
                "save": "Salvar",
                "reset": "Restaurar"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'ru-RU': {
            "calendar": {
                "months": [
                    "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь",
                    "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"
                ],
                "days": [
                    "Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота",
                    "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб",
                    "Вос", "Пон", "Вто", "Сре", "Чет", "Пят", "Суб"
                ],
                "time": {
                    "days": "ДНИ",
                    "hours": "ЧАСЫ",
                    "minutes": "МИН",
                    "seconds": "СЕК",
                    "month": "МЕС",
                    "day": "ДЕНЬ",
                    "year": "ГОД"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "ОК",
                "cancel": "Отмена",
                "done": "Готово",
                "today": "Сегодня",
                "now": "Сейчас",
                "clear": "Очистить",
                "help": "Помощь",
                "yes": "Да",
                "no": "Нет",
                "random": "Случайно",
                "save": "Сохранить",
                "reset": "Сброс"
            },
            "table": {
                "rowsCount": "Показать записей:",
                "search": "Поиск:",
                "info": "Показаны $1 с $2 по $3 записей",
                "prev": "Предыдущие",
                "next": "Следующие",
                "all": "Все",
                "inspector": "Инспектор",
                "skip": "Перейти на страницу",
                "empty": "Нет записей"
            },
            "colorSelector": {
                addUserColorButton: "ДОБАВИТЬ В ОБРАЗЦЫ",
                userColorsTitle: "ЦВЕТА ПОЛЬЗОВАТЕЛЯ"
            },
            "switch": {
                on: "вкл",
                off: "выкл"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'tr-TR': {
            "calendar": {
                "months": [
                    "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık",
                    "Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara"
                ],
                "days": [
                    "Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi",
                    "Pa", "Pz", "Sa", "Ça", "Pe", "Cu", "Ct",
                    "Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"
                ],
                "time": {
                    "days": "GÜN",
                    "hours": "SAAT",
                    "minutes": "DAK",
                    "seconds": "SAN",
                    "month": "AY",
                    "day": "GÜN",
                    "year": "YIL"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "Tamam",
                "cancel": "Vazgeç",
                "done": "Bitti",
                "today": "Bugün",
                "now": "Şimdi",
                "clear": "Temizle",
                "help": "Yardım",
                "yes": "Evet",
                "no": "Hayır",
                "random": "Rasgele",
                "save": "Kurtarmak",
                "reset": "Sıfırla"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'uk-UA': {
            "calendar": {
                "months": [
                    "Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень",
                    "Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"
                ],
                "days": [
                    "Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П’ятниця", "Субота",
                    "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб",
                    "Нед", "Пон", "Вiв", "Сер", "Чет", "Пят", "Суб"
                ],
                "time": {
                    "days": "ДНІ",
                    "hours": "ГОД",
                    "minutes": "ХВИЛ",
                    "seconds": "СЕК",
                    "month": "МІС",
                    "day": "ДЕНЬ",
                    "year": "РІК"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "ОК",
                "cancel": "Відміна",
                "done": "Готово",
                "today": "Сьогодні",
                "now": "Зараз",
                "clear": "Очистити",
                "help": "Допомога",
                "yes": "Так",
                "no": "Ні",
                "random": "Випадково",
                "save": "Зберегти",
                "reset": "Скинути"
            },
            "table": {
                "rowsCount": "Показати записів:",
                "search": "Пошук:",
                "info": "Показано $1 з $2 по $3 записів",
                "prev": "Попередні",
                "next": "Наступні",
                "all": "Усі",
                "inspector": "Інспектор",
                "skip": "Перейти до сторінки",
                "empty": "Нема записів"
            },
            "colorSelector": {
                addUserColorButton: "ДОДАТИ В ЗРАЗКИ",
                userColorsTitle: "КОЛІРИ КОРИСТУВАЧА"
            },
            "switch": {
                on: "увм",
                off: "вім"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'zh-CN': {
            "calendar": {
                "months": [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月",
                    "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
                ],
                "days": [
                    "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六",
                    "日", "一", "二", "三", "四", "五", "六",
                    "周日", "周一", "周二", "周三", "周四", "周五", "周六"
                ],
                "time": {
                    "days": "天",
                    "hours": "时",
                    "minutes": "分",
                    "seconds": "秒",
                    "month": "月",
                    "day": "日",
                    "year": "年"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "确认",
                "cancel": "取消",
                "done": "完成",
                "today": "今天",
                "now": "现在",
                "clear": "清除",
                "help": "帮助",
                "yes": "是",
                "no": "否",
                "random": "随机",
                "save": "保存",
                "reset": "重啟"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    $.extend(Metro.locales, {
        'zh-TW': {
            "calendar": {
                "months": [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月",
                    "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
                ],
                "days": [
                    "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六",
                    "日", "一", "二", "三", "四", "五", "六",
                    "週日", "週一", "週二", "週三", "週四", "週五", "週六"
                ],
                "time": {
                    "days": "天",
                    "hours": "時",
                    "minutes": "分",
                    "seconds": "秒",
                    "month": "月",
                    "day": "日",
                    "year": "年"
                },
                "weekStart": 1
            },
            "buttons": {
                "ok": "確認",
                "cancel": "取消",
                "done": "完成",
                "today": "今天",
                "now": "現在",
                "clear": "清除",
                "help": "幫助",
                "yes": "是",
                "no": "否",
                "random": "隨機",
                "save": "保存",
                "reset": "重啟"
            },
            "table": {
                "rowsCount": "Show entries:",
                "search": "Search:",
                "info": "Showing $1 to $2 of $3 entries",
                "prev": "Prev",
                "next": "Next",
                "all": "All",
                "inspector": "Inspector",
                "skip": "Goto page",
                "empty": "Nothing to show"
            },
            "colorSelector": {
                addUserColorButton: "ADD TO SWATCHES",
                userColorsTitle: "USER COLORS"
            },
            "switch": {
                on: "on",
                off: "off"
            }
        }
    });
}(Metro, m4q));

(function() {
    'use strict';

    if (typeof Array.prototype.shuffle !== "function") {
        Array.prototype.shuffle = function () {
            var currentIndex = this.length, temporaryValue, randomIndex;

            while (0 !== currentIndex) {

                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                temporaryValue = this[currentIndex];
                this[currentIndex] = this[randomIndex];
                this[randomIndex] = temporaryValue;
            }

            return this;
        };
    }

    if (typeof Array.prototype.clone !== "function") {
        Array.prototype.clone = function () {
            return this.slice(0);
        };
    }

    if (typeof Array.prototype.unique !== "function") {
        Array.prototype.unique = function () {
            var a = this.concat();
            for (var i = 0; i < a.length; ++i) {
                for (var j = i + 1; j < a.length; ++j) {
                    if (a[i] === a[j])
                        a.splice(j--, 1);
                }
            }

            return a;
        };
    }

}());

(function() {
    'use strict';

    /**
     * Number.prototype.format(n, x, s, c)
     *
     * @param  n: length of decimal
     * @param  x: length of whole part
     * @param  s: sections delimiter
     * @param  c: decimal delimiter
     */
    Number.prototype.format = function(n, x, s, c) {
        var re = '\\d(?=(\\d{' + (x || 3) + '})+' + (n > 0 ? '\\D' : '$') + ')',
            num = this.toFixed(Math.max(0, ~~n));

        return (c ? num.replace('.', c) : num).replace(new RegExp(re, 'g'), '$&' + (s || ','));
    };
}());

(function() {
    'use strict';

    String.prototype.toArray = function(delimiter, type, format, locale){
        var str = this;
        var a;

        type = type || "string";
        delimiter = delimiter || ",";
        format = format === undefined || format === null ? false : format;

        a = (""+str).split(delimiter);

        return a.map(function(s){
            var result;

            switch (type) {
                case "int":
                case "integer": result = isNaN(s) ? s.trim() : parseInt(s); break;
                case "number":
                case "float": result = isNaN(s) ? s : parseFloat(s); break;
                case "date": result = !format ? datetime(s) : Datetime.from(s, format, locale || 'en-US'); break;
                default: result = s.trim();
            }

            return result;
        });
    };

    String.prototype.capitalize = function(){
        var str = this;
        return str.substr(0, 1).toUpperCase() + str.substr(1)
    }
}());

(function(Metro, $) {
    'use strict';
    Metro.utils = {
        isVisible: function(element){
            var el = $(element)[0];
            return this.getStyleOne(el, "display") !== "none"
                && this.getStyleOne(el, "visibility") !== "hidden"
                && el.offsetParent !== null;
        },

        isUrl: function (val) {
            /* eslint-disable-next-line */
            return /^(\.\/|\.\.\/|ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@\-\/]))?/.test(val);
        },

        isTag: function(val){
            /* eslint-disable-next-line */
            return /^<\/?[\w\s="/.':;#-\/\?]+>/gi.test(val);
        },

        isEmbedObject: function(val){
            var embed = ["iframe", "object", "embed", "video"];
            var result = false;
            $.each(embed, function(){
                if (typeof val === "string" && val.toLowerCase() === this) {
                    result = true;
                } else if (val.nodeType !== undefined && val.tagName.toLowerCase() === this) {
                    result = true;
                }
            });
            return result;
        },

        isVideoUrl: function(val){
            return /youtu\.be|youtube|twitch|vimeo/gi.test(val);
        },

        isDate: function(val, format, locale){
            var result;

            if (this.isDateObject(val)) {
                return true;
            }

            try {
                result = format ? Datetime.from(val, format, locale || "en-US") : datetime(val)
                return Datetime.isDatetime(result);
            } catch (e) {
                return false;
            }
        },

        isDateObject: function(v){
            return typeof v === 'object' && v.getMonth !== undefined;
        },

        isInt: function(n){
            return !isNaN(n) && +n % 1 === 0;
        },

        isFloat: function(n){
            return (!isNaN(n) && +n % 1 !== 0) || /^\d*\.\d+$/.test(n);
        },

        isFunc: function(f){
            return this.isType(f, 'function');
        },

        isObject: function(o){
            return this.isType(o, 'object');
        },

        isObject2: function(o){
            return typeof o === "object" && !Array.isArray(o);
        },

        isType: function(o, t){
            if (!this.isValue(o)) {
                return false;
            }

            if (typeof o === t) {
                return o;
            }

            if ((""+t).toLowerCase() === 'tag' && this.isTag(o)) {
                return o;
            }

            if ((""+t).toLowerCase() === 'url' && this.isUrl(o)) {
                return o;
            }

            if ((""+t).toLowerCase() === 'array' && Array.isArray(o)) {
                return o;
            }

            if (this.isTag(o) || this.isUrl(o)) {
                return false;
            }

            if (typeof window[o] === t) {
                return window[o];
            }

            if (typeof o === 'string' && o.indexOf(".") === -1) {
                return false;
            }

            if (typeof o === 'string' && /[/\s([]+/gm.test(o)) {
                return false;
            }

            if (typeof o === "number" && t.toLowerCase() !== "number") {
                return false;
            }

            var ns = o.split(".");
            var i, context = window;

            for(i = 0; i < ns.length; i++) {
                context = context[ns[i]];
            }

            return typeof context === t ? context : false;
        },

        $: function(){
            return window.useJQuery ? jQuery : m4q;
        },

        isMetroObject: function(el, type){
            var $el = $(el), el_obj = Metro.getPlugin(el, type);

            if ($el.length === 0) {
                console.warn(type + ' ' + el + ' not found!');
                return false;
            }

            if (el_obj === undefined) {
                console.warn('Element not contain role '+ type +'! Please add attribute data-role="'+type+'" to element ' + el);
                return false;
            }

            return true;
        },

        isJQuery: function(el){
            return (typeof jQuery !== "undefined" && el instanceof jQuery);
        },

        isM4Q: function(el){
            return (typeof m4q !== "undefined" && el instanceof m4q);
        },

        isQ: function(el){
            return this.isJQuery(el) || this.isM4Q(el);
        },

        embedUrl: function(val){
            if (val.indexOf("youtu.be") !== -1) {
                val = "https://www.youtube.com/embed/" + val.split("/").pop();
            }
            return "<div class='embed-container'><iframe src='"+val+"'></iframe></div>";
        },

        elementId: function(prefix){
            return prefix+"-"+(new Date()).getTime()+$.random(1, 1000);
        },

        secondsToTime: function(s) {
            var days = Math.floor((s % 31536000) / 86400);
            var hours = Math.floor(((s % 31536000) % 86400) / 3600);
            var minutes = Math.floor((((s % 31536000) % 86400) % 3600) / 60);
            var seconds = Math.round((((s % 31536000) % 86400) % 3600) % 60);

            return {
                "d": days,
                "h": hours,
                "m": minutes,
                "s": seconds
            };
        },

        secondsToFormattedString: function(time){
            var sec_num = parseInt(time, 10);
            var hours   = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
            var seconds = sec_num - (hours * 3600) - (minutes * 60);

            return [
                Cake.lpad(hours, 2, "0"),
                Cake.lpad(minutes, 2, "0"),
                Cake.lpad(seconds, 2, "0")
            ].join(":");
        },

        func: function(f){
            /* jshint -W054 */
            return new Function("a", f);
        },

        exec: function(f, args, context){
            var result;
            if (f === undefined || f === null) {return false;}
            var func = this.isFunc(f);

            if (func === false) {
                func = this.func(f);
            }

            try {
                result = func.apply(context, args);
            } catch (err) {
                result = null;
                if (window.METRO_THROWS === true) {
                    throw err;
                }
            }
            return result;
        },

        isOutsider: function(element) {
            var el = $(element);
            var inViewport;
            var clone = el.clone();

            clone.removeAttr("data-role").css({
                visibility: "hidden",
                position: "absolute",
                display: "block"
            });
            el.parent().append(clone);

            inViewport = this.inViewport(clone[0]);

            clone.remove();

            return !inViewport;
        },

        inViewport: function(el){
            var rect = this.rect(el);

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        },

        rect: function(el){
            return el.getBoundingClientRect();
        },

        getCursorPosition: function(el, e){
            var a = this.rect(el);
            return {
                x: this.pageXY(e).x - a.left - window.pageXOffset,
                y: this.pageXY(e).y - a.top - window.pageYOffset
            };
        },

        getCursorPositionX: function(el, e){
            return this.getCursorPosition(el, e).x;
        },

        getCursorPositionY: function(el, e){
            return this.getCursorPosition(el, e).y;
        },

        objectLength: function(obj){
            return Object.keys(obj).length;
        },

        percent: function(total, part, round_value){
            if (total === 0) {
                return 0;
            }
            var result = part * 100 / total;
            return round_value === true ? Math.round(result) : Math.round(result * 100) / 100;
        },

        objectShift: function(obj){
            var min = 0;
            $.each(obj, function(i){
                if (min === 0) {
                    min = i;
                } else {
                    if (min > i) {
                        min = i;
                    }
                }
            });
            delete obj[min];

            return obj;
        },

        objectDelete: function(obj, key){
            if (obj[key] !== undefined) delete obj[key];
        },

        arrayDeleteByMultipleKeys: function(arr, keys){
            keys.forEach(function(ind){
                delete arr[ind];
            });
            return arr.filter(function(item){
                return item !== undefined;
            });
        },

        arrayDelete: function(arr, val){
            var i = arr.indexOf(val);
            if (i > -1) arr.splice(i, 1);
        },

        arrayDeleteByKey: function(arr, key){
            arr.splice(key, 1);
        },

        nvl: function(data, other){
            return data === undefined || data === null ? other : data;
        },

        objectClone: function(obj){
            var copy = {};
            for(var key in obj) {
                if ($.hasProp(obj, key)) {
                    copy[key] = obj[key];
                }
            }
            return copy;
        },

        github: function(repo, callback){
            var that = this;
            $.json('https://api.github.com/repos/' + repo).then(function(data){
                that.exec(callback, [data]);
            });
        },

        detectIE: function() {
            var ua = window.navigator.userAgent;
            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },

        detectChrome: function(){
            return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        },

        pageHeight: function(){
            var body = document.body,
                html = document.documentElement;

            return Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
        },

        cleanPreCode: function(selector){
            var els = Array.prototype.slice.call(document.querySelectorAll(selector), 0);

            els.forEach(function(el){
                var txt = el.textContent
                    .replace(/^[\r\n]+/, "")	// strip leading newline
                    .replace(/\s+$/g, "");

                if (/^\S/gm.test(txt)) {
                    el.textContent = txt;
                    return;
                }

                var mat, str, re = /^[\t ]+/gm, len, min = 1e3;

                /* jshint -W084 */
                /* eslint-disable-next-line */
                while (mat = re.exec(txt)) {
                    len = mat[0].length;

                    if (len < min) {
                        min = len;
                        str = mat[0];
                    }
                }

                if (min === 1e3)
                    return;

                el.textContent = txt.replace(new RegExp("^" + str, 'gm'), "").trim();
            });
        },

        coords: function(element){
            var el = $(element)[0];
            var box = el.getBoundingClientRect();

            return {
                top: box.top + window.pageYOffset,
                left: box.left + window.pageXOffset
            };
        },

        positionXY: function(e, t){
            switch (t) {
                case 'client': return this.clientXY(e);
                case 'screen': return this.screenXY(e);
                case 'page': return this.pageXY(e);
                default: return {x: 0, y: 0};
            }
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        clientXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
                y: e.changedTouches ? e.changedTouches[0].clientY : e.clientY
            };
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        screenXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].screenX : e.screenX,
                y: e.changedTouches ? e.changedTouches[0].screenY : e.screenY
            };
        },

        /**
         *
         * @param {TouchEvent|Event|MouseEvent} e
         * @returns {{x: (*), y: (*)}}
         */
        pageXY: function(e){
            return {
                x: e.changedTouches ? e.changedTouches[0].pageX : e.pageX,
                y: e.changedTouches ? e.changedTouches[0].pageY : e.pageY
            };
        },

        isRightMouse: function(e){
            return "which" in e ? e.which === 3 : "button" in e ? e.button === 2 : undefined;
        },

        hiddenElementSize: function(el, includeMargin){
            var width, height, clone = $(el).clone(true);

            clone.removeAttr("data-role").css({
                visibility: "hidden",
                position: "absolute",
                display: "block"
            });
            $("body").append(clone);

            if (!this.isValue(includeMargin)) {
                includeMargin = false;
            }

            width = clone.outerWidth(includeMargin);
            height = clone.outerHeight(includeMargin);
            clone.remove();
            return {
                width: width,
                height: height
            };
        },

        getStyle: function(element, pseudo){
            var el = $(element)[0];
            return window.getComputedStyle(el, pseudo);
        },

        getStyleOne: function(el, property){
            return this.getStyle(el).getPropertyValue(property);
        },

        getInlineStyles: function(element){
            var i, l, styles = {}, el = $(element)[0];
            for (i = 0, l = el.style.length; i < l; i++) {
                var s = el.style[i];
                styles[s] = el.style[s];
            }

            return styles;
        },

        encodeURI: function(str){
            return encodeURI(str).replace(/%5B/g, '[').replace(/%5D/g, ']');
        },

        updateURIParameter: function(uri, key, value) {
            var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
            var separator = uri.indexOf('?') !== -1 ? "&" : "?";
            if (uri.match(re)) {
                return uri.replace(re, '$1' + key + "=" + value + '$2');
            }
            else {
                return uri + separator + key + "=" + value;
            }
        },

        getURIParameter: function(url, name){
            if (!url) url = window.location.href;
            /* eslint-disable-next-line */
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        },

        getLocales: function(){
            return Object.keys(Metro.locales);
        },

        addLocale: function(locale){
            Metro.locales = $.extend( {}, Metro.locales, locale );
        },

        aspectRatioH: function(width, a){
            if (a === "16/9") return width * 9 / 16;
            if (a === "21/9") return width * 9 / 21;
            if (a === "4/3") return width * 3 / 4;
        },

        aspectRatioW: function(height, a){
            if (a === "16/9") return height * 16 / 9;
            if (a === "21/9") return height * 21 / 9;
            if (a === "4/3") return height * 4 / 3;
        },

        valueInObject: function(obj, value){
            return Object.values(obj).indexOf(value) > -1;
        },

        keyInObject: function(obj, key){
            return Object.keys(obj).indexOf(key) > -1;
        },

        inObject: function(obj, key, val){
            return obj[key] !== undefined && obj[key] === val;
        },

        newCssSheet: function(media){
            var style = document.createElement("style");

            if (media !== undefined) {
                style.setAttribute("media", media);
            }

            style.appendChild(document.createTextNode(""));

            document.head.appendChild(style);

            return style.sheet;
        },

        addCssRule: function(sheet, selector, rules, index){
            sheet.insertRule(selector + "{" + rules + "}", index);
        },

        media: function(query){
            return window.matchMedia(query).matches;
        },

        mediaModes: function(){
            return window.METRO_MEDIA;
        },

        mediaExist: function(media){
            return window.METRO_MEDIA.indexOf(media) > -1;
        },

        inMedia: function(media){
            return window.METRO_MEDIA.indexOf(media) > -1 && window.METRO_MEDIA.indexOf(media) === window.METRO_MEDIA.length - 1;
        },

        isValue: function(val){
            return val !== undefined && val !== null && val !== "";
        },

        isNull: function(val){
            return val === undefined || val === null;
        },

        isNegative: function(val){
            return parseFloat(val) < 0;
        },

        isPositive: function(val){
            return parseFloat(val) > 0;
        },

        isZero: function(val){
            return (parseFloat(val.toFixed(2))) === 0.00;
        },

        between: function(val, bottom, top, equals){
            return equals === true ? val >= bottom && val <= top : val > bottom && val < top;
        },

        parseMoney: function(val){
            return Number(parseFloat(val.replace(/[^0-9-.]/g, '')));
        },

        parseCard: function(val){
            return val.replace(/[^0-9]/g, '');
        },

        parsePhone: function(val){
            return this.parseCard(val);
        },

        parseNumber: function(val, thousand, decimal){
            return val.replace(new RegExp('\\'+thousand, "g"), "").replace(new RegExp('\\'+decimal, 'g'), ".");
        },

        nearest: function(val, precision, down){
            val /= precision;
            val = Math[down === true ? 'floor' : 'ceil'](val) * precision;
            return val;
        },

        bool: function(value){
            switch(value){
                case true:
                case "true":
                case 1:
                case "1":
                case "on":
                case "yes":
                    return true;
                default:
                    return false;
            }
        },

        copy: function(element){
            var body = document.body, range, sel;
            var el = $(element)[0];

            if (document.createRange && window.getSelection) {
                range = document.createRange();
                sel = window.getSelection();
                sel.removeAllRanges();
                try {
                    range.selectNodeContents(el);
                    sel.addRange(range);
                } catch (e) {
                    range.selectNode(el);
                    sel.addRange(range);
                }
            } else if (body["createTextRange"]) {
                range = body["createTextRange"]();
                range["moveToElementText"](el);
                range.select();
            }

            document.execCommand("Copy");

            if (window.getSelection) {
                if (window.getSelection().empty) {  // Chrome
                    window.getSelection().empty();
                } else if (window.getSelection().removeAllRanges) {  // Firefox
                    window.getSelection().removeAllRanges();
                }
            } else if (document["selection"]) {  // IE?
                document["selection"].empty();
            }
        },

        decCount: function(v){
            return v % 1 === 0 ? 0 : v.toString().split(".")[1].length;
        }
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Utils = Metro.utils;
    }
}(Metro, m4q));

(function(Metro, $){
    'use strict';
    var Utils = Metro.utils;
    var AccordionDefaultConfig = {
        accordionDeferred: 0,
        showMarker: true,
        material: false,
        duration: METRO_ANIMATION_DURATION,
        oneFrame: true,
        showActive: true,
        activeFrameClass: "",
        activeHeadingClass: "",
        activeContentClass: "",
        clsFrame: "",
        clsHeading: "",
        clsContent: "",
        clsAccordion: "",
        clsActiveFrame: "",
        clsActiveFrameHeading: "",
        clsActiveFrameContent: "",
        onFrameOpen: Metro.noop,
        onFrameBeforeOpen: Metro.noop_true,
        onFrameClose: Metro.noop,
        onFrameBeforeClose: Metro.noop_true,
        onAccordionCreate: Metro.noop
    };

    Metro.accordionSetup = function(options){
        AccordionDefaultConfig = $.extend({}, AccordionDefaultConfig, options);
    };

    if (typeof window["metroAccordionSetup"] !== undefined) {
        Metro.accordionSetup(window["metroAccordionSetup"]);
    }

    Metro.Component('accordion', {
        init: function( options, elem ) {
            this._super(elem, options, AccordionDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent('accordionCreate', {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var frames = element.children(".frame");
            var active = element.children(".frame.active");
            var frame_to_open;

            element
                .addClass("accordion")
                .addClass(o.clsAccordion)
            ;

            frames
                .addClass(o.clsFrame)
                .each(function(){
                    var $el = $(this);
                    $el.children(".heading").addClass(o.clsHeading);
                    $el.children(".content").addClass(o.clsContent);
                })
            ;

            if (o.showMarker === true) {
                element.addClass("marker-on");
            }

            if (o.material === true) {
                element.addClass("material");
            }

            if (active.length === 0) {
                frame_to_open = frames[0];
            } else {
                frame_to_open = active[0];
            }

            this._hideAll();

            if (o.showActive === true) {
                if (o.oneFrame === true) {
                    this._openFrame(frame_to_open);
                } else {
                    $.each(active, function(){
                        that._openFrame(this);
                    });
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var active = element.children(".frame.active");

            element.on(Metro.events.click, ".heading", function(){
                var heading = $(this);
                var frame = heading.parent();

                if (heading.closest(".accordion")[0] !== element[0]) {
                    return false;
                }

                if (frame.hasClass("active")) {
                    if (active.length === 1 && o.oneFrame) {
                        /* eslint-disable-next-line */

                    } else {
                        that._closeFrame(frame);
                    }
                } else {
                    that._openFrame(frame);
                }
            });
        },

        _openFrame: function(f){
            var element = this.element, o = this.options;
            var frame = $(f);

            if (Utils.exec(o.onFrameBeforeOpen, [frame[0]], element[0]) === false) {
                return false;
            }

            if (o.oneFrame === true) {
                this._closeAll(frame[0]);
            }

            frame.addClass("active " + o.activeFrameClass).addClass(o.clsActiveFrame);
            frame.children(".heading").addClass(o.activeHeadingClass).addClass(o.clsActiveFrameHeading);
            frame.children(".content").addClass(o.activeContentClass).addClass(o.clsActiveFrameContent).slideDown(o.duration);

            this._fireEvent("frameOpen", {
                frame: frame[0]
            });
        },

        _closeFrame: function(f){
            var element = this.element, o = this.options;
            var frame = $(f);

            if (!frame.hasClass("active")) {
                return ;
            }

            if (Utils.exec(o.onFrameBeforeClose, [frame[0]], element[0]) === false) {
                return ;
            }

            frame.removeClass("active " + o.activeFrameClass).removeClass(o.clsActiveFrame);
            frame.children(".heading").removeClass(o.activeHeadingClass).removeClass(o.clsActiveFrameHeading);
            frame.children(".content").removeClass(o.activeContentClass).removeClass(o.clsActiveFrameContent).slideUp(o.duration);

            this._fireEvent("frameClose", {
                frame: frame[0]
            });
        },

        _closeAll: function(skip){
            var that = this, element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                if (skip === this) return;
                that._closeFrame(this);
            });
        },

        _hideAll: function(){
            var element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                $(this).children(".content").hide();
            });
        },

        _openAll: function(){
            var that = this, element = this.element;
            var frames = element.children(".frame");

            $.each(frames, function(){
                that._openFrame(this);
            });
        },

        open: function(i){
            var frame = this.element.children(".frame").eq(i);
            this._openFrame(frame);
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attr, newVal){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".heading");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ActivityDefaultConfig = {
        activityDeferred: 0,
        type: "ring",
        style: "color",
        size: 64,
        radius: 20,
        onActivityCreate: Metro.noop
    };

    Metro.activitySetup = function(options){
        ActivityDefaultConfig = $.extend({}, ActivityDefaultConfig, options);
    };

    if (typeof window["metroActivitySetup"] !== undefined) {
        Metro.activitySetup(window["metroActivitySetup"]);
    }

    Metro.Component('activity', {
        init: function( options, elem ) {
            this._super(elem, options, ActivityDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i, wrap;

            element
                .html('')
                .addClass(o.style + "-style")
                .addClass("activity-" + o.type);

            function _metro(){
                for(i = 0; i < 5 ; i++) {
                    $("<div/>").addClass('circle').appendTo(element);
                }
            }

            function _square(){
                for(i = 0; i < 4 ; i++) {
                    $("<div/>").addClass('square').appendTo(element);
                }
            }

            function _cycle(){
                $("<div/>").addClass('cycle').appendTo(element);
            }

            function _ring(){
                for(i = 0; i < 5 ; i++) {
                    wrap = $("<div/>").addClass('wrap').appendTo(element);
                    $("<div/>").addClass('circle').appendTo(wrap);
                }
            }

            function _simple(){
                $('<svg class="circular"><circle class="path" cx="'+o.size/2+'" cy="'+o.size/2+'" r="'+o.radius+'" fill="none" stroke-width="2" stroke-miterlimit="10"/></svg>').appendTo(element);
            }

            function _atom(){
                for(i = 0; i < 3 ; i++) {
                    $("<span/>").addClass('electron').appendTo(element);
                }
            }

            function _bars(){
                for(i = 0; i < 6 ; i++) {
                    $("<span/>").addClass('bar').appendTo(element);
                }
            }

            switch (o.type) {
                case 'metro': _metro(); break;
                case 'square': _square(); break;
                case 'cycle': _cycle(); break;
                case 'simple': _simple(); break;
                case 'atom': _atom(); break;
                case 'bars': _bars(); break;
                default: _ring();
            }

            this._fireEvent("activity-create", {
                element: element
            })
        },

        /*eslint-disable-next-line*/
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro.activity = {
        open: function(options){
            var o = options || {};
            var activity = '<div data-role="activity" data-type="'+( o.type ? o.type : 'cycle' )+'" data-style="'+( o.style ? o.style : 'color' )+'"></div>';
            var text = o.text ? '<div class="text-center">'+o.text+'</div>' : '';

            return Metro.dialog.create({
                content: activity + text,
                defaultAction: false,
                clsContent: "d-flex flex-column flex-justify-center flex-align-center bg-transparent no-shadow w-auto",
                clsDialog: "no-border no-shadow bg-transparent global-dialog",
                autoHide: o.autoHide ? o.autoHide : 0,
                overlayClickClose: o.overlayClickClose === true,
                overlayColor: o.overlayColor ? o.overlayColor : '#000000',
                overlayAlpha: o.overlayAlpha ? o.overlayAlpha : 0.5,
                clsOverlay: "global-overlay"
            });
        },

        close: function(a){
            Metro.dialog.close(a);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AdblockDefaultConfig = {
        adblockDeferred: 0,
        checkInterval: 1000,
        fireOnce: true,
        checkStop: 10,
        localhost: false,
        onAlert: Metro.noop,
        onFishingStart: Metro.noop,
        onFishingDone: Metro.noop
    };

    Metro.adblockSetup = function(options){
        AdblockDefaultConfig = $.extend({}, AdblockDefaultConfig, options);
    };

    if (typeof window["metroAdblockSetup"] !== undefined) {
        Metro.adblockSetup(window["metroAdblockSetup"]);
    }

    var Adblock = {
        bite: function(){
            var classes = "adblock-bite adsense google-adsense dblclick advert topad top_ads topAds textads sponsoredtextlink_container show_ads right-banner rekl mpu module-ad mid_ad mediaget horizontal_ad headerAd contentAd brand-link bottombanner bottom_ad_block block_ad bannertop banner-right banner-body b-banner b-article-aside__banner b-advert adwrapper adverts advertisment advertisement:not(body) advertise advert_list adtable adsense adpic adlist adleft adinfo adi adholder adframe addiv ad_text ad_space ad_right ad_links ad_body ad_block ad_Right adTitle adText";
            $("<div>")
                .addClass(classes.split(" ").shuffle().join(" "))
                .css({
                    position: "fixed",
                    height: 1,
                    width: 1,
                    overflow: "hidden",
                    visibility: "visible",
                    top: 0,
                    left: 0
                })
                .append($("<a href='https://dblclick.net'>").html('dblclick.net'))
                .appendTo('body');

            if (Adblock.options.adblockDeferred) {
                setTimeout(function () {
                    Adblock.fishing();
                }, Adblock.options.adblockDeferred);
            } else this.fishing();
        },

        fishing: function(){
            var o = Adblock.options;
            var checks = typeof o.fireOnce === "number" ? o.fireOnce : 0;
            var checkStop = o.checkStop;
            var interval = false;
            var run = function(){
                var a = $(".adsense.google-adsense.dblclick.advert.adblock-bite");
                var b = a.find("a");
                var done = function(){
                    clearInterval(interval);

                    Utils.exec(o.onFishingDone);
                    $(window).fire("fishing-done");

                    a.remove();
                };

                if (!o.localhost && $.localhost) {
                    done();
                    return ;
                }

                if (   !a.length
                    || !b.length
                    || a.css("display").indexOf('none') > -1
                    || b.css("display").indexOf('none') > -1
                ) {

                    Utils.exec(Adblock.options.onAlert);
                    $(window).fire("adblock-alert");

                    if (Adblock.options.fireOnce === true) {
                        done();
                    } else {
                        checks--;
                        if (checks === 0) {
                            done();
                        }
                    }
                } else {
                    if (checkStop !== false) {
                        checkStop--;
                        if (checkStop === 0) {
                            done();
                        }
                    }
                }
            };

            Utils.exec(o.onFishingStart);
            $(window).fire("fishing-start");

            interval = setInterval(function(){
                run();
            }, Adblock.options.checkInterval);

            run();
        }
    };

    Metro.Adblock = Adblock;

    $(function(){
        Adblock.options = $.extend({}, AdblockDefaultConfig);
        $(window).on("metro-initiated", function(){
            Adblock.bite();
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var AnimationDefaultConfig = {
        duration: METRO_ANIMATION_DURATION,
        ease: "linear"
    }

    Metro.animations = {

        switchIn: function(el){
            $(el)
                .hide()
                .css({
                    left: 0,
                    top: 0
                })
                .show();
        },

        switchOut: function(el){
            $(el).hide();
        },

        switch: function(current, next){
            this.switchOut(current);
            this.switchIn(next);
        },

        slideUpIn: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    top: h,
                    left: 0,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        top: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideUpOut: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        top: -h,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideUp: function(current, next, o){
            this.slideUpOut(current, o);
            this.slideUpIn(next, o);
        },

        slideDownIn: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: 0,
                    top: -h,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        top: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideDownOut: function(el, o){
            var op, $el = $(el);
            var h = $el.parent().outerHeight(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        top: h,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideDown: function(current, next, o){
            this.slideDownOut(current, o);
            this.slideDownIn(next, o);
        },

        slideLeftIn: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: w,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        left: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideLeftOut: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        left: -w,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideLeft: function(current, next, o){
            this.slideLeftOut(current, o);
            this.slideLeftIn(next, o);
        },

        slideRightIn: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    left: -w,
                    zIndex: 2
                })
                .animate({
                    draw: {
                        left: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideRightOut: function(el, o){
            var op, $el = $(el);
            var w = $el.parent().outerWidth(true);

            op = $.extend({}, AnimationDefaultConfig, o);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        left:  w,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        slideRight: function(current, next, o){
            this.slideRightOut(current, o);
            this.slideRightIn(next, o);
        },

        fadeIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0
                })
                .animate({
                    draw: {
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        fadeOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .animate({
                    draw: {
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        fade: function(current, next, o){
            this.fadeOut(current, o);
            this.fadeIn(next, o);
        },

        zoomIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0,
                    transform: "scale(3)",
                    zIndex: 2
                })
                .animate({
                    draw: {
                        scale: 1,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        zoomOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        scale: 3,
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        zoom: function(current, next, o){
            this.zoomOut(current, o);
            this.zoomIn(next, o);
        },

        swirlIn: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    top: 0,
                    left: 0,
                    opacity: 0,
                    transform: "scale(3) rotate(180deg)",
                    zIndex: 2
                })
                .animate({
                    draw: {
                        scale: 1,
                        rotate: 0,
                        opacity: 1
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        swirlOut: function(el, o){
            var op = $.extend({}, AnimationDefaultConfig, o);
            var $el = $(el);

            $el
                .css({
                    zIndex: 1
                })
                .animate({
                    draw: {
                        scale: 3,
                        rotate: "180deg",
                        opacity: 0
                    },
                    dur: op.duration,
                    ease: op.ease
                });
        },

        swirl: function(current, next, o){
            this.swirlOut(current, o);
            this.swirlIn(next, o);
        }
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Animations = Metro.animations;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var AppBarDefaultConfig = {
        appbarDeferred: 0,
        expand: false,
        expandPoint: null,
        duration: 100,
        onMenuOpen: Metro.noop,
        onMenuClose: Metro.noop,
        onBeforeMenuOpen: Metro.noop,
        onBeforeMenuClose: Metro.noop,
        onMenuCollapse: Metro.noop,
        onMenuExpand: Metro.noop,
        onAppBarCreate: Metro.noop
    };

    Metro.appBarSetup = function (options) {
        AppBarDefaultConfig = $.extend({}, AppBarDefaultConfig, options);
    };

    if (typeof window["metroAppBarSetup"] !== undefined) {
        Metro.appBarSetup(window["metroAppBarSetup"]);
    }

    Metro.Component('app-bar', {
        init: function (options, elem) {
            this._super(elem, options, AppBarDefaultConfig, {
                id: Utils.elementId('app-bar')
            });

            return this;
        },

        _create: function () {
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("app-bar-create", {
                element: element
            })
        },

        _createStructure: function () {
            var element = this.element, o = this.options;
            var hamburger, menu, elementColor = Utils.getStyleOne(element, "background-color");

            element.addClass("app-bar");

            hamburger = element.find(".hamburger");
            if (hamburger.length === 0) {
                hamburger = $("<button>").attr("type", "button").addClass("hamburger menu-down");
                for (var i = 0; i < 3; i++) {
                    $("<span>").addClass("line").appendTo(hamburger);
                }

                if (elementColor === "rgba(0, 0, 0, 0)" || Metro.colors.isLight(elementColor) === true) {
                    hamburger.addClass("dark");
                }
            }

            element.prepend(hamburger);
            menu = element.find(".app-bar-menu");

            if (menu.length === 0) {
                hamburger.css("display", "none");
            } else {
                Utils.addCssRule(Metro.sheet, ".app-bar-menu li", "list-style: none!important;"); // This special for IE11 and Edge
            }

            if (hamburger.css('display') === 'block') {
                menu.hide().addClass("collapsed");
                hamburger.removeClass("hidden");
            } else {
                hamburger.addClass("hidden");
            }

            if (o.expand === true) {
                element.addClass("app-bar-expand");
                hamburger.addClass("hidden");
            } else {
                if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint)) {
                    element.addClass("app-bar-expand");
                    hamburger.addClass("hidden");
                }
            }
        },

        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            var menu = element.find(".app-bar-menu");
            var hamburger = element.find(".hamburger");

            element.on(Metro.events.click, ".hamburger", function () {
                if (menu.length === 0) return;
                var collapsed = menu.hasClass("collapsed");
                if (collapsed) {
                    that.open();
                } else {
                    that.close();
                }
            });

            $(window).on(Metro.events.resize, function () {

                if (o.expand !== true) {
                    if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint)) {
                        element.addClass("app-bar-expand");
                        that._fireEvent("menu-expand");
                    } else {
                        element.removeClass("app-bar-expand");
                        that._fireEvent("menu-collapse");
                    }
                }

                if (menu.length === 0) return;

                if (hamburger.css('display') !== 'block') {
                    menu.show(function () {
                        $(this).removeStyleProperty("display");
                    });
                    hamburger.addClass("hidden");
                } else {
                    hamburger.removeClass("hidden");
                    if (hamburger.hasClass("active")) {
                        menu.show().removeClass("collapsed");
                    } else {
                        menu.hide().addClass("collapsed");
                    }
                }
            }, {ns: this.id});
        },

        close: function () {
            var that = this, element = this.element, o = this.options;
            var menu = element.find(".app-bar-menu");
            var hamburger = element.find(".hamburger");

            that._fireEvent("before-menu-close", {
                menu: menu[0]
            });

            menu.slideUp(o.duration, function () {
                menu.addClass("collapsed").removeClass("opened");
                hamburger.removeClass("active");

                that._fireEvent("menu-close", {
                    menu: menu[0]
                });
            });
        },

        open: function () {
            var that = this, element = this.element, o = this.options;
            var menu = element.find(".app-bar-menu");
            var hamburger = element.find(".hamburger");

            that._fireEvent("before-menu-open", {
                menu: menu[0]
            });

            menu.slideDown(o.duration, function () {
                menu.removeClass("collapsed").addClass("opened");
                hamburger.addClass("active");

                that._fireEvent("menu-open", {
                    menu: menu[0]
                });
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function (attributeName) {
        },

        destroy: function () {
            var element = this.element;
            element.off(Metro.events.click, ".hamburger");
            $(window).off(Metro.events.resize, {ns: this.id});
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AudioButtonDefaultConfig = {
        audioVolume: 0.5,
        audioSrc: "",
        onAudioStart: Metro.noop,
        onAudioEnd: Metro.noop,
        onAudioButtonCreate: Metro.noop
    };

    Metro.audioButtonSetup = function (options) {
        AudioButtonDefaultConfig = $.extend({}, AudioButtonDefaultConfig, options);
    };

    if (typeof window["metroAudioButtonSetup"] !== undefined) {
        Metro.audioButtonSetup(window["metroAudioButtonSetup"]);
    }

    Metro.Component('audio-button', {
        init: function( options, elem ) {

            this._super(elem, options, AudioButtonDefaultConfig, {
                audio: null,
                canPlay: null,
                id: Utils.elementId("audioButton")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent('audioButtonCreate', {
                element: element
            });
        },

        _createStructure: function(){
            var o = this.options;
            this.audio = new Audio(o.audioSrc);
            this.audio.volume = o.audioVolume;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var audio = this.audio;

            audio.addEventListener('loadeddata', function(){
                that.canPlay = true;
            });

            audio.addEventListener('ended', function(){
                that._fireEvent("audioEnd", {
                    src: o.audioSrc,
                    audio: audio
                });
            })

            element.on(Metro.events.click, function(){
                that.play();
            }, {ns: this.id});
        },

        play: function(cb){
            var element = this.element, o = this.options;
            var audio = this.audio;

            if (o.audioSrc !== "" && this.audio.duration && this.canPlay) {

                this._fireEvent("audioStart", {
                    src: o.audioSrc,
                    audio: audio
                });

                audio.pause();
                audio.currentTime = 0;
                audio.play();

                Utils.exec(cb, [audio], element[0]);
            }
        },

        stop: function(cb){
            var element = this.element, o = this.options;
            var audio = this.audio;

            audio.pause();
            audio.currentTime = 0;

            this._fireEvent("audioEnd", {
                src: o.audioSrc,
                audio: audio
            });

            Utils.exec(cb, [audio], element[0]);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var audio = this.audio;

            var changeSrc = function(){
                var src = element.attr('data-audio-src');
                if (src && src.trim() !== "") {
                    o.audioSrc = src;
                    audio.src = src;
                }
            }

            var changeVolume = function(){
                var volume = parseFloat(element.attr('data-audio-volume'));
                if (isNaN(volume)) {
                    return ;
                }
                o.audioVolume = volume;
                audio.volume = volume;
            }

            if (attributeName === 'data-audio-src') {
                changeSrc();
            }

            if (attributeName === 'data-audio-volume') {
                changeVolume();
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, {ns: this.id});
        }
    });

    Metro["playSound"] = function(data){
        var audio;
        var src = typeof data === "string" ? data : data.audioSrc;
        var volume = data && data.audioVolume ? data.audioVolume : 0.5;

        if (!src) {
            return;
        }

        audio = new Audio(src);
        audio.volume = parseFloat(volume);

        audio.addEventListener('loadeddata', function(){
            if (data && data.onAudioStart)
                Utils.exec(data.onAudioStart, [src], this);
            this.play();
        });

        audio.addEventListener('ended', function(){
            if (data && data.onAudioEnd)
                Utils.exec(data.onAudioEnd, [null], this);
        });
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var AudioPlayerDefaultConfig = {
        audioDeferred: 0,
        playlist: null,
        src: null,

        volume: .5,
        loop: false,
        autoplay: false,

        showLoop: true,
        showPlay: true,
        showStop: true,
        showMute: true,
        showFull: true,
        showStream: true,
        showVolume: true,
        showInfo: true,

        showPlaylist: true,
        showNext: true,
        showPrev: true,
        showFirst: true,
        showLast: true,
        showForward: true,
        showBackward: true,
        showShuffle: true,
        showRandom: true,

        loopIcon: "<span class='default-icon-loop'></span>",
        stopIcon: "<span class='default-icon-stop'></span>",
        playIcon: "<span class='default-icon-play'></span>",
        pauseIcon: "<span class='default-icon-pause'></span>",
        muteIcon: "<span class='default-icon-mute'></span>",
        volumeLowIcon: "<span class='default-icon-low-volume'></span>",
        volumeMediumIcon: "<span class='default-icon-medium-volume'></span>",
        volumeHighIcon: "<span class='default-icon-high-volume'></span>",

        playlistIcon: "<span class='default-icon-playlist'></span>",
        nextIcon: "<span class='default-icon-next'></span>",
        prevIcon: "<span class='default-icon-prev'></span>",
        firstIcon: "<span class='default-icon-first'></span>",
        lastIcon: "<span class='default-icon-last'></span>",
        forwardIcon: "<span class='default-icon-forward'></span>",
        backwardIcon: "<span class='default-icon-backward'></span>",
        shuffleIcon: "<span class='default-icon-shuffle'></span>",
        randomIcon: "<span class='default-icon-random'></span>",

        onPlay: Metro.noop,
        onPause: Metro.noop,
        onStop: Metro.noop,
        onEnd: Metro.noop,
        onMetadata: Metro.noop,
        onTime: Metro.noop,
        onAudioPlayerCreate: Metro.noop
    };

    Metro.audioPlayerSetup = function(options){
        AudioPlayerDefaultConfig = $.extend({}, AudioPlayerDefaultConfig, options);
    };

    if (typeof window["metroAudioPlayerSetup"] !== undefined) {
        Metro.audioPlayerSetup(window["metroAudioPlayerSetup"]);
    }

    Metro.Component('audio-player', {
        init: function( options, elem ) {
            this._super(elem, options, AudioPlayerDefaultConfig, {
                preloader: null,
                player: null,
                audio: elem,
                stream: null,
                volume: null,
                volumeBackup: 0,
                muted: false
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this._createPlayer();
            this._createControls();
            this._createEvents();

            if (o.autoplay === true) {
                this.play();
            }

            this._fireEvent("audio-player-create", {
                element: element,
                player: this.player
            })
        },

        _createPlayer: function(){
            var element = this.element, o = this.options, audio = this.audio;

            var prev = element.prev();
            var parent = element.parent();
            var player = $("<div>").addClass("media-player audio-player " + element[0].className);

            if (prev.length === 0) {
                parent.prepend(player);
            } else {
                player.insertAfter(prev);
            }

            element.appendTo(player);

            $.each(['muted', 'autoplay', 'controls', 'height', 'width', 'loop', 'poster', 'preload'], function(){
                element.removeAttr(this);
            });

            element.attr("preload", "auto");

            audio.volume = o.volume;

            if (o.src !== null) {
                this._setSource(o.src);
            }

            element[0].className = "";

            this.player = player;
        },

        _setSource: function(src){
            var element = this.element;

            element.find("source").remove();
            element.removeAttr("src");
            if (Array.isArray(src)) {
                $.each(src, function(){
                    var item = this;
                    if (item.src === undefined) return ;
                    $("<source>").attr('src', item.src).attr('type', item.type !== undefined ? item.type : '').appendTo(element);
                });
            } else {
                element.attr("src", src);
            }
        },

        _createControls: function(){
            var that = this, element = this.element, o = this.options, audio = this.elem;

            var controls = $("<div>").addClass("controls").addClass(o.clsControls).insertAfter(element);


            var stream = $("<div>").addClass("stream").appendTo(controls);
            var streamSlider = $("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
            var preloader = $("<div>").addClass("load-audio").appendTo(stream);

            var volume = $("<div>").addClass("volume").appendTo(controls);
            var volumeSlider = $("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);

            var infoBox = $("<div>").addClass("info-box").appendTo(controls);

            if (o.showInfo !== true) {
                infoBox.hide();
            }

            preloader.activity({
                type: "metro",
                style: "color"
            });

            preloader.hide(0);

            this.preloader = preloader;

            Metro.makePlugin(streamSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                clsComplete: "bg-cyan",
                hint: true,
                onStart: function(){
                    if (!audio.paused) audio.pause();
                },
                onStop: function(val){
                    if (audio.seekable.length > 0) {
                        audio.currentTime = (that.duration * val / 100).toFixed(0);
                    }
                    if (audio.paused && audio.currentTime > 0) {
                        audio.play();
                    }
                }
            });

            this.stream = streamSlider;

            if (o.showStream !== true) {
                stream.hide();
            }

            Metro.makePlugin(volumeSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                hint: true,
                value: o.volume * 100,
                onChangeValue: function(val){
                    audio.volume = val / 100;
                }
            });

            this.volume = volumeSlider;

            if (o.showVolume !== true) {
                volume.hide();
            }

            var loop;

            if (o.showLoop === true) loop = $("<button>").attr("type", "button").addClass("button square loop").html(o.loopIcon).appendTo(controls);
            if (o.showPlay === true) $("<button>").attr("type", "button").addClass("button square play").html(o.playIcon).appendTo(controls);
            if (o.showStop === true) $("<button>").attr("type", "button").addClass("button square stop").html(o.stopIcon).appendTo(controls);
            if (o.showMute === true) $("<button>").attr("type", "button").addClass("button square mute").html(o.muteIcon).appendTo(controls);

            if (o.loop === true) {
                loop.addClass("active");
                element.attr("loop", "loop");
            }

            this._setVolume();

            if (o.muted) {
                that.volumeBackup = audio.volume;
                Metro.getPlugin(that.volume, 'slider').val(0);
                audio.volume = 0;
            }

            infoBox.html("00:00 / 00:00");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options, audio = this.elem, player = this.player;

            element.on("loadstart", function(){
                that.preloader.fadeIn();
            });

            element.on("loadedmetadata", function(){
                that.duration = audio.duration.toFixed(0);
                that._setInfo(0, that.duration);
                Utils.exec(o.onMetadata, [audio, player], element[0]);
            });

            element.on("canplay", function(){
                that._setBuffer();
                that.preloader.fadeOut();
            });

            element.on("progress", function(){
                that._setBuffer();
            });

            element.on("timeupdate", function(){
                var position = Math.round(audio.currentTime * 100 / that.duration);
                that._setInfo(audio.currentTime, that.duration);
                Metro.getPlugin(that.stream, 'slider').val(position);
                Utils.exec(o.onTime, [audio.currentTime, that.duration, audio, player], element[0]);
            });

            element.on("waiting", function(){
                that.preloader.fadeIn();
            });

            element.on("loadeddata", function(){

            });

            element.on("play", function(){
                player.find(".play").html(o.pauseIcon);
                Utils.exec(o.onPlay, [audio, player], element[0]);
            });

            element.on("pause", function(){
                player.find(".play").html(o.playIcon);
                Utils.exec(o.onPause, [audio, player], element[0]);
            });

            element.on("stop", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onStop, [audio, player], element[0]);
            });

            element.on("ended", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onEnd, [audio, player], element[0]);
            });

            element.on("volumechange", function(){
                that._setVolume();
            });

            player.on(Metro.events.click, ".play", function(){
                if (audio.paused) {
                    that.play();
                } else {
                    that.pause();
                }
            });

            player.on(Metro.events.click, ".stop", function(){
                that.stop();
            });

            player.on(Metro.events.click, ".mute", function(){
                that._toggleMute();
            });

            player.on(Metro.events.click, ".loop", function(){
                that._toggleLoop();
            });
        },

        _toggleLoop: function(){
            var loop = this.player.find(".loop");
            if (loop.length === 0) return ;
            loop.toggleClass("active");
            if (loop.hasClass("active")) {
                this.element.attr("loop", "loop");
            } else {
                this.element.removeAttr("loop");
            }
        },

        _toggleMute: function(){
            this.muted = !this.muted;
            if (this.muted === false) {
                this.audio.volume = this.volumeBackup;
            } else {
                this.volumeBackup = this.audio.volume;
                this.audio.volume = 0;
            }
            Metro.getPlugin(this.volume, 'slider').val(this.muted === false ? this.volumeBackup * 100 : 0);
        },

        _setInfo: function(a, b){
            this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a)) + " / " + Utils.secondsToFormattedString(Math.round(b)));
        },

        _setBuffer: function(){
            var buffer = this.audio.buffered.length ? Math.round(Math.floor(this.audio.buffered.end(0)) / Math.floor(this.audio.duration) * 100) : 0;
            Metro.getPlugin(this.stream, 'slider').buff(buffer);
        },

        _setVolume: function(){
            var audio = this.audio, player = this.player, o = this.options;

            var volumeButton = player.find(".mute");
            var volume = audio.volume * 100;
            if (volume > 1 && volume < 30) {
                volumeButton.html(o.volumeLowIcon);
            } else if (volume >= 30 && volume < 60) {
                volumeButton.html(o.volumeMediumIcon);
            } else if (volume >= 60 && volume <= 100) {
                volumeButton.html(o.volumeHighIcon);
            } else {
                volumeButton.html(o.muteIcon);
            }
        },

        play: function(src){
            if (src !== undefined) {
                this._setSource(src);
            }

            if (this.element.attr("src") === undefined && this.element.find("source").length === 0) {
                return ;
            }

            this.audio.play();
        },

        pause: function(){
            this.audio.pause();
        },

        resume: function(){
            if (this.audio.paused) {
                this.play();
            }
        },

        stop: function(){
            this.audio.pause();
            this.audio.currentTime = 0;
            Metro.getPlugin(this.stream, 'slider').val(0);
        },

        setVolume: function(v){
            if (v === undefined) {
                return this.audio.volume;
            }

            if (v > 1) {
                v /= 100;
            }

            this.audio.volume = v;
            Metro.getPlugin(this.volume, 'slider').val(v*100);
        },

        loop: function(){
            this._toggleLoop();
        },

        mute: function(){
            this._toggleMute();
        },

        changeSource: function(){
            var src = JSON.parse(this.element.attr('data-src'));
            this.play(src);
        },

        changeVolume: function(){
            var volume = this.element.attr("data-volume");
            this.setVolume(volume);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-src": this.changeSource(); break;
                case "data-volume": this.changeVolume(); break;
            }
        },

        destroy: function(){
            var element = this.element, player = this.player;

            element.off("all");
            player.off("all");

            Metro.getPlugin(this.stream, "slider").destroy();
            Metro.getPlugin(this.volume, "slider").destroy();

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var BottomSheetDefaultConfig = {
        bottomsheetDeferred: 0,
        mode: "list",
        toggle: null,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onBottomSheetCreate: Metro.noop
    };

    Metro.bottomSheetSetup = function(options){
        BottomSheetDefaultConfig = $.extend({}, BottomSheetDefaultConfig, options);
    };

    if (typeof window["metroBottomSheetSetup"] !== undefined) {
        Metro.bottomSheetSetup(window["metroBottomSheetSetup"]);
    }

    Metro.Component('bottom-sheet', {
        init: function( options, elem ) {
            this._super(elem, options, BottomSheetDefaultConfig, {
                toggle: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("bottom-sheet-create", {
                element: element
            })
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element
                .addClass("bottom-sheet")
                .addClass(o.mode+"-list");

            if (Utils.isValue(o.toggle) && $(o.toggle).length > 0) {
                this.toggle = $(o.toggle);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element;

            if (Utils.isValue(this.toggle)) {
                this.toggle.on(Metro.events.click, function(){
                    that.toggle();
                });
            }

            element.on(Metro.events.click, "li", function(){
                that.close();
            });
        },

        isOpen: function(){
            return this.element.hasClass("opened");
        },

        open: function(mode){
            var element = this.element;

            if (Utils.isValue(mode)) {
                element.removeClass("list-style grid-style").addClass(mode+"-style");
            }

            this.element.addClass("opened");

            this._fireEvent("open", {
                element: element
            })
        },

        close: function(){
            var element = this.element;

            element.removeClass("opened");

            this._fireEvent("close", {
                element: element
            })
        },

        toggle: function(mode){
            if (this.isOpen()) {
                this.close();
            } else {
                this.open(mode);
            }
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            if (Utils.isValue(this.toggle)) {
                this.toggle.off(Metro.events.click);
            }

            element.off(Metro.events.click, "li");
            return element;
        }
    });

    Metro['bottomsheet'] = {
        isBottomSheet: function(el){
            return Utils.isMetroObject(el, "bottom-sheet");
        },

        open: function(el, as){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            Metro.getPlugin(el, "bottom-sheet").open(as);
        },

        close: function(el){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            Metro.getPlugin(el, "bottom-sheet").close();
        },

        toggle: function(el, as){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            if (this.isOpen(el)) {
                this.close(el);
            } else {
                this.open(el, as);
            }
        },

        isOpen: function(el){
            if (!this.isBottomSheet(el)) {
                return false;
            }
            return Metro.getPlugin(el, "bottom-sheet").isOpen();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ButtonGroupDefaultConfig = {
        buttongroupDeferred: 0,
        targets: "button",
        clsActive: "",
        requiredButton: false,
        mode: Metro.groupMode.ONE,
        onButtonClick: Metro.noop,
        onButtonGroupCreate: Metro.noop
    };

    Metro.buttonGroupSetup = function(options){
        ButtonGroupDefaultConfig = $.extend({}, ButtonGroupDefaultConfig, options);
    };

    if (typeof window["metroButtonGroupSetup"] !== undefined) {
        Metro.buttonGroupSetup(window["metroButtonGroupSetup"]);
    }

    Metro.Component('button-group', {
        init: function( options, elem ) {
            this._super(elem, options, ButtonGroupDefaultConfig, {
                active: null,
                id: Utils.elementId("button-group")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createGroup();
            this._createEvents();

            this._fireEvent("button-group-create", {
                element: element
            })
        },

        _createGroup: function(){
            var element = this.element, o = this.options;
            var buttons, buttons_active;

            element.addClass("button-group");

            buttons = element.find( o.targets );
            buttons_active = element.find( ".active" );

            if (o.mode === Metro.groupMode.ONE && buttons_active.length === 0 && o.requiredButton === true) {
                $(buttons[0]).addClass("active");
            }

            if (o.mode === Metro.groupMode.ONE && buttons_active.length > 1) {
                buttons.removeClass("active").removeClass(o.clsActive);
                $(buttons[0]).addClass("active");
            }

            element
                .find( ".active" )
                .addClass("js-active")
                .addClass(o.clsActive);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, o.targets, function(){
                var el = $(this);

                that._fireEvent("button-click", {
                    button: this
                })

                if (o.mode === Metro.groupMode.ONE && el.hasClass("active")) {
                    return ;
                }

                if (o.mode === Metro.groupMode.ONE) {
                    element.find(o.targets).removeClass(o.clsActive).removeClass("active js-active");
                    el.addClass("active").addClass(o.clsActive).addClass("js-active");
                } else {
                    el.toggleClass("active").toggleClass(o.clsActive).toggleClass("js-active");
                }

            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element, o = this.options;
            element.off(Metro.events.click, o.targets);
            return element;
        }

    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CalendarDefaultConfig = {
        showGhost: false,
        events: null,
        startContent: "days",
        showTime: false,
        initialTime: null,
        initialHours: null,
        initialMinutes: null,
        labelTimeHours: null,
        labelTimeMinutes: null,

        animationContent: true,
        animationSpeed: 10,

        calendarDeferred: 0,
        dayBorder: false,
        excludeDay: null,
        prevMonthIcon: "<span class='default-icon-chevron-left'></span>",
        nextMonthIcon: "<span class='default-icon-chevron-right'></span>",
        prevYearIcon: "<span class='default-icon-chevron-left'></span>",
        nextYearIcon: "<span class='default-icon-chevron-right'></span>",
        compact: false,
        wide: false,
        widePoint: null,
        pickerMode: false,
        show: null,
        locale: METRO_LOCALE,
        weekStart: METRO_WEEK_START,
        outside: true,
        buttons: 'cancel, today, clear, done',
        yearsBefore: 100,
        yearsAfter: 100,
        headerFormat: "dddd, MMM DD",
        showHeader: true,
        showFooter: true,
        showWeekNumber: false,

        isDialog: false,
        ripple: false,
        rippleColor: "#cccccc",
        exclude: null,
        preset: null,
        minDate: null,
        maxDate: null,
        weekDayClick: false,
        weekNumberClick: false,
        multiSelect: false,
        special: null,
        format: METRO_DATE_FORMAT,
        inputFormat: null,

        clsCalendar: "",
        clsCalendarHeader: "",
        clsCalendarContent: "",
        clsCalendarFooter: "",
        clsCalendarMonths: "",
        clsCalendarYears: "",
        clsToday: "",
        clsSelected: "",
        clsExcluded: "",
        clsCancelButton: "",
        clsTodayButton: "",
        clsClearButton: "",
        clsDoneButton: "",
        clsEventCounter: "",
        clsWeekend: "",
        clsCurrentWeek: "",
        clsCalendarTime: "",
        clsTime: "",
        clsTimeHours: "",
        clsTimeMinutes: "",
        clsTimeButton: "",
        clsTimeButtonPlus: "",
        clsTimeButtonMinus: "",
        clsSpecial: "",
        clsEvents: "",
        clsEvent: "",

        onCancel: Metro.noop,
        onToday: Metro.noop,
        onClear: Metro.noop,
        onDone: Metro.noop,
        onDayClick: Metro.noop,
        onDrawDay: Metro.noop,
        onDrawMonth: Metro.noop,
        onDrawYear: Metro.noop,
        onWeekDayClick: Metro.noop,
        onWeekNumberClick: Metro.noop,
        onMonthChange: Metro.noop,
        onYearChange: Metro.noop,
        onTimeChange: Metro.noop,
        onHoursChange: Metro.noop,
        onMinutesChange: Metro.noop,
        onCalendarCreate: Metro.noop
    };

    Metro.calendarSetup = function (options) {
        CalendarDefaultConfig = $.extend({}, CalendarDefaultConfig, options);
    };

    if (typeof window["metroCalendarSetup"] !== undefined) {
        Metro.calendarSetup(window["metroCalendarSetup"]);
    }

    Metro.Component('calendar', {
        init: function( options, elem ) {

            var now = datetime().align("day");

            this._super(elem, options, CalendarDefaultConfig, {
                today: now,
                show: now,
                current: {
                    year: now.year(),
                    month: now.month(),
                    day: now.day()
                },
                preset: [],
                selected: [],
                exclude: [],
                special: [],
                excludeDay: [],
                events: [],
                min: null,
                max: null,
                locale: null,
                minYear: null,
                maxYear: null,
                id: Utils.elementId("calendar"),
                time: [datetime().hour(), datetime().minute()],
                content: "days",
                yearDistance: 11,
                yearGroupStart: now.year()
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.content = o.startContent;
            this.minYear = this.current.year - this.options.yearsBefore;
            this.maxYear = this.current.year + this.options.yearsAfter;

            element.html("").addClass("calendar " + (o.compact === true ? "compact" : "")).addClass(o.clsCalendar);

            if (Utils.isValue(o.initialTime)) {
                this.time = o.initialTime.split(":");
            }

            if (Utils.isValue(o.initialHours) && Utils.between(o.initialHours, 0, 23, true)) {
                this.time[0] = parseInt(o.initialHours);
            }

            if (Utils.isValue(o.initialMinutes) && Utils.between(o.initialMinutes, 0, 59, true)) {
                this.time[1] = parseInt(o.initialMinutes);
            }

            if (o.dayBorder === true) {
                element.addClass("day-border");
            }

            if (Utils.isValue(o.excludeDay)) {
                this.excludeDay = (""+o.excludeDay).toArray(",", "int");
            }

            if (Utils.isValue(o.preset)) {
                this._dates2array(o.preset, 'selected');
            }

            if (Utils.isValue(o.exclude)) {
                this._dates2array(o.exclude, 'exclude');
            }

            if (Utils.isValue(o.special)) {
                this._dates2array(o.special, 'special');
            }

            if (Utils.isValue(o.events)) {
                this._dates2array(o.events, 'events');
            }

            if (o.buttons !== false) {
                if (Array.isArray(o.buttons) === false) {
                    o.buttons = o.buttons.split(",").map(function(item){
                        return item.trim();
                    });
                }
            }

            this.min = o.minDate ? (o.inputFormat ? Datetime.from(o.minDate, o.inputFormat) : datetime(o.minDate)).align("day") : null;
            this.max = o.maxDate ? (o.inputFormat ? Datetime.from(o.maxDate, o.inputFormat) : datetime(o.maxDate)).align("day") : null;

            if (o.show) {
                this.show = (!o.show ? datetime() : o.inputFormat ? Datetime.from(o.show, o.inputFormat) : datetime(o.show)).align("day");
                this.current = {
                    year: this.show.year(),
                    month: this.show.month(),
                    day: this.show.day()
                }
            }

            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            this._drawCalendar();
            this._createEvents();

            if (o.wide === true) {
                element.addClass("calendar-wide");
            } else {
                if (!Utils.isNull(o.widePoint) && Utils.mediaExist(o.widePoint)) {
                    element.addClass("calendar-wide");
                }
            }


            if (o.ripple === true && Utils.isFunc(element.ripple) !== false) {
                element.ripple({
                    rippleTarget: ".button, .prev-month, .next-month, .prev-year, .next-year, .day",
                    rippleColor: this.options.rippleColor
                });
            }

            this._fireEvent("calendar-create");
        },

        _dates2array: function(val, category){
            var that = this, o = this.options;
            var dates;

            if (Utils.isNull(val)) {
                return ;
            }

            dates = typeof val === 'string' ? val.toArray() : Array.isArray(val) ? val : [];

            $.each(dates, function(){
                var _d, date = this;

                try {
                    _d = (o.inputFormat ? Datetime.from(date, o.inputFormat) : datetime(date)).align('day').format('YYYY-MM-DD');
                } catch (e) {
                    return;
                }

                that[category].push(_d);
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $(window).on(Metro.events.resize, function(){
                if (o.wide !== true) {
                    if (!Utils.isNull(o.widePoint) && Utils.mediaExist(o.widePoint)) {
                        element.addClass("calendar-wide");
                    } else {
                        element.removeClass("calendar-wide");
                    }
                }
            }, {ns: this.id});

            element.on(Metro.events.click, ".prev-year-group, .next-year-group", function(){
                if ($(this).hasClass("prev-year-group")) {
                    that.yearGroupStart -= that.yearDistance;
                } else {
                    that.yearGroupStart += that.yearDistance;
                }
                that._drawContent();
            });

            element.on(Metro.events.click, ".prev-month, .next-month, .prev-year, .next-year", function(){
                var new_date, el = $(this);

                if (el.hasClass("prev-month")) {
                    new_date = datetime(that.current.year, that.current.month - 1, 1);
                    if (new_date.year() < that.minYear) {
                        return ;
                    }
                }
                if (el.hasClass("next-month")) {
                    new_date = datetime(that.current.year, that.current.month + 1, 1);
                    if (new_date.year() > that.maxYear) {
                        return ;
                    }
                }
                if (el.hasClass("prev-year")) {
                    new_date = datetime(that.current.year - 1, that.current.month, 1);
                    if (new_date.year() < that.minYear) {
                        return ;
                    }
                }
                if (el.hasClass("next-year")) {
                    new_date = datetime(that.current.year + 1, that.current.month, 1);
                    if (new_date.year() > that.maxYear) {
                        return ;
                    }
                }

                that.current = {
                    year: new_date.year(),
                    month: new_date.month(),
                    day: new_date.day()
                };

                setTimeout(function(){
                    that._drawContent();
                    if (el.hasClass("prev-month") || el.hasClass("next-month")) {
                        that._fireEvent("month-change", {
                            current: that.current
                        });
                    }
                    if (el.hasClass("prev-year") || el.hasClass("next-year")) {
                        that._fireEvent("year-change", {
                            current: that.current
                        });
                    }
                }, o.ripple ? 300 : 1);
            });

            element.on(Metro.events.click, ".button.today", function(){
                that.toDay();
                that._fireEvent("today", {
                    today: that.today.val(),
                    time: that.time
                });
            });

            element.on(Metro.events.click, ".button.clear", function(){
                var date = datetime();

                that.selected = [];
                that.time = [date.hour(), date.minute()];
                that.yearGroupStart = date.year();
                that._drawContent();
                that._fireEvent("clear");
            });

            element.on(Metro.events.click, ".button.cancel", function(){
                that._drawContent();
                that._fireEvent("cancel");
            });

            element.on(Metro.events.click, ".button.done", function(){
                that._drawContent();
                that._fireEvent("done", {
                    selected: that.selected,
                    time: that.time
                });
            });

            if (o.weekDayClick === true) {
                element.on(Metro.events.click, ".week-days .week-day", function (e) {
                    var day, index, days, ii = [];

                    day = $(this);
                    index = day.index();

                    for (var i = 0; i < 7; i++) {
                        ii.push(index);
                        index += o.showWeekNumber ? 8 : 7;
                    }

                    if (o.multiSelect === true) {
                        days = element.find(".day").filter(function(el){
                            var $el = $(el);
                            return ii.indexOf($el.index()) > -1 && !$el.hasClass("outside disabled excluded");
                        })

                        $.each(days, function () {
                            var $el = $(this);
                            var day = $el.data('day');

                            if (that.selected.indexOf(day) === -1) {
                                that.selected.push(day);
                                $el.addClass("selected").addClass(o.clsSelected);
                            } else {
                                $el.removeClass("selected").removeClass(o.clsSelected);
                                Utils.arrayDelete(that.selected, day);
                            }
                        });
                    }

                    that._fireEvent("week-day-click", {
                        selected: that.selected,
                        day: day[0]
                    });

                    e.preventDefault();
                    e.stopPropagation();
                });
            }

            if (o.weekNumberClick) {
                element.on(Metro.events.click, ".week-number", function (e) {
                    var $el, wn, index, days;

                    $el = $(this);
                    wn = $el.text();
                    index = $el.index();

                    if (wn === "#") {
                        return ;
                    }

                    if (o.multiSelect === true) {
                        days = element.find(".day").filter(function(el){
                            var $el = $(el);
                            var elIndex = $el.index();
                            return Utils.between(elIndex, index, index + 8, false) && !$el.hasClass("outside disabled excluded");
                        })

                        $.each(days, function () {
                            var $el = $(this);
                            var day = $el.data('day');

                            if (that.selected.indexOf(day) === -1) {
                                that.selected.push(day);
                                $el.addClass("selected").addClass(o.clsSelected);
                            } else {
                                $el.removeClass("selected").removeClass(o.clsSelected);
                                Utils.arrayDelete(that.selected, day);
                            }
                        });
                    }

                    that._fireEvent("week-number-click", {
                        selected: that.selected,
                        num: wn,
                        numElement: $el[0]
                    });

                    e.preventDefault();
                    e.stopPropagation();
                });
            }

            element.on(Metro.events.click, ".day", function(e){
                var day = $(this);
                var index, date;

                date = day.data('day');
                index = that.selected.indexOf(date);

                if (day.hasClass("outside")) {
                    date = datetime(date);
                    that.current = {
                        year: date.year(),
                        month: date.month(),
                        day: date.day()
                    };
                    that._drawContent();

                    that._fireEvent("month-change", {
                        current: that.current
                    });

                    return ;
                }

                if (!day.hasClass("disabled")) {

                    if (o.pickerMode === true) {
                        that.selected = [date];
                        that.today = datetime(date);
                        that.current.year = that.today.year();
                        that.current.month = that.today.month();
                        that.current.day = that.today.day();
                        that._drawHeader();
                        that._drawContent();
                    } else {
                        if (index === -1) {
                            if (o.multiSelect === false) {
                                element.find(".day").removeClass("selected").removeClass(o.clsSelected);
                                that.selected = [];
                            }
                            that.selected.push(date);
                            day.addClass("selected").addClass(o.clsSelected);
                        } else {
                            day.removeClass("selected").removeClass(o.clsSelected);
                            Utils.arrayDelete(that.selected, date);
                        }
                    }

                }

                that._fireEvent("day-click", {
                    selected: that.selected,
                    day: day[0],
                    time: that.time
                });

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".curr-month", function(e){
                that.content = "months";
                that._drawContent();

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".month", function(e){
                that.current.month = parseInt($(this).attr("data-month"));
                that.content = "days";
                that._drawContent();

                that._fireEvent("month-change", {
                    current: that.current
                });

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".curr-year", function(e){
                if (that.content === "years") {
                    return ;
                }
                that.content = "years";
                that._drawContent();

                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.click, ".year", function(e){
                that.current.year = parseInt($(this).attr("data-year"));
                that.yearGroupStart = that.current.year;
                that.content = "months";
                that._drawContent();

                that._fireEvent("year-change", {
                    current: that.current
                });

                e.preventDefault();
                e.stopPropagation();
            });
        },

        _drawHeader: function(){
            var element = this.element, o = this.options;
            var header = element.find(".calendar-header");

            if (header.length === 0) {
                header = $("<div>").addClass("calendar-header").addClass(o.clsCalendarHeader).appendTo(element);
            }

            header.html("");

            $("<div>").addClass("header-year").html(this.today.year()).appendTo(header);
            $("<div>").addClass("header-day").html(this.today.format(o.headerFormat, o.locale)).appendTo(header);

            if (o.showHeader === false) {
                header.hide();
            }
        },

        _drawFooter: function(){
            var element = this.element, o = this.options;
            var buttons_locale = this.locale['buttons'];
            var footer = element.find(".calendar-footer");

            if (o.buttons === false) {
                return ;
            }

            if (footer.length === 0) {
                footer = $("<div>").addClass("calendar-footer").addClass(o.clsCalendarFooter).appendTo(element);
            }

            footer.html("");

            $.each(o.buttons, function(){
                var button = $("<button>").attr("type", "button").addClass("button " + this + " " + o['cls'+Cake.capitalize(this)+'Button']).html(buttons_locale[this]).appendTo(footer);
                if (this === 'cancel' || this === 'done') {
                    button.addClass("js-dialog-close");
                }
            });

            if (o.showFooter === false) {
                footer.hide();
            }
        },

        _drawTime: function(){
            var that = this, element = this.element, o = this.options;
            var calendarContent = element.find(".calendar-content");
            var time = $("<div>").addClass("calendar-time").addClass(o.clsCalendarTime).appendTo(calendarContent);
            var inner, hours, minutes, row;
            var h = ""+this.time[0];
            var m = ""+this.time[1];
            var locale = this.locale['calendar']['time'];

            var onChange = function(val){
                var value = parseInt(val);
                if ($(this).attr("data-time-part") === "hours") {
                    that.time[0] = value;
                    that._fireEvent("hours-change", {
                        time: that.time,
                        hours: value
                    });
                } else {
                    that.time[1] = value;
                    that._fireEvent("minutes-change", {
                        time: that.time,
                        minutes: value
                    });
                }

                that._fireEvent("time-change", {
                    time: that.time
                });
            }

            time.append( inner = $("<div>").addClass("calendar-time__inner") );

            inner.append( row = $("<div>").addClass("calendar-time__inner-row") );
            row.append( $("<div>").addClass("calendar-time__inner-cell").append( $("<span>").html(o.labelTimeHours || locale['hours']) ));
            row.append( $("<div>").addClass("calendar-time__inner-cell").append( $("<span>").html(o.labelTimeMinutes || locale['minutes']) ));

            time.append( inner = $("<div>").addClass("calendar-time__inner spinners").addClass(o.clsTime) );
            inner.append( hours = $("<input type='text' data-cls-spinner-input='"+o.clsTimeHours+"' data-time-part='hours' data-buttons-position='right' data-min-value='0' data-max-value='23'>").addClass("hours").addClass(o.compact ? "input-small" : "input-normal") );
            inner.append( minutes = $("<input type='text' data-cls-spinner-input='"+o.clsTimeMinutes+"' data-time-part='minutes' data-buttons-position='right' data-min-value='0' data-max-value='59'>").addClass("minutes").addClass(o.compact ? "input-small" : "input-normal") );

            h = Cake.lpad(h, 2, "0");
            m = Cake.lpad(m, 2, "0");

            hours.val(h);
            minutes.val(m);

            Metro.makePlugin(inner.find("input[type=text]"), "spinner", {
                onChange: onChange,
                clsSpinnerButton: o.clsTimeButton,
                clsSpinnerButtonPlus: o.clsTimeButtonPlus,
                clsSpinnerButtonMinus: o.clsTimeButtonMinus
            });

            if (o.showTime === false) {
                time.hide();
            }
        },

        _drawContentDays: function(){
            var that = this, element = this.element, o = this.options;
            var content = element.find(".calendar-content"), toolbar, weekDays, calendarDays;
            var calendar = datetime(this.current.year, this.current.month, this.current.day).useLocale(o.locale).calendar(o.weekStart);
            var locale = Datetime.getLocale(o.locale);
            var showDay = this.show.format("YYYY-MM-DD");
            var now = datetime();

            if (content.length === 0) {
                content = $("<div>").addClass("calendar-content").addClass(o.clsCalendarContent).appendTo(element);
            }

            if (o.showWeekNumber) {
                content.addClass("-week-numbers");
            }

            content.empty();

            toolbar = $("<div>").addClass("calendar-toolbar").appendTo(content);

            $("<span>").addClass("prev-month").html(o.prevMonthIcon).appendTo(toolbar);
            $("<span>").addClass("curr-month").html(locale['months'][this.current.month]).appendTo(toolbar);
            $("<span>").addClass("next-month").html(o.nextMonthIcon).appendTo(toolbar);

            $("<span>").addClass("prev-year").html(o.prevYearIcon).appendTo(toolbar);
            $("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
            $("<span>").addClass("next-year").html(o.nextYearIcon).appendTo(toolbar);

            weekDays = $("<div>").addClass("week-days").appendTo(content);
            if (o.showWeekNumber) {
                $("<span>").addClass("week-number").html("#").appendTo(weekDays);
            }
            $.each(calendar['weekdays'], function(){
                $("<span>").addClass("week-day").html(this).appendTo(weekDays);
            });

            calendarDays = $("<div>").addClass("days").appendTo(content);

            $.each(calendar['days'], function(i){
                var day = this;
                var date = datetime(day).align('day');
                var outsideDate = date.month() !== that.current.month;

                if (o.showWeekNumber && i % 7 === 0) {
                    $("<span>").addClass("week-number").html(date.weekNumber(o.weekStart)).appendTo(calendarDays);
                }

                var cell = $("<span>").addClass("day").html(date.day()).appendTo(calendarDays);

                cell.data('day', day);

                if (day === showDay) {
                    cell.addClass("showed");
                }

                if (outsideDate) {
                    cell.addClass("outside");
                    if (!o.outside) {
                        cell.empty();
                    }
                }

                if (day === calendar['today']) {
                    cell.addClass("today")
                }

                if (o.showGhost && date.day() === now.day()) {
                    cell.addClass("coincidental");
                }

                if (that.special.length) {
                    if (that.special.indexOf(day) === -1) {
                        cell.addClass("disabled excluded").addClass(o.clsExcluded);
                    } else {
                        cell.addClass(o.clsSpecial);
                    }
                } else {
                    if (that.selected.indexOf(day) > -1) {
                        cell.addClass("selected").addClass(o.clsSelected);
                    }
                    if (that.exclude.indexOf(day) > -1) {
                        cell.addClass("disabled excluded").addClass(o.clsExcluded);
                    }
                    if (that.min && date.older(that.min)) {
                        cell.addClass("disabled excluded").addClass(o.clsExcluded);
                    }
                    if (that.max && date.younger(that.max)) {
                        cell.addClass("disabled excluded").addClass(o.clsExcluded);
                    }
                }

                if (calendar['weekends'].indexOf(day) !== -1) {
                    cell.addClass(o.clsWeekend);
                }

                if (calendar['week'].indexOf(day) !== -1) {
                    cell.addClass(o.clsCurrentWeek);
                }

                if (that.events.length) {
                    var events = $("<div>").addClass("events").addClass(o.clsEvents).appendTo(cell);
                    $.each(that.events, function(){
                        if (this === day) {
                            var event = $("<div>").addClass("event").addClass(o.clsEvent).appendTo(events);
                            if (!o.clsEvent) {
                                event.css({
                                    backgroundColor: Metro.colors.random()
                                })
                            }
                        }
                    })
                }

                if (o.animationContent) {
                    cell.addClass("to-animate");
                }

                that._fireEvent("draw-day", {
                    date: date.val(),
                    day: date.day(),
                    month: date.month(),
                    year: date.year(),
                    cell: cell[0]
                });
            });

            this._drawTime();
            this._animateContent(".day");
        },

        _drawContentMonths: function(){
            var element = this.element, o = this.options;
            var content = element.find(".calendar-content");
            var locale = this.locale['calendar']['months'];
            var toolbar, months, month, yearToday = datetime().year(), monthToday = datetime().month();

            if (content.length === 0) {
                content = $("<div>").addClass("calendar-content").addClass(o.clsCalendarContent).appendTo(element);
            }

            content.clear();

            toolbar = $("<div>").addClass("calendar-toolbar").appendTo(content);

            /**
             * Calendar toolbar
             */

            $("<span>").addClass("prev-year").html(o.prevYearIcon).appendTo(toolbar);
            $("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
            $("<span>").addClass("next-year").html(o.nextYearIcon).appendTo(toolbar);

            content.append( months = $("<div>").addClass("months") );

            for(var i = 12; i < 24; i++) {
                months.append(
                    month = $("<div>")
                        .attr("data-month", i - 12)
                        .addClass("month")
                        .addClass(i - 12 === monthToday && this.current.year === yearToday ? "today" : "")
                        .html(locale[i])
                );

                if (o.animationContent) {
                    month.addClass("to-animate");
                }

                this._fireEvent("draw-month", {
                    month: i - 12,
                    year: this.current.year,
                    cell: month[0]
                });
            }

            this._animateContent(".months .month");
        },

        _drawContentYears: function(){
            var element = this.element, o = this.options;
            var content = element.find(".calendar-content");
            var toolbar, years, year;

            if (content.length === 0) {
                content = $("<div>").addClass("calendar-content").addClass(o.clsCalendarContent).appendTo(element);
            }

            content.clear();

            toolbar = $("<div>").addClass("calendar-toolbar").appendTo(content);

            /**
             * Calendar toolbar
             */

            $("<span>").addClass("prev-year-group").html(o.prevYearIcon).appendTo(toolbar);
            $("<span>").addClass("curr-year").html(this.yearGroupStart + " - " + (this.yearGroupStart + this.yearDistance)).appendTo(toolbar);
            $("<span>").addClass("next-year-group").html(o.nextYearIcon).appendTo(toolbar);

            content.append( years = $("<div>").addClass("years") );

            for(var i = this.yearGroupStart; i <= this.yearGroupStart + this.yearDistance; i++) {
                years.append(
                    year = $("<div>")
                        .attr("data-year", i)
                        .addClass("year")
                        .addClass(i === this.current.year ? "today" : "")
                        .html(i)
                );

                if (o.animationContent) {
                    year.addClass("to-animate");
                }

                if (i < o.minYear || i > o.maxYear) {
                    year.addClass("disabled");
                }

                this._fireEvent("draw-year", {
                    year: i,
                    cell: year[0]
                });
            }

            this._animateContent(".years .year");
        },

        _drawContent: function(){
            switch (this.content) {
                case "years": this._drawContentYears(); break;
                case "months": this._drawContentMonths(); break;
                default: this._drawContentDays();
            }
        },

        _drawCalendar: function(){
            var that = this;
            setTimeout(function(){
                that.element.html("");
                that._drawHeader();
                that._drawContent();
                that._drawFooter();
            }, 0);
        },

        _animateContent: function(target, cls){
            var element = this.element, o = this.options;
            var content = element.find(".calendar-content");

            cls = cls || "to-animate";

            content.find(target).each(function(k){
                var day = $(this);
                setTimeout(function(){
                    day.removeClass(cls);
                }, o.animationSpeed * k);
            });
        },

        getTime: function(asString){
            var h, m;

            asString = asString || false;

            h = Cake.lpad(this.time[0], 2, "0");
            m = Cake.lpad(this.time[1], 2, "0");

            return asString ? h +":"+ m : this.time;
        },

        setTime: function(time){
            if (Array.isArray(time)) {
                this.time = time;
            } else {
                this.time = time.split(":");
            }
            this._drawCalendar();
        },

        getPreset: function(){
            return this.preset;
        },

        getSelected: function(){
            return this.selected;
        },

        getExcluded: function(){
            return this.exclude;
        },

        getToday: function(){
            return this.today;
        },

        getCurrent: function(){
            return this.current;
        },

        clearSelected: function(){
            this.selected = [];
            this._drawContent();
        },

        toDay: function(){
            this.today = datetime().align("day");
            this.current = {
                year: this.today.year(),
                month: this.today.month(),
                day: this.today.day()
            };
            this.time = [datetime().hour(), datetime().minute()];
            this.yearGroupStart = datetime().year();
            this.content = "days";
            this._drawHeader();
            this._drawContent();
        },

        setExclude: function(exclude){
            var element = this.element, o = this.options;
            if (Utils.isNull(exclude) && Utils.isNull(element.attr("data-exclude"))) {
                return ;
            }
            o.exclude = !Utils.isNull(exclude) ? exclude : element.attr("data-exclude");
            this._dates2array(o.exclude, 'exclude');
            this._drawContent();
        },

        setPreset: function(preset){
            var element = this.element, o = this.options;
            if (Utils.isNull(preset) && Utils.isNull(element.attr("data-preset"))) {
                return ;
            }

            o.preset = !Utils.isNull(preset) ? preset : element.attr("data-preset");

            this._dates2array(o.preset, 'selected');
            this._drawContent();
        },

        setSpecial: function(special){
            var element = this.element, o = this.options;
            if (Utils.isNull(special) && Utils.isNull(element.attr("data-special"))) {
                return ;
            }
            o.special = !Utils.isNull(special) ? special : element.attr("data-special");
            this._dates2array(o.exclude, 'special');
            this._drawContent();
        },

        showDate: function(date){
            return this.setShow(date);
        },

        setShow: function(show){
            var element = this.element, o = this.options;
            var attr = element.attr("data-show");

            if (!show && !attr) {
                return ;
            }

            o.show = show ? show : attr;

            if (!o.show) {
                this.show = datetime();
            } else {
                if (typeof o.show === "string" && o.inputFormat) {
                    this.show = Datetime.from(o.show, o.inputFormat);
                } else {
                    this.show = datetime(o.show);
                }
            }

            this.show = this.show.align("day");

            this.current = {
                year: this.show.year(),
                month: this.show.month(),
                day: this.show.day()
            }

            this._drawContent();
        },

        setMinDate: function(date){
            var element = this.element, o = this.options;
            var attr = element.attr("data-min-date");

            if (!date && !attr) {
                return ;
            }

            o.minDate = date ? date : attr;

            this.min = o.minDate ? (o.inputFormat ? Datetime.from(o.minDate, o.inputFormat) : datetime(o.minDate)).align("day") : null;

            this._drawContent();
        },

        setMaxDate: function(date){
            var element = this.element, o = this.options;
            var attr = element.attr("data-max-date");

            o.maxDate = date ? date : attr;

            this.max = o.maxDate ? (o.inputFormat ? Datetime.from(o.maxDate, o.inputFormat) : datetime(o.maxDate)).align("day") : null;

            this._drawContent();
        },

        i18n: function(val){
            var o = this.options;
            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }
            o.locale = val;
            this.locale = Metro.locales[o.locale];
            this._drawCalendar();
        },

        changeAttrLocale: function(){
            var element = this.element;
            this.i18n(element.attr("data-locale"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-exclude': this.setExclude(); break;
                case 'data-preset': this.setPreset(); break;
                case 'data-special': this.setSpecial(); break;
                case 'data-show': this.setShow(); break;
                case 'data-min-date': this.setMinDate(); break;
                case 'data-max-date': this.setMaxDate(); break;
                case 'data-locale': this.changeAttrLocale(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            element.off(Metro.events.click, ".prev-month, .next-month, .prev-year, .next-year");
            element.off(Metro.events.click, ".button.today");
            element.off(Metro.events.click, ".button.clear");
            element.off(Metro.events.click, ".button.cancel");
            element.off(Metro.events.click, ".button.done");
            element.off(Metro.events.click, ".week-days .day");
            element.off(Metro.events.click, ".days-row .day");
            element.off(Metro.events.click, ".curr-month");
            element.off(Metro.events.click, ".calendar-months li");
            element.off(Metro.events.click, ".curr-year");
            element.off(Metro.events.click, ".calendar-years li");
            element.off(Metro.events.click);

            if (o.ripple === true) {
                element.data("ripple").destroy();
            }

            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.calendar .calendar-years').each(function(){
            $(this).removeClass("open");
        });
        $('.calendar .calendar-months').each(function(){
            $(this).removeClass("open");
        });
    });

    Metro.defaults.Calendar = CalendarDefaultConfig;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CalendarPickerDefaultConfig = {
        label: "",
        value: '',
        calendarpickerDeferred: 0,
        nullValue: true,
        useNow: false,
        prepend: "",
        dialogMode: false,
        dialogPoint: 640,
        dialogOverlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        locale: METRO_LOCALE,
        size: "100%",
        format: METRO_DATE_FORMAT,
        inputFormat: null,
        clearButton: false,
        calendarButtonIcon: "<span class='default-icon-calendar'></span>",
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        copyInlineStyles: false,
        clsPicker: "",
        clsInput: "",
        clsPrepend: "",
        clsLabel: "",
        onDayClick: Metro.noop,
        onCalendarPickerCreate: Metro.noop,
        onCalendarShow: Metro.noop,
        onCalendarHide: Metro.noop,
        onChange: Metro.noop,
        onPickerChange: Metro.noop,
        onMonthChange: Metro.noop,
        onYearChange: Metro.noop
    };

    Metro.calendarPickerSetup = function (options) {
        CalendarPickerDefaultConfig = $.extend({}, CalendarPickerDefaultConfig, options);
    };

    if (typeof window["metroCalendarPickerSetup"] !== undefined) {
        Metro.calendarPickerSetup(window["metroCalendarPickerSetup"]);
    }

    Metro.Component('calendar-picker', {
        init: function( options, elem ) {
            this._super(elem, options, $.extend({}, Metro.defaults.Calendar, {
            }, CalendarPickerDefaultConfig), {
                value: null,
                value_date: null,
                calendar: null,
                overlay: null,
                id: Utils.elementId("calendar-picker"),
                time: [datetime().hour(), datetime().minute()]
            });

            return this;
        },

        _create: function(){

            this._createStructure();
            this._createEvents();

            this._fireEvent("calendar-picker-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container = $("<div>").addClass("input " + element[0].className + " calendar-picker");
            var buttons = $("<div>").addClass("button-group");
            var calendarButton, clearButton, cal = $("<div>").addClass("drop-shadow");
            var curr, _curr, initTime, initHours, initMinutes, elementValue, h, m;
            var body = $("body");

            element.attr("type", "text");
            element.attr("autocomplete", "off");
            element.attr("readonly", true);

            if (Utils.isValue(o.initialTime)) {
                this.time = o.initialTime.trim().split(":");
            }

            if (Utils.isValue(o.initialHours)) {
                this.time[0] = parseInt(o.initialHours);
            }

            if (Utils.isValue(o.initialHours)) {
                this.time[1] = parseInt(o.initialMinutes);
            }

            curr = (""+o.value).trim() !== '' ? o.value : element.val().trim();

            if (!Utils.isValue(curr)) {
                if (o.useNow) {
                    this.value = datetime();
                    this.time = [this.value.hour(), this.value.minute()];
                }
            } else {
                _curr = curr.split(" ");
                this.value = (!o.inputFormat ? datetime(_curr[0]) : Datetime.from(_curr[0], o.inputFormat, o.locale)).align("day");
                if (_curr[1]) {
                    this.time = _curr[1].trim().split(":");
                }
            }

            elementValue = !curr && o.nullValue === true ? "" : datetime(that.value).format(o.format, o.locale);

            if (o.showTime && this.time && elementValue) {
                h = Cake.lpad(this.time[0], 2, "0");
                m = Cake.lpad(this.time[1], 2, "0");
                elementValue += " " + h + ":" + m;
            }

            element.val(elementValue);

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);
            cal.appendTo(o.dialogMode ? body : container);

            if (this.time && this.time.length) {
                initHours = this.time[0];
                if (typeof this.time[1] !== "undefined")
                    initMinutes = this.time[1];
            }

            initTime = o.initialTime;

            if (o.initialHours) {
                initHours = o.initialHours;
            }

            if (o.initialHours) {
                initMinutes = o.initialMinutes;
            }

            Metro.makePlugin(cal, "calendar", {
                showTime: o.showTime,
                initialTime: initTime,
                initialHours: initHours,
                initialMinutes: initMinutes,
                clsCalendarTime: o.clsCalendarTime,
                clsTime: o.clsTime,
                clsTimeHours: o.clsTimeHours,
                clsTimeMinutes: o.clsTimeMinutes,
                clsTimeButton: o.clsTimeButton,
                clsTimeButtonPlus: o.clsTimeButtonPlus,
                clsTimeButtonMinus: o.clsTimeButtonMinus,

                wide: o.wide,
                widePoint: o.widePoint,

                format: o.format,
                inputFormat: o.inputFormat,
                pickerMode: true,
                show: o.value,
                locale: o.locale,
                weekStart: o.weekStart,
                outside: o.outside,
                buttons: false,
                headerFormat: o.headerFormat,

                clsCalendar: [o.clsCalendar, "calendar-for-picker", (o.dialogMode ? "dialog-mode":"")].join(" "),
                clsCalendarHeader: o.clsCalendarHeader,
                clsCalendarContent: o.clsCalendarContent,
                clsCalendarFooter: "d-none",
                clsCalendarMonths: o.clsCalendarMonths,
                clsCalendarYears: o.clsCalendarYears,
                clsToday: o.clsToday,
                clsSelected: o.clsSelected,
                clsExcluded: o.clsExcluded,

                ripple: o.ripple,
                rippleColor: o.rippleColor,
                exclude: o.exclude,
                minDate: o.minDate,
                maxDate: o.maxDate,
                yearsBefore: o.yearsBefore,
                yearsAfter: o.yearsAfter,
                special: o.special,
                events: o.events,
                showHeader: false,
                showFooter: false,
                multiSelect: false,
                showWeekNumber: o.showWeekNumber,
                onDayClick: function(sel, day, time, el){
                    var date = datetime(sel[0]).align("day");
                    var elementValue, h, m;

                    that._removeOverlay();

                    that.value = date;
                    that.time = time;

                    elementValue = date.format(o.format, o.locale);

                    if (o.showTime) {
                        h = Cake.lpad(time[0], 2, "0");
                        m = Cake.lpad(time[1], 2, "0");
                        elementValue += " " + h + ":" + m;
                    }

                    element.val(elementValue);
                    element.trigger("change");
                    cal.removeClass("open open-up");
                    cal.hide();

                    that._fireEvent("change", {
                        val: that.value.val(),
                        time: that.time
                    });

                    that._fireEvent("day-click", {
                        sel: sel,
                        day: day,
                        time: time,
                        el: el
                    });

                    that._fireEvent("picker-change", {
                        val: that.value.val(),
                        time: that.time
                    });
                },
                onTimeChange: function(time){
                    var elementValue, h, m;

                    that.time = time;

                    if (!that.value) {
                        that.value = datetime();
                    }
                    elementValue = that.value.format(o.format, o.locale);

                    if (o.showTime) {
                        h = Cake.lpad(time[0], 2, "0");
                        m = Cake.lpad(time[1], 2, "0");
                        elementValue += " " + h + ":" + m;
                    }

                    element.val(elementValue);

                    that._fireEvent("change", {
                        val: that.value.val(),
                        time: that.time
                    });

                    that._fireEvent("picker-change", {
                        val: that.value.val(),
                        time: that.time
                    });
                },
                onMonthChange: o.onMonthChange,
                onYearChange: o.onYearChange
            });

            this.calendar = cal;

            if (o.clearButton === true) {
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            }

            calendarButton = $("<button>").addClass("button").attr("tabindex", -1).attr("type", "button").html(o.calendarButtonIcon);
            calendarButton.appendTo(buttons);

            if (o.prepend !== "") {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl");
            }

            if (String(o.size).indexOf("%") > -1) {
                container.css({
                    width: o.size
                });
            } else {
                container.css({
                    width: parseInt(o.size) + "px"
                });
            }

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                $.each(Utils.getInlineStyles(element), function(key, value){
                    container.css(key, value);
                });
            }

            container.addClass(o.clsPicker);
            element.addClass(o.clsInput);

            if (o.dialogOverlay === true) {
                this.overlay = that._overlay();
            }

            if (o.dialogMode === true) {
                container.addClass("dialog-mode");
            } else {
                if (Utils.media("(max-width: "+o.dialogPoint+"px)")) {
                    container.addClass("dialog-mode");
                    this.calendar.addClass("dialog-mode");
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.parent();
            var clear = container.find(".input-clear-button");
            var cal = this.calendar;
            var cal_plugin = Metro.getPlugin(cal[0], 'calendar');
            var calendar = this.calendar;

            $(window).on(Metro.events.resize, function(){
                if (o.dialogMode !== true) {
                    if (Utils.media("(max-width: " + o.dialogPoint + "px)")) {
                        container.addClass("dialog-mode");
                        calendar.appendTo("body").addClass("dialog-mode");
                    } else {
                        container.removeClass("dialog-mode");
                        calendar.appendTo(container).removeClass("dialog-mode");
                    }
                }
            }, {ns: this.id});

            if (clear.length > 0) clear.on(Metro.events.click, function(e){
                element.val("").trigger('change').blur(); // TODO change blur
                that.value = null;
                e.preventDefault();
                e.stopPropagation();
            });

            container.on(Metro.events.click, "button, input", function(e){

                var value = that.value ? that.value : datetime();
                var presetValue = o.inputFormat ? value.format(o.inputFormat) : value.format("YYYY-MM-DD");

                value.align("day");

                if (cal.hasClass("open") === false && cal.hasClass("open-up") === false) {

                    $(".calendar-picker .calendar").removeClass("open open-up").hide();

                    cal_plugin.setPreset([presetValue]);
                    cal_plugin.setShow(value);

                    if (container.hasClass("dialog-mode")) {
                        that.overlay.appendTo($('body'));
                    }
                    cal.addClass("open");
                    if (!Utils.inViewport(cal[0])) {
                        cal.addClass("open-up");
                    }

                    that._fireEvent("calendar-show", {
                        calendar: cal
                    });

                } else {

                    that._removeOverlay();
                    cal.removeClass("open open-up");

                    that._fireEvent("calendar-hide", {
                        calendar: cal
                    });

                }
                e.preventDefault();
                e.stopPropagation();
            });

            element.on(Metro.events.blur, function(){container.removeClass("focused");});
            element.on(Metro.events.focus, function(){container.addClass("focused");});
            element.on(Metro.events.change, function(){
                Utils.exec(o.onChange, [that.value.val()], element[0]);
            });

            container.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            })
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay for-calendar-picker").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Metro.colors.toRGBA(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        _removeOverlay: function(){
            $('body').find('.overlay.for-calendar-picker').remove();
        },

        clear: function(){
            this.value = datetime();
            this.time = [datetime().hour(), datetime().minute()];
            this.element.val("")
        },

        val: function(v, f){
            var element = this.element, o = this.options;
            var elementValue, h, m;

            if (arguments.length === 0 || Utils.isNull(v))  {
                return {
                    date: this.value.val(),
                    time: this.time
                };
            }

            if (v === "") {
                return this.clear();
            }

            if (f) {
                o.inputFormat = f;
            }

            var _curr = v.split(" ");
            this.value = !o.inputFormat ? datetime(_curr[0]) : Datetime.from(_curr[0], o.inputFormat, o.locale);
            if (_curr[1]) {
                this.time = _curr[1].trim().split(":");
            }

            this.value.align("day");
            Metro.getPlugin(this.calendar, "calendar").setTime(this.time);

            elementValue = this.value.format(o.format);

            if (o.showTime && this.time && elementValue) {
                h = Cake.lpad(this.time[0], 2, "0");
                m = Cake.lpad(this.time[1], 2, "0");
                elementValue += " " + h + ":" + m;
            }

            element.val(elementValue);
            element.trigger("change");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        i18n: function(val){
            var o = this.options;
            var hidden;
            var cal = this.calendar;
            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }

            hidden = cal[0].hidden;
            if (hidden) {
                cal.css({
                    visibility: "hidden",
                    display: "block"
                });
            }
            Metro.getPlugin(cal[0], 'calendar').i18n(val);
            if (hidden) {
                cal.css({
                    visibility: "visible",
                    display: "none"
                });
            }
        },

        getTime: function(asString){
            var h, m;

            asString = asString || false;

            h = Cake.lpad(this.time[0], 2, "0");
            m = Cake.lpad(this.time[1], 2, "0");

            return asString ? h +":"+ m : this.time;
        },

        changeAttribute: function(attributeName, newValue){
            var that = this;
            var cal = Metro.getPlugin(this.calendar[0], "calendar");

            switch (attributeName) {
                case "value": that.val(newValue); break;
                case 'disabled': this.toggleState(); break;
                case 'data-locale': that.i18n(newValue); break;
                case 'data-special': cal.setSpecial(newValue); break;
                case 'data-exclude': cal.setExclude(newValue); break;
                case 'data-min-date': cal.setMinDate(newValue); break;
                case 'data-max-date': cal.setMaxDate(newValue); break;
                case 'data-value': that.val(newValue); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.parent();
            var clear = container.find(".input-clear-button");

            $(window).off(Metro.events.resize, {ns: this.id});
            clear.off(Metro.events.click);
            container.off(Metro.events.click, "button, input");
            element.off(Metro.events.blur);
            element.off(Metro.events.focus);
            element.off(Metro.events.change);

            Metro.getPlugin(this.calendar, "calendar").destroy();

            return element;
        }
    });

    $(document).on(Metro.events.click, ".overlay.for-calendar-picker",function(){
        $(this).remove();
        $(".calendar-for-picker.open").removeClass("open open-up");
    });

    $(document).on(Metro.events.click, function(){
        $(".calendar-picker .calendar").removeClass("open open-up");
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var effects = [
        "slide", "slide-v", "fade", "switch", "zoom", "swirl"
    ];
    var CarouselDefaultConfig = {
        carouselDeferred: 0,
        autoStart: false,
        width: "100%",
        height: "16/9", // 3/4, 21/9
        effect: effects[0],
        effectFunc: "linear",
        direction: "left", //left, right
        duration: METRO_ANIMATION_DURATION,
        period: 5000,
        stopOnMouse: true,

        controls: true,
        bullets: true,
        bulletsStyle: "square", // square, circle, rect, diamond
        bulletsSize: "default", // default, mini, small, large

        controlsOnMouse: false,
        controlsOutside: false,
        bulletsPosition: "default", // default, left, right

        controlPrev: '&#x23F4',
        controlNext: '&#x23F5',
        clsCarousel: "",
        clsSlides: "",
        clsSlide: "",
        clsControls: "",
        clsControlNext: "",
        clsControlPrev: "",
        clsBullets: "",
        clsBullet: "",
        clsBulletOn: "",
        clsThumbOn: "",

        onStop: Metro.noop,
        onStart: Metro.noop,
        onPlay: Metro.noop,
        onSlideClick: Metro.noop,
        onBulletClick: Metro.noop,
        onThumbClick: Metro.noop,
        onMouseEnter: Metro.noop,
        onMouseLeave: Metro.noop,
        onNextClick: Metro.noop,
        onPrevClick: Metro.noop,
        onSlideShow: Metro.noop,
        onSlideHide: Metro.noop,
        onCarouselCreate: Metro.noop
    };

    Metro.carouselSetup = function (options) {
        CarouselDefaultConfig = $.extend({}, CarouselDefaultConfig, options);
    };

    if (typeof window["metroCarouselSetup"] !== undefined) {
        Metro.carouselSetup(window["metroCarouselSetup"]);
    }

    Metro.Component('carousel', {
        init: function( options, elem ) {
            this._super(elem, options, CarouselDefaultConfig, {
                height: 0,
                width: 0,
                slides: [],
                current: null,
                currentIndex: null,
                dir: "left",
                interval: false,
                isAnimate: false,
                id: Utils.elementId("carousel")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var slides = element.find(".slide");
            var slides_container = element.find(".slides");

            this.dir = this.options.direction;

            element.addClass("carousel").addClass(o.clsCarousel);

            element.css({
                maxWidth: o.width
            });


            if (o.controlsOutside === true) {
                element.addClass("controls-outside");
            }

            if (slides_container.length === 0) {
                slides_container = $("<div>").addClass("slides").appendTo(element);
                slides.appendTo(slides_container);
            }

            slides.addClass(o.clsSlides);

            if (slides.length > 0) {

                this._createSlides();
                this._createControls();
                this._createBullets();
                this._createEvents();
                this._resize();

                if (o.controlsOnMouse === true) {
                    element.find("[class*=carousel-switch]").fadeOut(0);
                    element.find(".carousel-bullets").fadeOut(0);
                }

                if (o.autoStart === true) {
                    this._start();
                } else {
                    this._fireEvent("slide-show", {
                        current: this.slides[this.currentIndex][0],
                        prev: undefined
                    });
                }

            }

            this._fireEvent("carousel-create", {
                element: element
            });
        },

        _start: function(){
            var that = this, element = this.element, o = this.options;
            var period = o.period;
            var current = this.slides[this.currentIndex];

            if (current.data("period") !== undefined) {
                period = current.data("period");
            }

            if (this.slides.length <= 1) {
                return ;
            }

            if (this.interval === false) this.interval = setTimeout(function run() {
                var t = o.direction === 'left' ? 'next' : 'prior';
                that._slideTo(t, true);
            }, period);

            this._fireEvent("start", {
                element: element
            });
        },

        _stop: function(){
            clearInterval(this.interval);
            this.interval = false;
        },

        _resize: function(){
            var element = this.element, o = this.options;
            var width = element.outerWidth();
            var height;
            var medias = [];

            if (["16/9", "21/9", "4/3"].indexOf(o.height) > -1) {
                height = Utils.aspectRatioH(width, o.height);
            } else {
                if (String(o.height).indexOf("@") > -1) {
                    medias = o.height.substr(1).toArray("|");
                    $.each(medias, function(){
                        var media = this.toArray(",");
                        if (window.matchMedia(media[0]).matches) {
                            if (["16/9", "21/9", "4/3"].indexOf(media[1]) > -1) {
                                height = Utils.aspectRatioH(width, media[1]);
                            } else {
                                height = parseInt(media[1]);
                            }
                        }
                    });
                } else {
                    height = parseInt(o.height);
                }
            }

            element.css({
                height: height
            });
        },

        _createSlides: function(){
            var that = this, element = this.element, o = this.options;
            var slides = element.find(".slide");

            $.each(slides, function(i){
                var slide = $(this);
                if (slide.data("cover") !== undefined) {
                    slide.css({
                        backgroundImage: "url("+slide.data('cover')+")"
                    });
                }

                if (i !== 0) {
                    switch (o.effect) {
                        case "switch":
                        case "slide":
                            slide.css("left", "100%");
                            break;
                        case "slide-v":
                            slide.css("top", "100%");
                            break;
                        case "fade":
                        case "zoom":
                        case "swirl":
                            slide.css("opacity", "0");
                            break;
                    }
                } else {
                    slide.addClass("active-slide");
                }

                slide.addClass(o.clsSlide);

                that.slides.push(slide);
            });

            this.currentIndex = 0;
            this.current = this.slides[this.currentIndex];
        },

        _createControls: function(){
            var element = this.element, o = this.options;
            var next, prev;

            if (o.controls === false) {
                return ;
            }

            next = $('<span/>').addClass('carousel-switch-next').addClass(o.clsControls).addClass(o.clsControlNext).html(">");
            prev = $('<span/>').addClass('carousel-switch-prev').addClass(o.clsControls).addClass(o.clsControlPrev).html("<");

            if (o.controlNext) {
                next.html(o.controlNext);
            }

            if (o.controlPrev) {
                prev.html(o.controlPrev);
            }

            next.appendTo(element);
            prev.appendTo(element);
        },

        _createBullets: function(){
            var element = this.element, o = this.options;
            var bullets, i;

            if (o.bullets === false) {
                return ;
            }

            bullets = $('<div>').addClass("carousel-bullets").addClass(o.bulletsSize+"-size").addClass("bullet-style-"+o.bulletsStyle).addClass(o.clsBullets);
            if (o.bulletsPosition === 'default' || o.bulletsPosition === 'center') {
                bullets.addClass("flex-justify-center");
            } else if (o.bulletsPosition === 'left') {
                bullets.addClass("flex-justify-start");
            } else {
                bullets.addClass("flex-justify-end");
            }

            for (i = 0; i < this.slides.length; i++) {
                var bullet = $('<span>').addClass("carousel-bullet").addClass(o.clsBullet).data("slide", i);
                if (i === 0) {
                    bullet.addClass('bullet-on').addClass(o.clsBulletOn);
                }
                bullet.appendTo(bullets);
            }

            bullets.appendTo(element);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".carousel-bullet", function(){
                var bullet = $(this);
                if (that.isAnimate === false) {
                    that._slideToSlide(bullet.data('slide'));
                    that._fireEvent("bullet-click", {
                        bullet: bullet
                    });
                }
            });

            element.on(Metro.events.click, ".carousel-switch-next", function(){
                if (that.isAnimate === false) {
                    that._slideTo("next", false);
                    that._fireEvent("next-click", {
                        button: this
                    });
                }
            });

            element.on(Metro.events.click, ".carousel-switch-prev", function(){
                if (that.isAnimate === false) {
                    that._slideTo("prev", false);
                    that._fireEvent("prev-click", {
                        button: this
                    });
                }
            });

            if (o.stopOnMouse === true && o.autoStart === true) {
                element.on(Metro.events.enter, function () {
                    that._stop();
                    that._fireEvent("mouse-enter", {
                        element: element
                    }, false, true);
                });
                element.on(Metro.events.leave, function () {
                    that._start();
                    that._fireEvent("mouse-leave", {
                        element: element
                    }, false, true);
                });
            }

            if (o.controlsOnMouse === true) {
                element.on(Metro.events.enter, function () {
                    element.find("[class*=carousel-switch]").fadeIn();
                    element.find(".carousel-bullets").fadeIn();
                });
                element.on(Metro.events.leave, function () {
                    element.find("[class*=carousel-switch]").fadeOut();
                    element.find(".carousel-bullets").fadeOut();
                });
            }

            element.on(Metro.events.click, ".slide", function(){
                var slide = $(this);
                that._fireEvent("slide-click", {
                    slide: slide
                });
            });

            $(window).on(Metro.events.resize, function(){
                that._resize();
            }, {ns: this.id});
        },

        _slideToSlide: function(index){
            var element = this.element, o = this.options;
            var current, next, to;

            if (this.slides[index] === undefined) {
                return ;
            }

            if (this.currentIndex === index) {
                return ;
            }

            to = index > this.currentIndex ? "next" : "prev";
            current = this.slides[this.currentIndex];
            next = this.slides[index];

            this.currentIndex = index;

            this._effect(current, next, o.effect, to);

            element.find(".carousel-bullet").removeClass("bullet-on").removeClass(o.clsBulletOn);
            element.find(".carousel-bullet:nth-child("+(this.currentIndex+1)+")").addClass("bullet-on").addClass(o.clsBulletOn);
        },

        _slideTo: function(to, interval){
            var element = this.element, o = this.options;
            var current, next;

            if (to === undefined) {
                to = "next";
            }

            current = this.slides[this.currentIndex];

            if (to === "next") {
                this.currentIndex++;
                if (this.currentIndex >= this.slides.length) {
                    this.currentIndex = 0;
                }
            } else {
                this.currentIndex--;
                if (this.currentIndex < 0) {
                    this.currentIndex = this.slides.length - 1;
                }
            }

            next = this.slides[this.currentIndex];

            this._effect(current, next, o.effect, to, interval);

            element.find(".carousel-bullet").removeClass("bullet-on").removeClass(o.clsBulletOn);
            element.find(".carousel-bullet:nth-child("+(this.currentIndex+1)+")").addClass("bullet-on").addClass(o.clsBulletOn);
        },

        _effect: function(current, next, effect, to, interval){
            var that = this, o = this.options;
            var duration = o.duration;
            var func, effectFunc = o.effectFunc;
            var period = o.period;

            var run = function(f, c, n, o){
                Metro.animations[f](c, n, o);
            }

            if (next.data('duration') !== undefined) {
                duration = next.data('duration');
            }

            if (next.data('effectFunc') !== undefined) {
                effectFunc = next.data('effectFunc');
            }

            if (effect === 'switch') {
                duration = 0;
            }

            current.stop(true);
            next.stop(true);
            this.isAnimate = true;

            setTimeout(function(){that.isAnimate = false;}, duration + 100);

            if (effect === 'slide') {
                func = to === 'next' ? 'slideLeft': 'slideRight';
            } else
            if (effect === 'slide-v') {
                func = to === 'next' ? 'slideUp': 'slideDown';
            } else {
                func = effect;
            }

            if (!effects.includes(effect)) {
                func = "switch";
            }

            run(func, current, next, {duration: duration, ease: effectFunc});

            current.removeClass("active-slide");
            next.addClass("active-slide");

            setTimeout(function(){
                that._fireEvent("slide-show", {
                    current: next[0],
                    prev: current[0]
                })
            }, duration);

            setTimeout(function(){
                that._fireEvent("slide-hide", {
                    current: current[0],
                    next: next[0]
                })
            }, duration);

            if (interval === true) {

                if (next.data('period') !== undefined) {
                    period = next.data('period');
                }

                this.interval = setTimeout(function run() {
                    var t = o.direction === 'left' ? 'next' : 'prior';
                    that._slideTo(t, true);
                }, period);
            }
        },

        toSlide: function(index){
            this._slideToSlide(index);
        },

        next: function(){
            this._slideTo("next");
        },

        prev: function(){
            this._slideTo("prev");
        },

        stop: function () {
            clearInterval(this.interval);
            this._fireEvent("stop");
        },

        play: function(){
            this._start();
            this._fireEvent("play");
        },

        setEffect: function(effect){
            var element = this.element, o = this.options;
            var slides = element.find(".slide");

            if (!effects.includes(effect)) return ;

            o.effect = effect;

            slides.removeStyleProperty("transform").css({
                top: 0,
                left: 0
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName, newValue){
            if (attributeName === 'data-effect') {
                this.setEffect(newValue);
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            element.off(Metro.events.click, ".carousel-bullet");
            element.off(Metro.events.click, ".carousel-switch-next");
            element.off(Metro.events.click, ".carousel-switch-prev");

            if (o.stopOnMouse === true && o.autoStart === true) {
                element.off(Metro.events.enter);
                element.off(Metro.events.leave);
            }

            if (o.controlsOnMouse === true) {
                element.off(Metro.events.enter);
                element.off(Metro.events.leave);
            }

            element.off(Metro.events.click, ".slide");
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CharmsDefaultConfig = {
        charmsDeferred: 0,
        position: "right",
        opacity: 1,
        clsCharms: "",
        onCharmCreate: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onToggle: Metro.noop
    };

    Metro.charmsSetup = function (options) {
        CharmsDefaultConfig = $.extend({}, CharmsDefaultConfig, options);
    };

    if (typeof window["metroCharmsSetup"] !== undefined) {
        Metro.charmsSetup(window["metroCharmsSetup"]);
    }

    Metro.Component('charms', {
        init: function( options, elem ) {
            this._super(elem, options, CharmsDefaultConfig, {
                origin: {
                    background: ""
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("charm-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element
                .addClass("charms")
                .addClass(o.position + "-side")
                .addClass(o.clsCharms);

            this.origin.background = element.css("background-color");

            element.css({
                backgroundColor: Metro.colors.toRGBA(Utils.getStyleOne(element, "background-color"), o.opacity)
            });
        },

        _createEvents: function(){
        },

        open: function(){
            var element = this.element;

            element.addClass("open");

            this._fireEvent("open");
        },

        close: function(){
            var element = this.element;

            element.removeClass("open");

            this._fireEvent("close");
        },

        toggle: function(){
            var element = this.element;

            if (element.hasClass("open") === true) {
                this.close();
            } else {
                this.open();
            }

            this._fireEvent("toggle");
        },

        opacity: function(v){
            var element = this.element, o = this.options;

            if (v === undefined) {
                return o.opacity;
            }

            var opacity = Math.abs(parseFloat(v));
            if (opacity < 0 || opacity > 1) {
                return ;
            }
            o.opacity = opacity;

            element.css({
                backgroundColor: Metro.colors.toRGBA(Utils.getStyleOne(element, "background-color"), opacity)
            });
        },

        changeOpacity: function(){
            var element = this.element;
            this.opacity(element.attr("data-opacity"));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-opacity": this.changeOpacity(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['charms'] = {
        check: function(el){
            if (Utils.isMetroObject(el, "charms") === false) {
                console.warn("Element is not a charms component");
                return false;
            }
            return true;
        },

        isOpen: function(el){
            if (this.check(el) === false) return ;
            return $(el).hasClass("open");
        },

        open: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").open();
        },

        close: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").close();
        },

        toggle: function(el){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").toggle();
        },

        closeAll: function(){
            $('[data-role*=charms]').each(function() {
                Metro.getPlugin(this, 'charms').close();
            });
        },

        opacity: function(el, opacity){
            if (this.check(el) === false) return ;
            Metro.getPlugin(el, "charms").opacity(opacity);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var defaultAvatar = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gOTAK/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/9sAQwEDBAQFBAUJBQUJFA0LDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU/8AAEQgAUABQAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+t+KKPxo/GgA70Yo/Gj8aADFH4VesdC1HUl3WtjcXCf344yV/PGKW+0HUtNXddWNzbp/fkjIX88YoAofhR+FH40fjQAfhR+FH40fjQAUUUUAFepeAPh5D9li1LVYhK8g3Q27j5VXszDuT6f5HA+FtOXVvEWn2rjMcko3j1UckfkDX0MBgYHAoARVCKFUBVHAA6ClZQwKkZBGCDS0UAec+Pvh3BJay6lpUQimjBeW3QYVx3Kjsfbv/PyqvpuvnvxfpqaT4l1C1QbY0lJUDsrfMB+RoAyKKKKACiiigDa8GXq6f4p02eQgIJQpJ7Bvlz+tfQP4V8yDg17P4A8cw65ZxWV5IE1KMbfmP+uA7j39R+NAHaUfhSUUAL+FeA+OL1NQ8WalNGQU83YCO+0Bf6V6b498cQ6BZyWlrIJNSkXaApz5QP8AEff0FeKk5OTyTQAUUUUAH40fjRU1naTX93DbQIXmlYIijuTQBc0Dw/eeI74W1mm49XkbhUHqTXsHhz4eaXoCpI8YvbscmaYZAP8Asr0H8/etHwv4cg8M6XHaxANIfmllxy7dz9PStigA/Gk/GlooA5bxJ8PdL19XkWMWd43PnwjGT/tL0P8AP3rx/X/D954cvjbXibT1SReVceoNfRFZHijw5B4m0uS1lAWQfNFLjlG7H6etAHz5+NH41NeWk1hdzW06FJonKMp7EGoaACvQfhBowudTudRkXK2y7I8j+Nup/Afzrz6vafhRaCDwmkgHM8zufwO3/wBloA7Kiij8KACkpaSgBaSj8KKAPJvi/owttTttRjXC3K7JMf3l6H8R/KvPq9p+K1qJ/CbyEcwTI4P1O3/2avFqAP/Z";
    var ChatDefaultConfig = {
        chatDeferred: 0,
        inputTimeFormat: null,
        timeFormat: "D MMM hh:mm A",
        name: "John Doe",
        avatar: defaultAvatar,
        welcome: null,
        welcomeAvatar: defaultAvatar,
        title: null,
        width: "100%",
        height: "auto",
        messages: null,
        sendButtonTitle: "Send",
        readonly: false,
        locale: METRO_LOCALE,

        clsChat: "",
        clsName: "",
        clsTime: "",
        clsInput: "",
        clsSendButton: "",
        clsMessageLeft: "default",
        clsMessageRight: "default",

        onMessage: Metro.noop,
        onSend: Metro.noop,
        onSendButtonClick: Metro.noop,
        onChatCreate: Metro.noop
    };

    Metro.chatSetup = function (options) {
        ChatDefaultConfig = $.extend({}, ChatDefaultConfig, options);
    };

    if (typeof window["metroChatSetup"] !== undefined) {
        Metro.chatSetup(window["metroChatSetup"]);
    }

    Metro.Component('chat', {
        init: function( options, elem ) {
            this._super(elem, options, ChatDefaultConfig, {
                input: null,
                classes: "primary secondary success alert warning yellow info dark light".split(" "),
                lastMessage: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("chat-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var messages, messageInput, input;
            var customButtons = [
                {
                    html: o.sendButtonTitle,
                    cls: o.clsSendButton+" js-chat-send-button",
                    onclick: o.onSendButtonClick
                }
            ];

            element.addClass("chat").addClass(o.clsChat);

            element.css({
                width: o.width,
                height: o.height
            });

            if (Utils.isValue(o.title)) {
                $("<div>").addClass("title").html(o.title).appendTo(element);
            }

            messages = $("<div>").addClass("messages");
            messages.appendTo(element);
            messageInput = $("<div>").addClass("message-input").appendTo(element);
            input = $("<input type='text'>");
            input.appendTo(messageInput);
            input.input({
                customButtons: customButtons,
                clsInput: o.clsInput
            });

            if (o.welcome) {
                this.add({
                    text: o.welcome,
                    time: datetime(),
                    position: "left",
                    name: "Chat Bot",
                    avatar: o.welcomeAvatar
                })
            }

            if (Utils.isValue(o.messages) && typeof o.messages === "string") {
                o.messages = Utils.isObject(o.messages);
            }

            if (!Utils.isNull(o.messages) && typeof o.messages === "object" && Utils.objectLength(o.messages) > 0) {
                $.each(o.messages, function(){
                    that.add(this);
                });
            }

            element.find(".message-input")[o.readonly ? 'addClass':'removeClass']("disabled");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var sendButton = element.find(".js-chat-send-button");
            var input = element.find("input[type=text]");

            var send = function(){
                var msg = ""+input.val(), m;
                if (msg.trim() === "") {return false;}
                m = {
                    id: Utils.elementId("chat-message"),
                    name: o.name,
                    avatar: o.avatar,
                    text: msg,
                    position: "right",
                    time: datetime()
                };
                that.add(m);
                input.val("");
                that._fireEvent("send", {
                    msg: m
                });
                input.focus();
            };

            sendButton.on(Metro.events.click, function () {
                send();
            });

            input.on(Metro.events.keyup, function(e){
                if (e.keyCode === Metro.keyCode.ENTER) {
                    send();
                }
            })
        },

        add: function(msg){
            var that = this, element = this.element, o = this.options;
            var message, sender, time, item, avatar, text;
            var messages = element.find(".messages");
            var messageDate;

            messageDate = o.inputTimeFormat ? Datetime.from(msg.time, o.inputTimeFormat, o.locale) : datetime(msg.time);

            message = $("<div>").addClass("message").addClass(msg.position).appendTo(messages);
            item = $("<div>").addClass("message-item").appendTo(message);
            avatar = $("<img>").attr("src", msg.avatar).addClass("message-avatar").appendTo(item);
            text = $("<div>").addClass("message-text").append($("<div>").addClass("message-text-inner").html(Cake.escapeHtml(msg.text))).appendTo(item);
            time = $("<div>").addClass("message-time").addClass(o.clsTime).text(messageDate.format(o.timeFormat)).appendTo(text);
            sender = $("<div>").addClass("message-sender").addClass(o.clsName).text(msg.name).appendTo(text);

            if (Utils.isValue(msg.id)) {
                message.attr("id", msg.id);
            }

            if (msg.position === 'left' && Utils.isValue(o.clsMessageLeft)) {
                text.addClass(o.clsMessageLeft);
            }
            if (msg.position === 'right' && Utils.isValue(o.clsMessageRight)) {
                text.addClass(o.clsMessageRight);
            }

            if (this.lastMessage && this.lastMessage.position === msg.position) {
                text.addClass("--next");
                avatar.visible(false);
                sender.hide();
            }

            that._fireEvent("message", {
                msg: msg,
                el: {
                    message: message,
                    sender: sender,
                    time: time,
                    item: item,
                    avatar: avatar,
                    text: text
                }
            });

            messages.animate({
                draw: {
                    scrollTop: messages[0].scrollHeight
                },
                dur: 1000
            });

            this.lastMessage = msg;

            return this;
        },

        addMessages: function(messages){
            var that = this;

            if (Utils.isValue(messages) && typeof messages === "string") {
                messages = Utils.isObject(messages);
            }

            if (typeof messages === "object" && Utils.objectLength(messages) > 0) {
                $.each(messages, function(){
                    that.add(this);
                });
            }

            return this;
        },

        delMessage: function(id){
            var element = this.element;

            element.find(".messages").find("#"+id).remove();

            return this;
        },

        updMessage: function(msg){
            var element = this.element;
            var message = element.find(".messages").find("#"+msg.id);

            if (message.length === 0) return this;

            message.find(".message-text").html(msg.text);
            message.find(".message-time").html(msg.time);

            return this;
        },

        clear: function(){
            var element = this.element;
            var messages = element.find(".messages");
            messages.html("");
            this.lastMessage = null;
        },

        toggleReadonly: function(readonly){
            var element = this.element, o = this.options;
            o.readonly = typeof readonly === "undefined" ? !o.readonly : readonly;
            element.find(".message-input")[o.readonly ? 'addClass':'removeClass']("disabled");
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-readonly": this.toggleReadonly(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var sendButton = element.find(".js-chat-send-button");
            var input = element.find("input[type=text]");

            sendButton.off(Metro.events.click);
            input.off(Metro.events.keyup);

            return element;
        }
    });

    Metro.defaults.Chat = ChatDefaultConfig;
    Metro.defaults.ChatAvatar = defaultAvatar;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CheckboxDefaultConfig = {
        checkboxDeferred: 0,
        transition: true,
        style: 1,
        caption: "",
        captionPosition: "right",
        indeterminate: false,
        clsCheckbox: "",
        clsCheck: "",
        clsCaption: "",
        onCheckboxCreate: Metro.noop
    };

    Metro.checkboxSetup = function (options) {
        CheckboxDefaultConfig = $.extend({}, CheckboxDefaultConfig, options);
    };

    if (typeof window["metroCheckboxSetup"] !== undefined) {
        Metro.checkboxSetup(window["metroCheckboxSetup"]);
    }

    Metro.Component('checkbox', {
        init: function( options, elem ) {
            this._super(elem, options, CheckboxDefaultConfig, {
                origin: {
                    className: ""
                }
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();
            this._fireEvent("checkbox-create");
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var checkbox;
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            checkbox = element
                .wrap("<label>")
                .addClass("checkbox " + element[0].className)
                .addClass(o.style === 2 ? "style2" : "");

            check.appendTo(checkbox);
            caption.appendTo(checkbox);

            if (o.transition === true) {
                checkbox.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                checkbox.addClass("caption-left");
            }

            this.origin.className = element[0].className;
            element[0].className = '';

            checkbox.addClass(o.clsCheckbox);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (o.indeterminate) {
                element[0].indeterminate = true;
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var element = this.element, check = element.siblings(".check");

            element.on("focus", function(){
                check.addClass("focused");
            });

            element.on("blur", function(){
                check.removeClass("focused");
            });
        },

        indeterminate: function(v){
            var element = this.element;

            v = Utils.isNull(v) ? true : Utils.bool(v);

            element[0].indeterminate = v;
            element.attr("data-indeterminate", v);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            this.indeterminate(false);

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                if (v === -1) {
                    this.indeterminate(true);
                } else {
                    element.prop("checked", v === 1);
                }
            }
            return this;
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var parent = element.parent();

            var changeStyle = function(){
                var new_style = parseInt(element.attr("data-style"));

                if (!Utils.isInt(new_style)) return;

                o.style = new_style;
                parent.removeClass("style1 style2").addClass("style"+new_style);
            };

            var indeterminateState = function(){
                element[0].indeterminate = JSON.parse(element.attr("data-indeterminate")) === true;
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-indeterminate': indeterminateState(); break;
                case 'data-style': changeStyle(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            element.off("focus");
            element.off("blur");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ClockDefaultConfig = {
        clockDeferred: 0,
        showTime: true,
        showDate: true,
        timeFormat: '24',
        dateFormat: 'american',
        divider: "&nbsp;&nbsp;",
        leadingZero: true,
        dateDivider: '-',
        timeDivider: ":",
        onTick: Metro.noop,
        onSecond: Metro.noop,
        onClockCreate: Metro.noop
    };

    Metro.clockSetup = function (options) {
        ClockDefaultConfig = $.extend({}, ClockDefaultConfig, options);
    };

    if (typeof window["metroClockSetup"] !== undefined) {
        Metro.clockSetup(window["metroClockSetup"]);
    }

    Metro.Component('clock', {
        init: function( options, elem ) {
            this._super(elem, options, ClockDefaultConfig, {
                _clockInterval: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._fireEvent('clock-create', {
                element: element
            });

            this._tick();

            this._clockInterval = setInterval(function(){
                that._tick();
            }, 500);
            this._secondInterval = setInterval(function(){
                that._second();
            }, 1000);
        },

        _addLeadingZero: function(i){
            if (i<10){i="0" + i;}
            return i;
        },

        _second: function(){
            var timestamp = new Date();

            this._fireEvent('second', {
                timestamp: timestamp
            })
        },

        _tick: function(){
            var element = this.element, o = this.options;
            var timestamp = new Date();
            var result = "";
            var h = timestamp.getHours(),
                i = timestamp.getMinutes(),
                s = timestamp.getSeconds(),
                d = timestamp.getDate(),
                m = timestamp.getMonth() + 1,
                y = timestamp.getFullYear(),
                a = '';

            if (parseInt(o.timeFormat) === 12) {
                a = " AM";
                if (h > 11) { a = " PM"; }
                if (h > 12) { h = h - 12; }
                if (h === 0) { h = 12; }
            }

            i = this._addLeadingZero(i);
            s = this._addLeadingZero(s);

            if (o.leadingZero) {
                h = this._addLeadingZero(h);
                m = this._addLeadingZero(m);
                d = this._addLeadingZero(d);
            }

            if (o.showDate) {
                if (o.dateFormat === 'american') {
                    result += "<span class='date-month'>" + m + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-day'>" + d + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-year'>" + y + "</span>";
                } else {
                    result += "<span class='date-day'>" + d + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-month'>" + m + "</span>";
                    result += "<span class='date-divider'>" + o.dateDivider + "</span>";
                    result += "<span class='date-year'>" + y + "</span>";
                }
                result += o.divider;
            }

            if (o.showTime) {
                result += "<span class='clock-hour'>" + h + "</span>";
                result += "<span class='clock-divider'>" + o.timeDivider + "</span>";
                result += "<span class='clock-minute'>" + i + "</span>";
                result += "<span class='clock-divider'>" + o.timeDivider + "</span>";
                result += "<span class='clock-second'>" + s + "</span>";
                result += "<span class='clock-suffix'>" + a + "</span>";
            }

            element.html(result);

            this._fireEvent('tick', {
                timestamp: timestamp
            })
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            clearInterval(this._clockInterval);
            this._clockInterval = null;
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var CollapseDefaultConfig = {
        collapseDeferred: 0,
        collapsed: false,
        toggleElement: false,
        duration: 100,
        onExpand: Metro.noop,
        onCollapse: Metro.noop,
        onCollapseCreate: Metro.noop
    };

    Metro.collapseSetup = function (options) {
        CollapseDefaultConfig = $.extend({}, CollapseDefaultConfig, options);
    };

    if (typeof window["metroCollapseSetup"] !== undefined) {
        Metro.collapseSetup(window["metroCollapseSetup"]);
    }

    Metro.Component('collapse', {
        init: function( options, elem ) {
            this._super(elem, options, CollapseDefaultConfig, {
                toggle: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var toggle;

            toggle = o.toggleElement !== false ? $(o.toggleElement) : element.siblings('.collapse-toggle').length > 0 ? element.siblings('.collapse-toggle') : element.siblings('a:nth-child(1)');

            if (o.collapsed === true || element.attr("collapsed") === true) {
                element.hide(0);
            }

            toggle.on(Metro.events.click, function(e){
                if (element.css('display') === 'block' && !element.hasClass('keep-open')) {
                    that._close(element);
                } else {
                    that._open(element);
                }

                if (["INPUT"].indexOf(e.target.tagName) === -1) {
                    e.preventDefault();
                }
                e.stopPropagation();
            });

            this.toggle = toggle;

            this._fireEvent("collapse-create", {
                element: element
            });
        },

        _close: function(el, immediate){
            var elem = $(el);
            var dropdown  = Metro.getPlugin(elem[0], "collapse");
            var options = dropdown.options;
            var func = immediate ? 'show' : 'slideUp';
            var dur = immediate ? 0 : options.duration;

            this.toggle.removeClass("active-toggle");

            elem[func](dur, function(){
                el.trigger("onCollapse", null, el);
                el.data("collapsed", true);
                el.addClass("collapsed");

                dropdown._fireEvent("collapse");
            });
        },

        _open: function(el, immediate){
            var elem = $(el);
            var dropdown  = Metro.getPlugin(elem[0], "collapse");
            var options = dropdown.options;
            var func = immediate ? 'show' : 'slideDown';
            var dur = immediate ? 0 : options.duration;

            this.toggle.addClass("active-toggle");

            elem[func](dur, function(){
                el.trigger("onExpand", null, el);
                el.data("collapsed", false);
                el.removeClass("collapsed");

                dropdown._fireEvent("expand");
            });
        },

        collapse: function(immediate){
            this._close(this.element, immediate);
        },

        expand: function(immediate){
            this._open(this.element, immediate);
        },

        close: function(immediate){
            this._close(this.element, immediate);
        },

        open: function(immediate){
            this._open(this.element, immediate);
        },

        isCollapsed: function(){
            return this.element.data("collapsed");
        },

        toggleState: function(){
            var element = this.element;
            if (element.attr("collapsed") === true || element.data("collapsed") === true) {
                this.collapse();
            } else {
                this.expand();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "collapsed":
                case "data-collapsed": this.toggleState(); break;
            }
        },

        destroy: function(){
            this.toggle.off(Metro.events.click);
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ColorPickerDefaultConfig = {
        duration: 100,
        prepend: "",
        append: "",
        clearButton: false,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        pickerButtonIcon: "<span class='default-icon-equalizer'></span>",
        defaultValue: "rgba(0, 0, 0, 0)",
        copyInlineStyles: false,
        clsPickerButton: "",
        clsClearButton: "",
        onColorSelected: Metro.noop,
        onColorPickerCreate: Metro.noop
    };

    Metro.colorPickerSetup = function (options) {
        ColorPickerDefaultConfig = $.extend({}, ColorPickerDefaultConfig, options);
    };

    if (typeof window["metroColorPickerSetup"] !== undefined) {
        Metro.colorPickerSetup(window["metroColorPickerSetup"]);
    }

    Metro.Component('color-picker', {
        init: function( options, elem ) {
            this._super(elem, options, $.extend({}, Metro.defaults.ColorSelector, {
                showUserColors: false,
                showValues: ""
            }, ColorPickerDefaultConfig), {
                value: null,
                picker: null,
                colorSelector: null,
                colorSelectorBox: null,
                colorExample: null,
                inputInterval: null,
                isOpen: false
            });
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var current = element.val();

            if (!Metro.pluginExists("color-selector")) {
                throw new Error("Color selector component required!");
            }

            this.value = Metro.colors.isColor(current) ? current : Metro.colors.isColor(o.defaultValue) ? o.defaultValue : "rgba(0,0,0,0)";

            this._createStructure();
            this._createEvents();

            this._fireEvent('color-picker-create');
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var picker = element.wrap( $("<div>").addClass("color-picker").addClass(element[0].className) );
            var buttons, colorExample, colorSelector, colorSelectorBox;

            colorExample = $("<div>").addClass("color-example-box").insertBefore(element);

            buttons = $("<div>").addClass("buttons").appendTo(picker);

            buttons.append(
                $("<button>")
                    .addClass("button color-picker-button")
                    .addClass(o.clsPickerButton)
                    .attr("tabindex", -1)
                    .attr("type", "button")
                    .html(o.pickerButtonIcon)
            );

            if (o.clearButton === true && !element[0].readOnly) {
                buttons.append(
                    $("<button>")
                        .addClass("button input-clear-button")
                        .addClass(o.clsClearButton)
                        .attr("tabindex", -1)
                        .attr("type", "button")
                        .html(o.clearButtonIcon)
                );
            }

            if (Utils.isValue(o.prepend)) {
                picker.prepend($("<div>").addClass("prepend").addClass(o.clsPrepend).html(o.prepend));
            }

            if (Utils.isValue(o.append)) {
                picker.append($("<div>").html(o.append).addClass("append").addClass(o.clsAppend));
            }

            colorSelectorBox = $("<div>").addClass("color-selector-box").appendTo(picker);
            colorSelector = $("<div>").appendTo(colorSelectorBox);

            this.picker = picker;
            this.colorExample = colorExample;
            this.colorSelector = colorSelector;
            this.colorSelectorBox = colorSelectorBox;

            Metro.makePlugin(colorSelector, 'color-selector', {
                defaultSwatches: o.defaultSwatches,
                userColors: o.userColors,
                returnValueType: o.returnValueType,
                returnAsString: o.returnAsString,
                showValues: o.showValues,
                showAsString: o.showAsString,
                showUserColors: o.showUserColors,
                target: o.target,
                controller: element,
                locale: o.locale,
                addUserColorTitle: o.addUserColorTitle,
                userColorsTitle: o.userColorsTitle,
                hslMode: o.hslMode,
                showAlphaChannel: o.showAlphaChannel,
                inputThreshold: o.inputThreshold,
                initColor: this.value,
                readonlyInput: o.readonlyInput,
                clsSelector: o.clsSelector,
                clsSwatches: o.clsSwatches,
                clsSwatch: o.clsSwatch,
                clsValue: o.clsValue,
                clsLabel: o.clsLabel,
                clsInput: o.clsInput,
                clsUserColorButton: o.clsUserColorButton,
                clsUserColors: o.clsUserColors,
                clsUserColorsTitle: o.clsUserColorsTitle,
                clsUserColor: o.clsUserColor,
                onColor: o.onColor,
                onColorSelectorCreate: o.onColorSelectorCreate
            });

            Metro.makePlugin(colorSelectorBox, 'dropdown', {
                dropFilter: ".color-picker",
                duration: o.duration,
                toggleElement: [picker],
                checkDropUp: true,
                onDrop: function(){
                    Metro.getPlugin(colorSelector, 'color-selector').val(that.value);
                }
            });

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                $.each(Utils.getInlineStyles(element), function(key, value){
                    picker.css(key, value);
                });
            }

            this._setColor();
        },

        _clearInputInterval: function(){
            clearInterval(this.inputInterval);
            this.inputInterval = false;
        },

        _setColor: function(){
            var colorExample = this.colorExample;
            var color = this.value;

            if (this.value.indexOf("cmyk") !== -1 || this.value.indexOf("hsv") !== -1) {
                color = Metro.colors.toHEX(this.value);
            }

            colorExample.css({
                backgroundColor: color
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var picker = this.picker,
                colorSelector = this.colorSelector,
                colorSelectorBox = this.colorSelector;

            picker.on(Metro.events.click, ".input-clear-button", function(e){
                e.preventDefault();
                e.stopPropagation();
                element.val(o.defaultValue).trigger("change");
                Metro.getPlugin(colorSelector, 'color-selector').val(o.defaultValue);
            });

            element.on(Metro.events.inputchange, function(){
                that.value = this.value;
                that._setColor();
            });

            colorSelectorBox.on(Metro.events.click, function(e){
                e.stopPropagation();
            })
        },

        val: function(v){
            if (arguments.length === 0 || !Utils.isValue(v)) {
                return this.value;
            }

            if (!Metro.colors.isColor(v)) {
                return ;
            }

            this.value = v;
            this.element.val(v).trigger("change");
            this._setColor();
        },

        // changeAttribute: function(attr, newValue){
        // },

        destroy: function(){
            this.element.remove();
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".color-picker").removeClass("open");
    });

}(Metro, m4q));


(function(Metro, $) {
    'use strict';

    var supportedColorTypes = "hex, rgb, rgba, hsl, hsla, hsv, cmyk";
    var Utils = Metro.utils;
    var ColorSelectorDefaultConfig = {
        defaultSwatches: "#FFFFFF,#000000,#FFFB0D,#0532FF,#FF9300,#00F91A,#FF2700,#686868,#EE5464,#D27AEE,#5BA8C4,#E64AA9,#1ba1e2,#6a00ff,#bebebe,#f8f8f8",
        userColors: null,
        returnValueType: "hex",
        returnAsString: true,
        showValues: supportedColorTypes,
        showAsString: null,
        showUserColors: true,
        controller: null,
        locale: "en-US",
        addUserColorTitle: null,
        userColorsTitle: null,
        hslMode: "percent",
        showAlphaChannel: true,
        inputThreshold: 300,
        initColor: null,
        readonlyInput: false,
        clsSelector: "",
        clsSwatches: "",
        clsSwatch: "",
        clsValue: "",
        clsLabel: "",
        clsInput: "",
        clsUserColorButton: "",
        clsUserColors: "",
        clsUserColorsTitle: "",
        clsUserColor: "",
        onSelectColor: Metro.noop,
        onColorSelectorCreate: Metro.noop
    };

    Metro.colorSelectorSetup = function (options) {
        ColorSelectorDefaultConfig = $.extend({}, ColorSelectorDefaultConfig, options);
    };

    if (typeof window["metroColorSelectorSetup"] !== undefined) {
        Metro.colorSelectorSetup(window["metroColorSelectorSetup"]);
    }

    Metro.Component('color-selector', {
        init: function( options, elem ) {
            this._super(elem, options, ColorSelectorDefaultConfig, {
                // define instance vars here
                id: Utils.elementId("color-selector"),
                defaultSwatches: [],
                showValues: [],
                userColors: [],
                showAsString: [],
                hue: 0,
                saturation: 0,
                lightness: 1,
                alpha: 1,
                hsl: null,
                hsla: null,
                hsv: null,
                rgb: null,
                rgba: null,
                cmyk: null,
                hex: null,
                inputInterval: null,
                locale: null
            });
            return this;
        },

        _create: function(){
            var o = this.options;

            if (Utils.isValue(o.defaultSwatches)) this.defaultSwatches = o.defaultSwatches.toArray(",").map(function (el){return el.toUpperCase();});
            if (Utils.isValue(o.showValues)) this.showValues = o.showValues.toArray(",");
            if (Utils.isValue(o.userColors)) this.userColors = o.userColors.toArray(",").map(function (el){return el.toUpperCase();});
            if (Utils.isValue(o.showAsString)) this.showAsString = o.showAsString.toArray(",");

            this.locale = Metro.locales[o.locale]['colorSelector'];

            this._createStructure();
            this._createEvents();

            this._fireEvent('color-selector-create');
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options, locale = this.locale;
            var colorBox, row, swatches, map, value, inputs, radios,
                userColorsActions, hueCanvas, shadeCanvas, hueCursor, shadeCursor,
                colorBlock, alphaCanvas, alphaCursor;

            element.addClass("color-selector").addClass(o.clsSelector);

            element.append( colorBox = $("<div>").addClass("color-box") );

            colorBox.append( row = $("<div>").addClass("row") );

            row.append( swatches = $("<div>").addClass("default-swatches").addClass(o.clsSwatches) );
            $.each(this.defaultSwatches, function(){
                swatches.append(
                    $("<button>")
                        .attr("data-color", this)
                        .attr("type", "button")
                        .addClass("swatch")
                        .addClass(o.clsSwatch)
                        .css("background-color", this)
                );
            });

            colorBox.append( row = $("<div>").addClass("row") );

            row.append( map = $("<div>").addClass("color-map") );
            map.append( shadeCursor = $("<button>").attr("type", "button").addClass("cursor color-cursor") )
            map.append( shadeCanvas = $("<canvas>").addClass("color-canvas") )

            row.append( map = $("<div>").addClass("hue-map") );
            map.append( hueCursor = $("<button>").attr("type", "button").addClass("cursor hue-cursor") )
            map.append( hueCanvas = $("<canvas>").addClass("hue-canvas") )

            row.append( map = $("<div>").addClass("alpha-map") );
            map.append( alphaCursor = $("<button>").attr("type", "button").addClass("cursor alpha-cursor") )
            map.append( alphaCanvas = $("<canvas>").addClass("alpha-canvas") )

            colorBox.append( row = $("<div>").addClass("row color-values-block") );

            row.append( value = $("<div>").addClass("color-value-hex") );
            value.append( $("<input type='radio' name='returnType' value='hex' checked>").addClass("check-color-value-hex") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-hex") );
            colorBlock.append( $("<input type='text' data-prepend='HEX:'>").addClass("input-small value-hex") );

            row.append( value = $("<div>").addClass("color-value-rgb") );
            value.append( $("<input type='radio' name='returnType' value='rgb'>").addClass("check-color-value-rgb") );
            value.append( colorBlock = $("<div>").addClass("color-block color-rgb") );
            colorBlock.append( $("<input type='text' data-prepend='R:'>").addClass("input-small value-r") );
            colorBlock.append( $("<input type='text' data-prepend='G:'>").addClass("input-small value-g") );
            colorBlock.append( $("<input type='text' data-prepend='B:'>").addClass("input-small value-b") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-rgb") );
            colorBlock.append( $("<input type='text' data-prepend='RGB:'>").addClass("input-small value-rgb") );

            if (this.showAsString.indexOf("rgb") > -1) {
                value.find(".value-r,.value-g,.value-b").parent().hide();
            } else {
                value.find(".value-rgb").parent().hide();
            }

            row.append( value = $("<div>").addClass("color-value-rgba") );
            value.append( $("<input type='radio' name='returnType' value='rgba'>").addClass("check-color-value-rgba") );
            value.append( colorBlock = $("<div>").addClass("color-block color-rgba") );
            colorBlock.append( $("<input type='text' data-prepend='R:'>").addClass("input-small value-r") );
            colorBlock.append( $("<input type='text' data-prepend='G:'>").addClass("input-small value-g") );
            colorBlock.append( $("<input type='text' data-prepend='B:'>").addClass("input-small value-b") );
            colorBlock.append( $("<input type='text' data-prepend='A:'>").addClass("input-small value-a") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-rgba") );
            colorBlock.append( $("<input type='text' data-prepend='RGBA:'>").addClass("input-small value-rgba") );

            if (this.showAsString.indexOf("rgba") > -1) {
                value.find(".value-r,.value-g,.value-b,.value-a").parent().hide();
            } else {
                value.find(".value-rgba").parent().hide();
            }

            row.append( value = $("<div>").addClass("color-value-hsl") );
            value.append( $("<input type='radio' name='returnType' value='hsl'>").addClass("check-color-value-hsl") );
            value.append( colorBlock = $("<div>").addClass("color-block color-hsl") );
            colorBlock.append( $("<input type='text' data-prepend='H:'>").addClass("input-small value-h") );
            colorBlock.append( $("<input type='text' data-prepend='S:'>").addClass("input-small value-s") );
            colorBlock.append( $("<input type='text' data-prepend='L:'>").addClass("input-small value-l") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-hsl") );
            colorBlock.append( $("<input type='text' data-prepend='HSL:'>").addClass("input-small value-hsl") );

            if (this.showAsString.indexOf("hsl") > -1) {
                value.find(".value-h,.value-s,.value-l").parent().hide();
            } else {
                value.find(".value-hsl").parent().hide();
            }

            row.append( value = $("<div>").addClass("color-value-hsla") );
            value.append( $("<input type='radio' name='returnType' value='hsla'>").addClass("check-color-value-hsla") );
            value.append( colorBlock = $("<div>").addClass("color-block color-hsla") );
            colorBlock.append( $("<input type='text' data-prepend='H:'>").addClass("input-small value-h") );
            colorBlock.append( $("<input type='text' data-prepend='S:'>").addClass("input-small value-s") );
            colorBlock.append( $("<input type='text' data-prepend='L:'>").addClass("input-small value-l") );
            colorBlock.append( $("<input type='text' data-prepend='A:'>").addClass("input-small value-a") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-hsla") );
            colorBlock.append( $("<input type='text' data-prepend='HSLA:'>").addClass("input-small value-hsla") );

            if (this.showAsString.indexOf("hsla") > -1) {
                value.find(".value-h,.value-s,.value-l,.value-a").parent().hide();
            } else {
                value.find(".value-hsla").parent().hide();
            }

            row.append( value = $("<div>").addClass("color-value-hsv") );
            value.append( $("<input type='radio' name='returnType' value='hsv'>").addClass("check-color-value-hsl") );
            value.append( colorBlock = $("<div>").addClass("color-block color-hsv") );
            colorBlock.append( $("<input type='text' data-prepend='H:'>").addClass("input-small value-h") );
            colorBlock.append( $("<input type='text' data-prepend='S:'>").addClass("input-small value-s") );
            colorBlock.append( $("<input type='text' data-prepend='V:'>").addClass("input-small value-v") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-hsv") );
            colorBlock.append( $("<input type='text' data-prepend='HSV:'>").addClass("input-small value-hsv") );

            if (this.showAsString.indexOf("hsv") > -1) {
                value.find(".value-h,.value-s,.value-v").parent().hide();
            } else {
                value.find(".value-hsv").parent().hide();
            }

            row.append( value = $("<div>").addClass("color-value-cmyk") );
            value.append( $("<input type='radio' name='returnType' value='cmyk'>").addClass("check-color-value-cmyk") );
            value.append( colorBlock = $("<div>").addClass("color-block color-cmyk") );
            colorBlock.append( $("<input type='text' data-prepend='C:'>").addClass("input-small value-c") );
            colorBlock.append( $("<input type='text' data-prepend='M:'>").addClass("input-small value-m") );
            colorBlock.append( $("<input type='text' data-prepend='Y:'>").addClass("input-small value-y") );
            colorBlock.append( $("<input type='text' data-prepend='K:'>").addClass("input-small value-k") );
            value.append( colorBlock = $("<div>").addClass("color-block as-string color-cmyk") );
            colorBlock.append( $("<input type='text' data-prepend='CMYK:'>").addClass("input-small value-cmyk") );

            if (this.showAsString.indexOf("cmyk") > -1) {
                value.find(".value-s,.value-m,.value-y,.value-k").parent().hide();
            } else {
                value.find(".value-cmyk").parent().hide();
            }

            colorBox.append( row = $("<div>").addClass("row user-colors-container") );
            row.append( $("<div>").addClass("user-colors-title").addClass(o.clsUserColorsTitle).html(o.userColorsTitle || locale['userColorsTitle']) );
            row.append( $("<div>").addClass("user-colors").addClass(o.clsUserColors) );
            row.append( userColorsActions = $("<div>").addClass("user-colors-actions") );
            userColorsActions.append(
                $("<button>")
                    .addClass("button add-button")
                    .addClass(o.clsUserColorButton)
                    .html("<span class='user-swatch'></span><span>"+(o.addUserColorTitle || locale['addUserColorButton'])+"</span>")
            );

            inputs = colorBox.find("input[type=text]");
            Metro.makePlugin(inputs, 'input', {
                clearButton: false,
                clsPrepend: o.clsLabel,
                clsComponent: o.clsInput
            });
            inputs.addClass(o.clsValue);

            if (o.readonlyInput) {
                inputs.attr("readonly", true);
            }

            radios = colorBox.find("input[type=radio]").each(function(){
                $(this).attr("name", that.id + "-returnType");
            });
            radios.each(function(){
                if ($(this).val() === o.returnValueType) {
                    this.checked = true;
                }
            });
            Metro.makePlugin(radios, 'radio', {
                style: 2
            });

            $.each(supportedColorTypes.toArray(","), function(){
                if (that.showValues.indexOf(this) === -1) element.find(".color-value-"+this).hide();
            });

            if (!o.showUserColors) {
                element.find(".user-colors-container").hide();
            }

            if (!o.showAlphaChannel) {
                element.addClass("no-alpha-channel");
                $.each(["rgba", "hsla"], function(){
                    element.find(".color-value-"+this).hide();
                });
            }

            this._fillUserColors();

            this.hueCanvas = hueCanvas;
            this.hueCursor = hueCursor;
            this.shadeCanvas = shadeCanvas;
            this.shadeCursor = shadeCursor;
            this.alphaCanvas = alphaCanvas;
            this.alphaCursor = alphaCursor;

            this._createShadeCanvas();
            this._createHueCanvas();
            this._createAlphaCanvas();
            this._setColorValues();
            this._updateCursorsColor();

            if (o.initColor && Metro.colors.isColor(o.initColor)) {
                this._colorToPos(typeof o.initColor === "string" ? Metro.colors.parse(o.initColor) : o.initColor);
            }
        },

        _createShadeCanvas: function(color){
            var canvas = this.shadeCanvas[0];
            var ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if(!color) color = '#f00';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            var whiteGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            whiteGradient.addColorStop(0, "#fff");
            whiteGradient.addColorStop(1, "transparent");
            ctx.fillStyle = whiteGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            var blackGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            blackGradient.addColorStop(0, "transparent");
            blackGradient.addColorStop(1, "#000");
            ctx.fillStyle = blackGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        },

        _createHueCanvas: function(){
            var canvas = this.hueCanvas[0];
            var ctx = canvas.getContext('2d');
            var hueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

            hueGradient.addColorStop(0.00, "hsl(0,100%,50%)");
            hueGradient.addColorStop(0.17, "hsl(298.8, 100%, 50%)");
            hueGradient.addColorStop(0.33, "hsl(241.2, 100%, 50%)");
            hueGradient.addColorStop(0.50, "hsl(180, 100%, 50%)");
            hueGradient.addColorStop(0.67, "hsl(118.8, 100%, 50%)");
            hueGradient.addColorStop(0.83, "hsl(61.2,100%,50%)");
            hueGradient.addColorStop(1.00, "hsl(360,100%,50%)");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = hueGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        },

        _createAlphaCanvas: function(){
            var canvas = this.alphaCanvas[0];
            var ctx = canvas.getContext('2d');
            var alphaGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            var startColor = new Metro.colorPrimitive.HSLA(this.hue, 1, .5, 1).toString(), endColor = "rgba(0,0,0,0)";

            alphaGradient.addColorStop(0.00, startColor);
            alphaGradient.addColorStop(1.00, endColor);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = alphaGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        },

        _updateHueCursor: function(y){
            this.hueCursor.css({
                "top": y
            });
        },

        _updateAlphaCursor: function(y){
            this.alphaCursor.css({
                "top": y
            });
        },

        _getHueColor: function(pageY){
            var canvas = this.hueCanvas;
            var offset = canvas.offset();
            var height = canvas.height();
            var y, percent, color, hue;

            y = pageY - offset.top;

            if ( y > height ) y = height;
            if ( y < 0 ) y = 0;

            percent = y / height;
            hue = 360 - (360 * percent);
            if (hue === 360) hue = 0;
            color = "hsl("+ hue +", 100%, 50%)";
            this.hue = hue;

            this._createShadeCanvas(color);
            this._createAlphaCanvas();
            this._updateHueCursor(y);
            this._updateCursorsColor();
            this._setColorValues();
        },

        _getAlphaValue: function(pageY){
            var canvas = this.alphaCanvas;
            var offset = canvas.offset();
            var height = canvas.height();
            var y, percent;

            y = pageY - offset.top;

            if ( y > height ) y = height;
            if ( y < 0 ) y = 0;

            percent = 1 - y / height;
            this.alpha = percent.toFixed(2);

            this._updateAlphaCursor(y);
            this._updateCursorsColor();
            this._setColorValues();
        },

        _getShadeColor: function(pageX, pageY){
            var canvas = this.shadeCanvas;
            var offset = canvas.offset();
            var width = canvas.width();
            var height = canvas.height();
            var x = pageX - offset.left;
            var y = pageY - offset.top;

            if(x > width) x = width;
            if(x < 0) x = 0;
            if(y > height) y = height;
            if(y < 0) y = .1;

            var xRatio = x / width * 100;
            var yRatio = y / height * 100;
            var hsvValue = 1 - (yRatio / 100);
            var hsvSaturation = xRatio / 100;
            var lightness = (hsvValue / 2) * (2 - hsvSaturation);
            var saturation = (hsvValue * hsvSaturation) / (1 - Math.abs(2 * lightness - 1));

            if (isNaN(lightness)) {
                lightness = 0;
            }

            if (isNaN(saturation)) {
                saturation = 0;
            }

            this.lightness = lightness;
            this.saturation = saturation;

            this._updateShadeCursor(x, y);
            this._updateCursorsColor();
            this._setColorValues();
        },

        _updateCursorsColor: function(){
            this.shadeCursor.css({backgroundColor: Metro.colors.toHEX(new Metro.colorPrimitive.HSL(this.hue, this.saturation, this.lightness))});
            this.hueCursor.css({backgroundColor: Metro.colors.toHEX(new Metro.colorPrimitive.HSL(this.hue, 1, .5))});
            this.alphaCursor.css({backgroundColor: Metro.colors.toRGBA(new Metro.colorPrimitive.HSL(this.hue, 1, .5), this.alpha).toString()});
        },

        _updateShadeCursor: function(x, y){
            this.shadeCursor.css({
                top: y,
                left: x
            })
        },

        _colorToPos: function (color){
            var shadeCanvasRect = this.shadeCanvas[0].getBoundingClientRect();
            var hueCanvasRect = this.hueCanvas[0].getBoundingClientRect();
            var alphaCanvasRect = this.alphaCanvas[0].getBoundingClientRect();
            var hsl = Metro.colors.toHSL(color);
            var hsla = Metro.colors.toHSLA(color, color.a);
            var hsv = Metro.colors.toHSV(color);
            var x = shadeCanvasRect.width * hsv.s;
            var y = shadeCanvasRect.height * (1 - hsv.v);
            var hueY = hueCanvasRect.height - ((hsl.h / 360) * hueCanvasRect.height);
            var alphaY = (1 - hsla.a) * alphaCanvasRect.height;

            this.hue = hsl.h;
            this.saturation = hsl.s;
            this.lightness = hsl.l;
            this.alpha = hsla.a;

            this._updateHueCursor(hueY);
            this._updateShadeCursor(x, y);
            this._updateAlphaCursor(alphaY);
            this._updateCursorsColor();
            this._createShadeCanvas("hsl("+ this.hue +", 100%, 50%)");
            this._createAlphaCanvas();
            this._setColorValues();
        },

        _setColorValues: function(){
            var element = this.element, o = this.options;
            var hsl = Metro.colors.toHSL(new Metro.colorPrimitive.HSL(this.hue, this.saturation, this.lightness));
            var hsla = Metro.colors.toHSLA(new Metro.colorPrimitive.HSLA(this.hue, this.saturation, this.lightness, this.alpha));
            var rgb = Metro.colors.toRGB(hsl);
            var rgba = Metro.colors.toRGBA(rgb, this.alpha);
            var hsv = Metro.colors.toHSV(hsl);
            var cmyk = Metro.colors.toCMYK(hsl);
            var hex = Metro.colors.toHEX(hsl);
            var controller = $(o.controller);
            var percent = o.hslMode === "percent";

            this.hsl = hsl;
            this.hsla = hsla;
            this.hsv = hsv;
            this.rgb = rgb;
            this.rgba = rgba;
            this.hex = hex;
            this.cmyk = cmyk;

            element.find(".color-value-hex .value-hex input").val(hex);

            element.find(".color-value-rgb .value-r input").val(rgb.r);
            element.find(".color-value-rgb .value-g input").val(rgb.g);
            element.find(".color-value-rgb .value-b input").val(rgb.b);
            element.find(".color-value-rgb .value-rgb input").val(rgb.toString());

            element.find(".color-value-rgba .value-r input").val(rgba.r);
            element.find(".color-value-rgba .value-g input").val(rgba.g);
            element.find(".color-value-rgba .value-b input").val(rgba.b);
            element.find(".color-value-rgba .value-a input").val(rgba.a);
            element.find(".color-value-rgba .value-rgba input").val(rgba.toString());

            element.find(".color-value-hsl .value-h input").val(hsl.h.toFixed(0));
            element.find(".color-value-hsl .value-s input").val(percent ? Math.round(hsl.s*100)+"%" : hsl.s.toFixed(4));
            element.find(".color-value-hsl .value-l input").val(percent ? Math.round(hsl.l*100)+"%" : hsl.l.toFixed(4));
            element.find(".color-value-hsl .value-hsl input").val(hsl.toString());

            element.find(".color-value-hsla .value-h input").val(hsla.h.toFixed(0));
            element.find(".color-value-hsla .value-s input").val(percent ? Math.round(hsla.s*100)+"%" : hsl.s.toFixed(4));
            element.find(".color-value-hsla .value-l input").val(percent ? Math.round(hsla.l*100)+"%" : hsl.l.toFixed(4));
            element.find(".color-value-hsla .value-a input").val(hsla.a);
            element.find(".color-value-hsla .value-hsla input").val(hsla.toString());

            element.find(".color-value-hsv .value-h input").val(hsv.h.toFixed(0));
            element.find(".color-value-hsv .value-s input").val(percent ? Math.round(hsv.s*100)+"%" : hsv.s.toFixed(4));
            element.find(".color-value-hsv .value-v input").val(percent ? Math.round(hsv.v*100)+"%" : hsv.v.toFixed(4));
            element.find(".color-value-hsv .value-hsv input").val(hsv.toString());

            element.find(".color-value-cmyk .value-c input").val(cmyk.c.toFixed(0));
            element.find(".color-value-cmyk .value-m input").val(cmyk.m.toFixed(0));
            element.find(".color-value-cmyk .value-y input").val(cmyk.y.toFixed(0));
            element.find(".color-value-cmyk .value-k input").val(cmyk.k.toFixed(0));
            element.find(".color-value-cmyk .value-cmyk input").val(cmyk.toString());

            element.find(".user-colors-actions .user-swatch").css({
                backgroundColor: hex
            });

            if (controller && controller.length) {
                controller.val(this.val()).trigger("change");
            }

            this._fireEvent("select-color", {
                color: this.val(),
                primitive: {
                    hsl: this.hsl,
                    hsla: this.hsla,
                    rgb: this.rgb,
                    rgba: this.rgba,
                    hsv: this.hsv,
                    cmyk: this.cmyk,
                    hex: this.hex
                }
            });
        },

        _clearInputInterval: function(){
            clearInterval(this.inputInterval);
            this.inputInterval = false;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var hueMap = element.find(".hue-map");
            var alphaMap = element.find(".alpha-map");
            var shadeMap = element.find(".color-map");
            var controller = $(o.controller);
            var colorValues = element.find(".color-values-block input[type=text]");

            colorValues.on(Metro.events.inputchange, function(){
                var input = $(this);

                that._clearInputInterval();

                if (!that.inputInterval) that.inputInterval = setTimeout(function(){
                    var colorGroup = input.closest(".color-block");
                    var colorType;
                    var color, parts;

                    if (colorGroup.hasClass("color-hex")) {
                        colorType = "hex";
                    } else if (colorGroup.hasClass("color-rgb")) {
                        colorType = "rgb";
                    } else if (colorGroup.hasClass("color-rgba")) {
                        colorType = "rgba";
                    } else if (colorGroup.hasClass("color-hsl")) {
                        colorType = "hsl";
                    } else if (colorGroup.hasClass("color-hsla")) {
                        colorType = "hsla";
                    } else if (colorGroup.hasClass("color-hsv")) {
                        colorType = "hsv";
                    } else if (colorGroup.hasClass("color-cmyk")) {
                        colorType = "cmyk";
                    }

                    if (colorGroup.hasClass("as-string")) {
                        color = input.val();
                    } else {
                        parts = [];
                        $.each(colorGroup.find("input"), function(){
                            parts.push(this.value);
                        });
                        color = colorType + "(" +parts.join(", ")+ ")";
                    }
                    if (color && Metro.colors.isColor(color)) {
                        that.val(color);
                    }

                    that._clearInputInterval();
                }, o.inputThreshold);
            });

            if (controller && controller.length) {
                controller.on(Metro.events.inputchange, function(){
                    that._clearInputInterval();
                    if (!that.inputInterval) that.inputInterval = setTimeout(function(){
                        var val = controller.val();
                        if (val && Metro.colors.isColor(val)) {
                            that.val(val);
                        }
                        that._clearInputInterval();
                    }, o.inputThreshold);
                });
            }

            alphaMap.on(Metro.events.startAll, function(e){

                that._getAlphaValue(Utils.pageXY(e).y);
                that.alphaCursor.addClass("dragging");

                $(document).on(Metro.events.moveAll, function(e){
                    e.preventDefault();
                    that._getAlphaValue(Utils.pageXY(e).y);
                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    that.alphaCursor.removeClass("dragging");
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});
                }, {ns: that.id});
            });

            hueMap.on(Metro.events.startAll, function(e){

                that._getHueColor(Utils.pageXY(e).y);
                that.hueCursor.addClass("dragging");

                $(document).on(Metro.events.moveAll, function(e){
                    e.preventDefault();
                    that._getHueColor(Utils.pageXY(e).y);
                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    that.hueCursor.removeClass("dragging");
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});
                }, {ns: that.id});
            });

            shadeMap.on(Metro.events.startAll, function(e){

                that._getShadeColor(Utils.pageXY(e).x, Utils.pageXY(e).y);
                that.shadeCursor.addClass("dragging");

                $(document).on(Metro.events.moveAll, function(e){
                    e.preventDefault();
                    that._getShadeColor(Utils.pageXY(e).x, Utils.pageXY(e).y);
                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    that.shadeCursor.removeClass("dragging");
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});
                }, {ns: that.id})
            });

            element.on("click", ".swatch", function(){
                that._colorToPos($(this).attr("data-color"));
            });

            element.on("click", ".add-button", function(){
                var color = Metro.colors.toHEX(new Metro.colorPrimitive.HSL(that.hue, that.saturation, that.lightness)).toUpperCase();

                if (that.userColors.indexOf(color) > -1) {
                    return ;
                }

                that.userColors.push(color);

                element.find(".user-colors").append(
                    $("<button>")
                        .attr("data-color", color)
                        .attr("type", "button")
                        .addClass("swatch user-swatch")
                        .css({
                            backgroundColor: color
                        })
                );
            });

            element.find("input[type=radio]").on("click", function(){
                o.returnValueType = $(this).val();
                that._setColorValues();
            });
        },

        val: function(v){
            var o = this.options;

            if (!Utils.isValue(v) || !Metro.colors.isColor(v)) {
                var res;
                switch (o.returnValueType.toLowerCase()) {
                    case "rgb":
                        res = this.rgb;
                        break;
                    case "rgba":
                        res = this.rgba;
                        break;
                    case "hsl":
                        res = this.hsl;
                        break;
                    case "hsla":
                        res = this.hsla;
                        break;
                    case "hsv":
                        res = this.hsv;
                        break;
                    case "cmyk":
                        res = this.cmyk;
                        break;
                    default: res = this.hex;
                }
                return o.returnAsString ? res.toString() : res;
            }

            if (!Metro.colors.isColor(v)) {
                return ;
            }

            this._colorToPos(Metro.colors.parse(v));
        },

        user: function(v){
            if (!Utils.isValue(v)) {
                return this.userColors;
            }

            if (!Array.isArray(v) && typeof v !== "string") {
                return ;
            }

            if (typeof v === "string") {
                this.userColors = v.toArray(",").map(function (el){return el.toUpperCase();});
            } else {
                this.userColors = v.map(function (el){return el.toUpperCase();});
            }

            this._fillUserColors();
        },

        _fillUserColors: function(){
            var colors = this.element.find(".user-colors").clear();

            $.each(this.userColors, function(){
                var color = this;
                colors.append(
                    $("<button>")
                        .attr("data-color", color)
                        .attr("type", "button")
                        .addClass("swatch user-swatch")
                        .css({
                            backgroundColor: color
                        })
                )
            });
        },

        changeAttribute: function(attr, newValue){
            var o = this.options;

            if (attr === "data-return-value-type") {
                o.returnValueType = newValue;
            }

            if (attr === "data-return-as-string") {
                o.returnValueType = Utils.bool(newValue);
            }
        },

        destroy: function(){
            this.element.remove();
        }
    });

    Metro.defaults.ColorSelector = ColorSelectorDefaultConfig;
}(Metro, m4q));


(function(Metro, $) {
    'use strict';
    var Types = {
        HEX: "hex",
        HEXA: "hexa",
        RGB: "rgb",
        RGBA: "rgba",
        HSV: "hsv",
        HSL: "hsl",
        HSLA: "hsla",
        CMYK: "cmyk",
        UNKNOWN: "unknown"
    };

    Metro.colorsSetup = function (options) {
        ColorsDefaultConfig = $.extend({}, ColorsDefaultConfig, options);
    };

    if (typeof window["metroColorsSetup"] !== undefined) {
        Metro.colorsSetup(window["metroColorsSetup"]);
    }

    var ColorsDefaultConfig = {
        angle: 30,
        resultType: 'hex',
        results: 6,
        baseLight: "#ffffff",
        baseDark: "self"
    };

    // function HEX(r, g, b) {
    //     this.r = r || "00";
    //     this.g = g || "00";
    //     this.b = b || "00";
    // }
    //
    // HEX.prototype.toString = function(){
    //     return "#" + [this.r, this.g, this.b].join("");
    // }

    // function dec2hex(d){
    //     return Math.round(parseFloat(d) * 255).toString(16);
    // }
    //
    // function hex2dec(h){
    //     return (parseInt(h, 16) / 255);
    // }

    function shift(h, angle){
        h += angle;
        while (h >= 360.0) h -= 360.0;
        while (h < 0.0) h += 360.0;
        return h;
    }

    function clamp(val){
        return Math.min(1, Math.max(0, val));
    }

    function RGB(r, g, b){
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
    }

    RGB.prototype.toString = function(){
        return "rgb(" + [this.r, this.g, this.b].join(", ") + ")";
    }

    function RGBA(r, g, b, a){
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
        this.a = a === 0 ? 0 : a || 1;
    }

    RGBA.prototype.toString = function(){
        return "rgba(" + [this.r, this.g, this.b, parseFloat(this.a).toFixed(2)].join(", ") + ")";
    }

    function HSV(h, s, v){
        this.h = h || 0;
        this.s = s || 0;
        this.v = v || 0;
    }

    HSV.prototype.toString2 = function(){
        return "hsv(" + [this.h, this.s, this.v].join(", ") + ")";
    }

    HSV.prototype.toString = function(){
        return "hsv(" + [Math.round(this.h), Math.round(this.s*100)+"%", Math.round(this.v*100)+"%"].join(", ") + ")";
    }

    function HSL(h, s, l){
        this.h = h || 0;
        this.s = s || 0;
        this.l = l || 0;
    }

    HSL.prototype.toString2 = function(){
        return "hsl(" + [this.h, this.s, this.l].join(", ") + ")";
    }

    HSL.prototype.toString = function(){
        return "hsl(" + [Math.round(this.h), Math.round(this.s*100)+"%", Math.round(this.l*100)+"%"].join(", ") + ")";
    }

    function HSLA(h, s, l, a){
        this.h = h || 0;
        this.s = s || 0;
        this.l = l || 0;
        this.a = a === 0 ? 0 : a || 1;
    }

    HSLA.prototype.toString2 = function(){
        return "hsla(" + [this.h, this.s, this.l, this.a].join(", ") + ")";
    }

    HSLA.prototype.toString = function(){
        return "hsla(" + [Math.round(this.h), Math.round(this.s*100)+"%", Math.round(this.l*100)+"%", parseFloat(this.a).toFixed(2)].join(", ") + ")";
    }

    function CMYK(c, m, y, k){
        this.c = c || 0;
        this.m = m || 0;
        this.y = y || 0;
        this.k = k || 0;
    }

    CMYK.prototype.toString = function(){
        return "cmyk(" + [this.c, this.m, this.y, this.k].join(", ") + ")";
    }

    var Colors = {

        PALETTES: {
            ALL: "all",
            METRO: "metro",
            STANDARD: "standard"
        },

        metro: {
            lime: '#a4c400',
            green: '#60a917',
            emerald: '#008a00',
            blue: '#00AFF0',
            teal: '#00aba9',
            cyan: '#1ba1e2',
            cobalt: '#0050ef',
            indigo: '#6a00ff',
            violet: '#aa00ff',
            pink: '#dc4fad',
            magenta: '#d80073',
            crimson: '#a20025',
            red: '#CE352C',
            orange: '#fa6800',
            amber: '#f0a30a',
            yellow: '#fff000',
            brown: '#825a2c',
            olive: '#6d8764',
            steel: '#647687',
            mauve: '#76608a',
            taupe: '#87794e'
        },

        standard: {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#DCDCDC",
            ghostwhite: "#F8F8FF",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gray: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavender: "#e6e6fa",
            lavenderblush: "#fff0f5",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrodyellow: "#fafad2",
            lightgray: "#d3d3d3",
            lightgreen: "#90ee90",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32dc32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370db",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdd5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#db7093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            rebeccapurple: "#663399",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            slyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
        },

        all: {},

        init: function(){
            this.all = $.extend( {}, this.standard, this.metro );
            return this;
        },

        color: function(name, palette){
            palette = palette || this.PALETTES.ALL;
            return this[palette][name] !== undefined ? this[palette][name] : false;
        },

        palette: function(palette){
            palette = palette || this.PALETTES.ALL;
            return Object.keys(this[palette]);
        },

        expandHexColor: function(hex){
            if (typeof hex !== "string") {
                throw new Error("Value is not a string!");
            }
            if (hex[0] === "#" && hex.length === 4) {
                var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                return (
                    "#" +
                    hex.replace(shorthandRegex, function(m, r, g, b) {
                        return r + r + g + g + b + b;
                    })
                );
            }
            return hex[0] === "#" ? hex : "#" + hex;
        },

        colors: function(palette){
            palette = palette || this.PALETTES.ALL;
            return Object.values(this[palette]);
        },

        random: function(colorType, alpha){
            colorType = colorType || Types.HEX;
            alpha = typeof alpha !== "undefined" ? alpha : 1;

            var hex, r, g, b;

            r = $.random(0, 255);
            g = $.random(0, 255);
            b = $.random(0, 255);

            hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

            return colorType === "hex" ? hex : this.toColor(hex, colorType, alpha);
        },

        parse: function(color){
            var _color = color.toLowerCase().trim();

            var a = _color
                .replace(/[^%\d.,]/g, "")
                .split(",")
                .map(function(v) {
                    if (v.indexOf('%') > -1) {
                        v = ""+parseInt(v)/100;
                    }
                    return v.indexOf(".") > -1 ? parseFloat(v) : parseInt(v);
                });

            if (this.metro[_color]) {
                return this.expandHexColor(this.metro[_color]);
            }

            if (this.standard[_color]) {
                return this.expandHexColor(this.standard[_color]);
            }

            if (_color[0] === "#") {
                return this.expandHexColor(_color);
            }

            if (_color.indexOf("rgba") === 0 && a.length === 4) {
                return new RGBA(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("rgb") === 0 && a.length === 3) {
                return new RGB(a[0], a[1], a[2]);
            }
            if (_color.indexOf("cmyk") === 0 && a.length === 4) {
                return new CMYK(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("hsv") === 0 && a.length === 3) {
                return new HSV(a[0], a[1], a[2]);
            }
            if (_color.indexOf("hsla") === 0 && a.length === 4) {
                return new HSLA(a[0], a[1], a[2], a[3]);
            }
            if (_color.indexOf("hsl")  === 0 && a.length === 3) {
                return new HSL(a[0], a[1], a[2]);
            }
            return undefined;
        },

        createColor: function(colorType, from){
            colorType = colorType || "hex";
            from = from || "#000000";

            var baseColor;

            if (typeof from === "string") {
                baseColor = this.parse(from);
            }

            if (!this.isColor(baseColor)) {
                baseColor = "#000000";
            }

            return this.toColor(baseColor, colorType.toLowerCase());
        },

        isDark: function(color){
            if (!this.isColor(color)) return;
            var rgb = this.toRGB(color);
            var YIQ = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            return YIQ < 128;
        },

        isLight: function(color){
            return !this.isDark(color);
        },

        isHSV: function(color){
            return color instanceof HSV;
        },

        isHSL: function(color){
            return color instanceof HSL;
        },

        isHSLA: function(color){
            return color instanceof HSLA;
        },

        isRGB: function(color){
            return color instanceof RGB;
        },

        isRGBA: function(color){
            return color instanceof RGBA;
        },

        isCMYK: function(color){
            return color instanceof CMYK;
        },

        isHEX: function(color){
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
        },

        isColor: function(val){
            var color = typeof val === "string" ? this.parse(val) : val;

            return !color
                ? false
                : this.isHEX(color) ||
                  this.isRGB(color) ||
                  this.isRGBA(color) ||
                  this.isHSV(color) ||
                  this.isHSL(color) ||
                  this.isHSLA(color) ||
                  this.isCMYK(color);
        },

        check: function(color, type){
            var that = this, checkFor = typeof type === "string" ? [type] : type;
            var result = false;

            $.each(checkFor, function(){
                if (that["is"+this.toUpperCase()](color)) {
                    result = true;
                }
            });

            if (!result) {
                throw new Error("Value is not a " + type + " color type!");
            }
        },

        colorType: function(color){
            if (this.isHEX(color)) return Types.HEX;
            if (this.isRGB(color)) return Types.RGB;
            if (this.isRGBA(color)) return Types.RGBA;
            if (this.isHSV(color)) return Types.HSV;
            if (this.isHSL(color)) return Types.HSL;
            if (this.isHSLA(color)) return Types.HSLA;
            if (this.isCMYK(color)) return Types.CMYK;

            return Types.UNKNOWN;
        },

        equal: function(color1, color2){
            if (!this.isColor(color1) || !this.isColor(color2)) {
                return false;
            }

            return this.toHEX(color1) === this.toHEX(color2);
        },

        colorToString: function(color){
            return color.toString();
        },

        hex2rgb: function(color){
            if (typeof color !== "string") {
                throw new Error("Value is not a string!")
            }
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                this.expandHexColor(color)
            );
            var rgb = [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ];
            return result ? new RGB(rgb[0], rgb[1], rgb[2]) : null;
        },

        // TODO can be improved
        rgb2hex: function(color){
            this.check(color, "rgb");
            return (
                "#" +
                ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1)
            );
        },

        rgb2hsv: function(color){
            this.check(color, "rgb");
            var hsv = new HSV();
            var h, s, v;
            var r = color.r / 255,
                g = color.g / 255,
                b = color.b / 255;

            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var delta = max - min;

            v = max;

            if (max === 0) {
                s = 0;
            } else {
                s = 1 - min / max;
            }

            if (max === min) {
                h = 0;
            } else if (max === r && g >= b) {
                h = 60 * ((g - b) / delta);
            } else if (max === r && g < b) {
                h = 60 * ((g - b) / delta) + 360;
            } else if (max === g) {
                h = 60 * ((b - r) / delta) + 120;
            } else if (max === b) {
                h = 60 * ((r - g) / delta) + 240;
            } else {
                h = 0;
            }

            hsv.h = h;
            hsv.s = s;
            hsv.v = v;

            return hsv;
        },

        hsv2rgb: function(color){
            this.check(color, "hsv");
            var r, g, b;
            var h = color.h,
                s = color.s * 100,
                v = color.v * 100;
            var Hi = Math.floor(h / 60);
            var Vmin = ((100 - s) * v) / 100;
            var alpha = (v - Vmin) * ((h % 60) / 60);
            var Vinc = Vmin + alpha;
            var Vdec = v - alpha;

            switch (Hi) {
                case 0:
                    r = v;
                    g = Vinc;
                    b = Vmin;
                    break;
                case 1:
                    r = Vdec;
                    g = v;
                    b = Vmin;
                    break;
                case 2:
                    r = Vmin;
                    g = v;
                    b = Vinc;
                    break;
                case 3:
                    r = Vmin;
                    g = Vdec;
                    b = v;
                    break;
                case 4:
                    r = Vinc;
                    g = Vmin;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = Vmin;
                    b = Vdec;
                    break;
            }

            return new RGB(
                Math.round((r * 255) / 100),
                Math.round((g * 255) / 100),
                Math.round((b * 255) / 100)
            );
        },

        hsv2hex: function(color){
            this.check(color, "hsv");
            return this.rgb2hex(this.hsv2rgb(color));
        },

        hex2hsv: function(color){
            this.check(color, "hex");
            return this.rgb2hsv(this.hex2rgb(color));
        },

        rgb2cmyk: function(color){
            this.check(color, "rgb");
            var cmyk = new CMYK();

            var r = color.r / 255;
            var g = color.g / 255;
            var b = color.b / 255;

            cmyk.k = Math.min(1 - r, 1 - g, 1 - b);

            cmyk.c = 1 - cmyk.k === 0 ? 0 : (1 - r - cmyk.k) / (1 - cmyk.k);
            cmyk.m = 1 - cmyk.k === 0 ? 0 : (1 - g - cmyk.k) / (1 - cmyk.k);
            cmyk.y = 1 - cmyk.k === 0 ? 0 : (1 - b - cmyk.k) / (1 - cmyk.k);

            cmyk.c = Math.round(cmyk.c * 100);
            cmyk.m = Math.round(cmyk.m * 100);
            cmyk.y = Math.round(cmyk.y * 100);
            cmyk.k = Math.round(cmyk.k * 100);

            return cmyk;
        },

        cmyk2rgb: function(color){
            this.check(color, "cmyk");
            var r = Math.floor(255 * (1 - color.c / 100) * (1 - color.k / 100));
            var g = Math.ceil(255 * (1 - color.m / 100) * (1 - color.k / 100));
            var b = Math.ceil(255 * (1 - color.y / 100) * (1 - color.k / 100));

            return new RGB(r, g, b);
        },

        hsv2hsl: function(color){
            this.check(color, "hsv");
            var h, s, l, d;
            h = color.h;
            l = (2 - color.s) * color.v;
            s = color.s * color.v;
            if (l === 0) {
                s = 0;
            } else {
                d = l <= 1 ? l : 2 - l;
                if (d === 0) {
                    s = 0;
                } else {
                    s /= d;
                }
            }
            l /= 2;
            return new HSL(h, s, l);
        },

        hsl2hsv: function(color){
            this.check(color, ["hsl", "hsla"]);
            var h, s, v, l;
            h = color.h;
            l = color.l * 2;
            s = color.s * (l <= 1 ? l : 2 - l);

            v = (l + s) / 2;

            if (l + s === 0) {
                s = 0;
            } else {
                s = (2 * s) / (l + s);
            }

            return new HSV(h, s, v);
        },

        rgb2websafe: function(color){
            this.check(color, "rgb");
            return new RGB(
                Math.round(color.r / 51) * 51,
                Math.round(color.g / 51) * 51,
                Math.round(color.b / 51) * 51
            );
        },

        rgba2websafe: function(color){
            this.check(color, "rgba");
            var rgbWebSafe = this.rgb2websafe(color);
            return new RGBA(rgbWebSafe.r, rgbWebSafe.g, rgbWebSafe.b, color.a);
        },

        hex2websafe: function(color){
            this.check(color, "hex");
            return this.rgb2hex(this.rgb2websafe(this.hex2rgb(color)));
        },

        hsv2websafe: function(color){
            this.check(color, "hsv");
            return this.rgb2hsv(this.rgb2websafe(this.toRGB(color)));
        },

        hsl2websafe: function(color){
           this.check(color, "hsl");
            return this.hsv2hsl(this.rgb2hsv(this.rgb2websafe(this.toRGB(color))));
        },

        cmyk2websafe: function(color){
            this.check(color, "cmyk");
            return this.rgb2cmyk(this.rgb2websafe(this.cmyk2rgb(color)));
        },

        websafe: function(color){
            if (this.isHEX(color)) return this.hex2websafe(color);
            if (this.isRGB(color)) return this.rgb2websafe(color);
            if (this.isRGBA(color)) return this.rgba2websafe(color);
            if (this.isHSV(color)) return this.hsv2websafe(color);
            if (this.isHSL(color)) return this.hsl2websafe(color);
            if (this.isCMYK(color)) return this.cmyk2websafe(color);

            return color;
        },

        toColor: function(color, type, alpha){
            var result;
            switch (type.toLowerCase()) {
                case "hex":
                    result = this.toHEX(color);
                    break;
                case "rgb":
                    result = this.toRGB(color);
                    break;
                case "rgba":
                    result = this.toRGBA(color, alpha);
                    break;
                case "hsl":
                    result = this.toHSL(color);
                    break;
                case "hsla":
                    result = this.toHSLA(color, alpha);
                    break;
                case "hsv":
                    result = this.toHSV(color);
                    break;
                case "cmyk":
                    result = this.toCMYK(color);
                    break;
                default:
                    result = color;
            }
            return result;
        },

        toHEX: function(val){
            var color = typeof val === "string" ? this.parse(val) : val;

            if (!color) {
                throw new Error("Unknown color format!");
            }

            return typeof color === "string"
                ? color
                : this.rgb2hex(this.toRGB(color));
        },

        toRGB: function(val){
            var color = typeof val === "string" ? this.parse(val) : val;

            if (this.isRGB(color)) return color;
            if (this.isRGBA(color)) return new RGB(color.r, color.g, color.b);
            if (this.isHSV(color)) return this.hsv2rgb(color);
            if (this.isHSL(color)) return this.hsv2rgb(this.hsl2hsv(color));
            if (this.isHSLA(color)) return this.hsv2rgb(this.hsl2hsv(color));
            if (this.isHEX(color)) return this.hex2rgb(color);
            if (this.isCMYK(color)) return this.cmyk2rgb(color);

            throw new Error("Unknown color format!");
        },

        toRGBA: function(color, alpha){
            if (this.isRGBA(color)) {
                if (alpha) {
                    color.a = alpha;
                }
                return color;
            }
            var rgb = this.toRGB(color);
            return new RGBA(rgb.r, rgb.g, rgb.b, alpha);
        },

        toHSV: function(color){
            return this.rgb2hsv(this.toRGB(color));
        },

        toHSL: function(color){
            return this.hsv2hsl(this.rgb2hsv(this.toRGB(color)));
        },

        toHSLA: function(color, alpha){
            if (this.isHSLA(color)) {
                if (alpha) {
                    color.a = alpha;
                }
                return color;
            }
            var hsla = this.hsv2hsl(this.rgb2hsv(this.toRGB(color)));
            hsla.a = alpha;
            return new HSLA(hsla.h, hsla.s, hsla.l, hsla.a);
        },

        toCMYK: function(color){
            return this.rgb2cmyk(this.toRGB(color));
        },

        grayscale: function(color){
            return this.desaturate(color, 100);
        },

        lighten: function(color, amount){
            var hsl, type, alpha;

            if (!this.isColor(color)) {
                throw new Error(color + " is not a valid color value!");
            }

            amount = (amount === 0) ? 0 : (amount || 10);
            hsl = this.toHSL(color);
            hsl.l += amount / 100;
            hsl.l = clamp(hsl.l);

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsl, type, alpha);
        },

        darken: function(color, amount){
            return this.lighten(color, -amount);
        },

        spin: function(color, amount){
            var hsl, type, alpha, hue;

            if (!this.isColor(color)) {
                throw new Error(color + " is not a valid color value!");
            }

            hsl = this.toHSL(color);
            hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsl, type, alpha);
        },

        brighten: function(color, amount){
            var rgb, type, alpha;

            if (!this.isColor(color)) {
                throw new Error(color + " is not a valid color value!");
            }

            rgb = this.toRGB(color);
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * - (amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * - (amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * - (amount / 100))));

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(rgb, type, alpha);
        },

        saturate: function(color, amount){
            var hsl, type, alpha;

            if (!this.isColor(color)) {
                throw new Error(color + " is not a valid color value!");
            }

            hsl = this.toHSL(color);
            hsl.s += amount / 100;
            hsl.s = clamp(hsl.s);

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsl, type, alpha);
        },

        desaturate: function(color, amount){
            var hsl, type, alpha;

            if (!this.isColor(color)) {
                throw new Error(color + " is not a valid color value!");
            }

            hsl = this.toHSL(color);
            hsl.s -= amount / 100;
            hsl.s = clamp(hsl.s);

            type = this.colorType(color).toLowerCase();

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsl, type, alpha);
        },

        hueShift: function(color, hue, saturation, value){
            var hsv = this.toHSV(color);
            var type = this.colorType(color).toLowerCase();
            var h = hsv.h;
            var alpha;
            var _h = hue || 0;
            var _s = saturation || 0;
            var _v = value || 0;

            h += _h;
            while (h >= 360.0) h -= 360.0;
            while (h < 0.0) h += 360.0;
            hsv.h = h;

            hsv.s += _s;
            if (hsv.s > 1) {hsv.s = 1;}
            if (hsv.s < 0) {hsv.s = 0;}

            hsv.v += _v;
            if (hsv.v > 1) {hsv.v = 1;}
            if (hsv.v < 0) {hsv.v = 0;}

            if (type === Types.RGBA || type === Types.HSLA) {
                alpha = color.a;
            }

            return this.toColor(hsv, type, alpha);
        },

        shade: function(color, amount){
            if (!this.isColor(color)) {
                throw new Error(color + " is not a valid color value!");
            }

            amount /= 100;

            var type = this.colorType(color).toLowerCase();
            var rgb = this.toRGB(color);
            var t = amount < 0 ? 0 : 255;
            var p = amount < 0 ? amount * -1 : amount;
            var r, g, b, a;

            r = (Math.round((t - rgb.r) * p) + rgb.r);
            g = (Math.round((t - rgb.g) * p) + rgb.g);
            b = (Math.round((t - rgb.b) * p) + rgb.b);

            if (type === Types.RGBA || type === Types.HSLA) {
                a = color.a;
            }

            return this.toColor(new RGB(r, g, b), type, a);
        },

        mix: function(color1, color2, amount){

            amount = (amount === 0) ? 0 : (amount || 50);

            var rgb = new RGB(0,0,0);
            var rgb1 = this.toRGB(color1);
            var rgb2 = this.toRGB(color2);

            var p = amount / 100;

            rgb.r = Math.round(((rgb2.r - rgb1.r) * p) + rgb1.r);
            rgb.g = Math.round(((rgb2.g - rgb1.g) * p) + rgb1.g);
            rgb.b = Math.round(((rgb2.b - rgb1.b) * p) + rgb1.b);

            return this.toHEX(rgb);
        },

        multiply: function(color1, color2){
            var rgb1 = this.toRGB(color1);
            var rgb2 = this.toRGB(color2);
            var rgb = new RGB();

            rgb1.b = Math.floor(rgb1.b * rgb2.b / 255);
            rgb1.g = Math.floor(rgb1.g * rgb2.g / 255);
            rgb1.r = Math.floor(rgb1.r * rgb2.r / 255);

            return this.toHEX(rgb);
        },

        materialPalette: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var baseLight = opt.baseLight;
            var baseDark = opt.baseDark === "self" || !opt.baseDark ? this.multiply(color, color) : opt.baseDark;

            return {
                "50": this.mix(baseLight, color, 10),
                "100": this.mix(baseLight, color, 30),
                "200": this.mix(baseLight, color, 50),
                "300": this.mix(baseLight, color, 70),
                "400": this.mix(baseLight, color, 85),
                "500": this.mix(baseLight, color, 100),
                "600": this.mix(baseDark, color, 92),
                "700": this.mix(baseDark, color, 83),
                "800": this.mix(baseDark, color, 74),
                "900": this.mix(baseDark, color, 65),

                "A100": this.lighten(this.saturate(this.mix(baseDark, color, 15), 80), 65),
                "A200": this.lighten(this.saturate(this.mix(baseDark, color, 15), 80), 55),
                "A400": this.lighten(this.saturate(this.mix(baseLight, color, 100), 55), 10),
                "A700": this.lighten(this.saturate(this.mix(baseDark, color, 83), 65), 10)
            };
        },

        monochromatic: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var returnAs = opt.resultType;
            var results = opt.results;
            var hsv = this.toHSV(color);
            var h = hsv.h,
                s = hsv.s,
                v = hsv.v;
            var result = [];
            var mod = 1 / results;
            var self = this;

            while (results--) {
                result.push(new HSV(h, s, v));
                v = (v + mod) % 1;
            }

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        complementary: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var hsl = this.toHSL(color);
            var result;
            var self = this;

            var returnAs = opt.resultType;

            result = [
                hsl,
                new HSL(shift(hsl.h, 180), hsl.s, hsl.l)
            ];

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        splitComplementary: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var hsl = this.toHSL(color);
            var h = hsl.h;
            var result, self = this;

            var returnAs = opt.resultType;
            var angle = opt.angle;

            result = [
                hsl,
                new HSL(shift(h, 180 - angle), hsl.s, hsl.l ),
                new HSL(shift(h, 180 + angle), hsl.s, hsl.l )
            ];

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        doubleComplementary: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var returnAs = opt.resultType;
            var angle = opt.angle;
            var hsl = this.toHSL(color);
            var h = hsl.h;
            var result, self = this;

            result = [
                hsl,
                new HSL(shift(h, 180), hsl.s, hsl.l ),
                new HSL(shift(h, angle), hsl.s, hsl.l ),
                new HSL(shift(h, 180 + angle), hsl.s, hsl.l )
            ];

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        square: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var returnAs = opt.resultType;
            var result = [], i;
            var hsl = this.toHSL(color);
            var h = hsl.h , self = this;

            result.push(hsl);

            for (i = 1; i < 4; i++) {
                h = shift(h, 90.0);
                result.push(new HSL(h, hsl.s, hsl.l));
            }

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        tetradic: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var returnAs = opt.resultType;
            var angle = opt.angle;
            var result;
            var hsl = this.toHSL(color);
            var h = hsl.h;
            var self = this;

            result = [
                hsl,
                new HSL(shift(h, 180), hsl.s, hsl.l),
                new HSL(shift(h, 180 - angle), hsl.s, hsl.l),
                new HSL(shift(h, -angle), hsl.s, hsl.l)
            ];

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        triadic: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var returnAs = opt.resultType;
            var result;
            var hsl = this.toHSL(color);
            var h = hsl.h;
            var self = this;

            result = [
                hsl,
                new HSL(shift(h,120), hsl.s, hsl.l),
                new HSL(shift(h,240), hsl.s, hsl.l)
            ];

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        analogous: function(color, options){
            var opt = $.extend({}, ColorsDefaultConfig, options);
            var returnAs = opt.resultType;
            var angle = opt.angle;

            var hsl = this.toHSL(color);
            var result, self = this;

            result = [
                hsl,
                new HSL(shift(hsl.h, -angle), hsl.s, hsl.l),
                new HSL(shift(hsl.h, +angle), hsl.s, hsl.l)
            ];

            return result.map(function(el){
                return self["to"+returnAs.toUpperCase()](el);
            });
        },

        createScheme: function(color, name, options){
            switch (name.toLowerCase()) {
                case "analogous":
                case "analog": return this.analogous(color, options);

                case "triadic":
                case "triad": return this.triadic(color, options);

                case "tetradic":
                case "tetra": return this.tetradic(color, options);

                case "monochromatic":
                case "mono": return this.monochromatic(color, options);

                case "complementary":
                case "complement":
                case "comp": return this.complementary(color, options);

                case "double-complementary":
                case "double-complement":
                case "double": return this.doubleComplementary(color, options);

                case "split-complementary":
                case "split-complement":
                case "split": return this.splitComplementary(color, options);

                case "square": return this.square(color, options);
                case "material": return this.materialPalette(color, options);
            }
        },

        getScheme: function(){
            return this.createScheme.apply(this, arguments)
        },

        add: function(val1, val2, returnAs){
            var color1 = typeof val1 === "string" ? this.parse(val1) : val1;
            var color2 = typeof val2 === "string" ? this.parse(val2) : val2;
            var c1 = this.toRGBA(color1);
            var c2 = this.toRGBA(color2);
            var result = new RGBA();
            var to = (""+returnAs).toLowerCase() || "hex";

            result.r = Math.round((c1.r + c2.r) / 2);
            result.g = Math.round((c1.g + c2.g) / 2);
            result.b = Math.round((c1.b + c2.b) / 2);
            result.a = Math.round((c1.a + c2.a) / 2);

            return this["to"+to.toUpperCase()](result);
        }
    };

    var Color = function(color, options){
        this._setValue(color);
        this._setOptions(options);
    }

    Color.prototype = {
        _setValue: function(color){
            var _color;

            if (typeof color === "string") {
                _color = Colors.parse(color);
            } else {
                _color = color;
            }

            if (!Colors.isColor(_color)) {
                _color = "#000000";
            }

            this._value = _color;
            this._type = Colors.colorType(this._value);
        },

        _setOptions: function(options){
            options = typeof options === "object" ? options : {};
            this._options = $.extend({}, ColorsDefaultConfig, options);
        },

        getOptions: function(){
            return this._options;
        },

        setOptions: function(options){
            this._setOptions(options);
        },

        setValue: function(color){
            this._setValue(color);
        },

        getValue: function(){
            return this._value;
        },

        channel: function(ch, val){
            var currentType = this._type.toUpperCase();

            if (["red", "green", "blue"].indexOf(ch) > -1) {
                this.toRGB();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (ch === "alpha" && this._value.a) {
                this._value.a = val;
            }
            if (["hue", "saturation", "value"].indexOf(ch) > -1) {
                this.toHSV();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (["lightness"].indexOf(ch) > -1) {
                this.toHSL();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }
            if (["cyan", "magenta", "yellow", "black"].indexOf(ch) > -1) {
                this.toCMYK();
                this._value[ch[0]] = val;
                this["to"+currentType]();
            }

            return this;
        },

        channels: function(obj){
            var that = this;

            $.each(obj, function(key, val){
                that.channel(key, val);
            });

            return this;
        },

        toRGB: function() {
            this._value = Colors.toRGB(this._value);
            this._type = Types.RGB;
            return this;
        },

        rgb: function(){
            return this._value ? new Color(Colors.toRGB(this._value)) : undefined;
        },

        toRGBA: function(alpha) {
            if (Colors.isRGBA(this._value)) {
                if (alpha) {
                    this._value = Colors.toRGBA(this._value, alpha);
                }
            } else {
                this._value = Colors.toRGBA(this._value, alpha);
            }
            this._type = Types.RGBA;
            return this;
        },

        rgba: function(alpha) {
            return this._value ? new Color(Colors.toRGBA(this._value, alpha)) : undefined;
        },

        toHEX: function() {
            this._value = Colors.toHEX(this._value);
            this._type = Types.HEX;
            return this;
        },

        hex: function() {
            return this._value ? new Color(Colors.toHEX(this._value)) : undefined;
        },

        toHSV: function() {
            this._value = Colors.toHSV(this._value);
            this._type = Types.HSV;
            return this;
        },

        hsv: function() {
            return this._value ? new Color(Colors.toHSV(this._value)) : undefined;
        },

        toHSL: function() {
            this._value = Colors.toHSL(this._value);
            this._type = Types.HSL;
            return this;
        },

        hsl: function() {
            return this._value ? new Color(Colors.toHSL(this._value)) : undefined;
        },

        toHSLA: function(alpha) {
            if (Colors.isHSLA(this._value)) {
                if (alpha) {
                    this._value = Colors.toHSLA(this._value, alpha);
                }
            } else {
                this._value = Colors.toHSLA(this._value, alpha);
            }
            this._type = Types.HSLA;
            return this;
        },

        hsla: function(alpha) {
            return this._value ? new Color(Colors.toHSLA(this._value, alpha)) : undefined;
        },

        toCMYK: function() {
            this._value = Colors.toCMYK(this._value);
            this._type = Types.CMYK;
            return this;
        },

        cmyk: function() {
            return this._value ? new Color(Colors.toCMYK(this._value)) : undefined;
        },

        toWebsafe: function() {
            this._value = Colors.websafe(this._value);
            this._type = Colors.colorType(this._value);
            return this;
        },

        websafe: function() {
            return this._value ? new Color(Colors.websafe(this._value)) : undefined;
        },

        toString: function() {
            return this._value ? Colors.colorToString(this._value) : "undefined";
        },

        toDarken: function(amount) {
            this._value = Colors.darken(this._value, amount);
            return this;
        },

        darken: function(amount){
            return new Color(Colors.darken(this._value, amount));
        },

        toLighten: function(amount) {
            this._value = Colors.lighten(this._value, amount);
            return this;
        },

        lighten: function(amount){
            return new Color(Colors.lighten(this._value, amount))
        },

        isDark: function() {
            return this._value ? Colors.isDark(this._value) : undefined;
        },

        isLight: function() {
            return this._value ? Colors.isLight(this._value) : undefined;
        },

        toHueShift: function(hue, saturation, value) {
            this._value = Colors.hueShift(this._value, hue, saturation, value);
            return this;
        },

        hueShift: function (hue, saturation, value) {
            return new Color(Colors.hueShift(this._value, hue, saturation, value));
        },

        toGrayscale: function() {
            this._value = Colors.grayscale(this._value, this._type);
            return this;
        },

        grayscale: function(){
            return new Color(Colors.grayscale(this._value, this._type));
        },

        type: function() {
            return Colors.colorType(this._value);
        },

        createScheme: function(name, format, options) {
            return this._value
                ? Colors.createScheme(this._value, name, format, options)
                : undefined;
        },

        getScheme: function(){
            return this.createScheme.apply(this, arguments);
        },

        equal: function(color) {
            return Colors.equal(this._value, color);
        },

        toAdd: function(color){
            this._value = Colors.add(this._value, color, this._type);
            return this;
        },

        add: function(color){
            return new Color(Colors.add(this._value, color, this._type));
        }
    }

    Metro.colors = Colors.init();
    window.Color = Metro.Color = Color;
    window.ColorPrimitive = Metro.colorPrimitive = {
        RGB: RGB,
        RGBA: RGBA,
        HSV: HSV,
        HSL: HSL,
        HSLA: HSLA,
        CMYK: CMYK
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Colors = Metro.colors;
    }

}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var cookieDisclaimerDefaults = {
        name: 'cookies_accepted',
        template: null,
        templateSource: null,
        acceptButton: '.cookie-accept-button',
        cancelButton: '.cookie-cancel-button',
        message: 'Our website uses cookies to monitor traffic on our website and ensure that we can provide our customers with the best online experience possible.',
        duration: "30days",
        clsContainer: "",
        clsMessage: "",
        clsButtons: "",
        clsAcceptButton: "alert",
        clsCancelButton: "",
        onAccept: Metro.noop,
        onDecline: Metro.noop
    };

    Metro.cookieDisclaimer = {
        init: function(options){
            var that = this, cookie = Metro.cookie;

            this.options = $.extend({}, cookieDisclaimerDefaults, options);
            this.disclaimer = $("<div>");

            if (cookie.getCookie(this.options.name)) {
                return ;
            }

            if (this.options.template) {
                fetch(this.options.template)
                    .then(Metro.fetch.text)
                    .then(function(data){
                        that.create(data)
                    });
            } else if (this.options.templateSource) {
                this.create($(this.options.templateSource));
            } else {
                this.create();
            }
        },

        create: function(html){
            var cookie = Metro.cookie;
            var o = this.options, wrapper = this.disclaimer, buttons;

            wrapper
                .addClass("cookie-disclaimer-block")
                .addClass(o.clsContainer);

            if (!html) {
                buttons = $("<div>")
                    .addClass("cookie-disclaimer-actions")
                    .addClass(o.clsButtons)
                    .append( $('<button>').addClass('button cookie-accept-button').addClass(o.clsAcceptButton).html('Accept') )
                    .append( $('<button>').addClass('button cookie-cancel-button').addClass(o.clsCancelButton).html('Cancel') );

                wrapper
                    .html( $("<div>").addClass(o.clsMessage).html(o.message) )
                    .append( $("<hr>").addClass('thin') )
                    .append(buttons);

            } else if (html instanceof $) {
                wrapper.append(html);
            } else {
                wrapper.html(html);
            }

            wrapper.appendTo($('body'));

            wrapper.on(Metro.events.click, o.acceptButton, function(){
                var dur = 0;
                var durations = (""+o.duration).toArray(" ");

                $.each(durations, function(){
                    var d = ""+this;
                    if (d.includes("day")) {
                        dur += parseInt(d)*24*60*60*1000;
                    } else
                    if (d.includes("hour")) {
                        dur += parseInt(d)*60*60*1000;
                    } else
                    if (d.includes("min")) {
                        dur += parseInt(d)*60*1000;
                    } else
                    if (d.includes("sec")) {
                        dur += parseInt(d)*1000;
                    } else {
                        dur += parseInt(d);
                    }
                })

                cookie.setCookie(o.name, true, dur);
                Utils.exec(o.onAccept);
                wrapper.remove();
            });

            wrapper.on(Metro.events.click, o.cancelButton, function(){
                Utils.exec(o.onDecline);
                wrapper.remove();
            });
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var CookieDefaultConfig = {
        path: "/",
        expires: null,
        maxAge: null,
        domain: null,
        secure: false,
        samesite: null
    }

    Metro.cookieSetup = function (options) {
        CookieDefaultConfig = $.extend({}, CookieDefaultConfig, options);
    };

    if (typeof window["metroCookieSetup"] !== undefined) {
        Metro.cookieSetup(window["metroCookieSetup"]);
    }

    Metro.cookie = {
        getCookies: function(){
            var a = document.cookie.toArray(";");
            var o = {};
            $.each(a, function(){
                var i = this.split('=');
                o[i[0]] = i[1];
            });
            return o;
        },

        getCookie: function(name){
            var cookieName = encodeURIComponent(name) + "=";
            var cookies = document.cookie.toArray(";");
            var i, cookie;

            for(i = 0; i < cookies.length; i++) {
                cookie = cookies[i];
                while (cookie.charAt(0) === ' ') {
                    cookie = cookie.substring(1, cookie.length);
                }
                if (cookie.indexOf(cookieName) === 0) {
                    return decodeURIComponent(cookie.substring(cookieName.length, cookie.length));
                }
            }
            return null;
        },

        setCookie: function(name, value, options){
            var date;
            var cookieName = encodeURIComponent(name);
            var cookieValue = encodeURIComponent(value);
            var opt, a = [];

            if (options && typeof options !== "object") {
                date = new Date();
                date.setTime(date.getTime()+(parseInt(options)));
                opt = $.extend({}, CookieDefaultConfig, {
                    expires: date.toUTCString()
                });
            } else {
                opt = $.extend({}, CookieDefaultConfig, options);
            }

            $.each(opt, function(key, val){
                if (key !== 'secure' && val) {
                    a.push(Cake.dashedName(key) + "=" + val);
                }
                if (key === 'secure' && val === true) {
                    a.push( "secure" );
                }
            });

            document.cookie = cookieName + '=' + cookieValue + "; " +  a.join("; ");
        },

        delCookie: function(name){
            this.setCookie(name, false, {
                maxAge: -1
            });
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CountdownDefaultConfig = {
        countdownDeferred: 0,
        stopOnBlur: true,
        animate: "none",
        ease: "linear",
        duration: 600,
        inputFormat: null,
        locale: METRO_LOCALE,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        date: null,
        start: true,
        clsCountdown: "",
        clsPart: "",
        clsZero: "",
        clsAlarm: "",
        clsDays: "",
        clsHours: "",
        clsMinutes: "",
        clsSeconds: "",
        onAlarm: Metro.noop,
        onTick: Metro.noop,
        onZero: Metro.noop,
        onBlink: Metro.noop,
        onCountdownCreate: Metro.noop
    };

    Metro.countdownSetup = function (options) {
        CountdownDefaultConfig = $.extend({}, CountdownDefaultConfig, options);
    };

    if (typeof window["metroCountdownSetup"] !== undefined) {
        Metro.countdownSetup(window["metroCountdownSetup"]);
    }

    Metro.Component('countdown', {
        init: function( options, elem ) {
            this._super(elem, options, CountdownDefaultConfig, {
                locale: Metro.locales["en-US"],
                breakpoint: (new Date()).getTime(),
                blinkInterval: null,
                tickInterval: null,
                zeroDaysFired: false,
                zeroHoursFired: false,
                zeroMinutesFired: false,
                zeroSecondsFired: false,
                fontSize: parseInt(Utils.getStyleOne(elem, "font-size")),
                current: {
                    d: 0, h: 0, m: 0, s: 0
                },
                inactiveTab: false,
                id: Utils.elementId("countdown"),
                duration: 600
            });

            return this;
        },

        _create: function(){
            var o = this.options;

            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            this.duration = (+o.duration <= 0 || +o.duration >= 1000) ? 600 : +o.duration;

            this._build();
            this._createEvents();
        },

        _setBreakpoint: function(){
            var o = this.options;
            var dm = 86400000, hm = 3600000, mm = 60000, sm = 1000;

            this.breakpoint = datetime().time();

            if (o.date) {
                this.breakpoint = (o.inputFormat ? Datetime.from(o.date, o.inputFormat) : datetime(o.date)).time();
            }

            if (parseInt(o.days) > 0) {
                this.breakpoint += parseInt(o.days) * dm;
            }
            if (parseInt(o.hours) > 0) {
                this.breakpoint += parseInt(o.hours) * hm;
            }
            if (parseInt(o.minutes) > 0) {
                this.breakpoint += parseInt(o.minutes) * mm;
            }
            if (parseInt(o.seconds) > 0) {
                this.breakpoint += parseInt(o.seconds) * sm;
            }
        },

        _build: function(){
            var that = this, element = this.element, o = this.options;
            var parts = ["days", "hours", "minutes", "seconds"];
            var dm = 24*60*60*1000;
            var delta_days;
            var now = datetime().time();
            var digit;

            if (!element.attr("id")) {
                element.attr("id", Utils.elementId("countdown"));
            }

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("countdown"));
            }

            element.addClass("countdown").addClass(o.clsCountdown);

            this._setBreakpoint();

            delta_days = Math.round((that.breakpoint - now) / dm);

            $.each(parts, function(){
                var part = $("<div>").addClass("part " + this).addClass(o.clsPart).attr("data-label", that.locale["calendar"]["time"][this]).appendTo(element);

                if (this === "days") {part.addClass(o.clsDays);}
                if (this === "hours") {part.addClass(o.clsHours);}
                if (this === "minutes") {part.addClass(o.clsMinutes);}
                if (this === "seconds") {part.addClass(o.clsSeconds);}

                $("<div>").addClass("digit").appendTo(part);
                $("<div>").addClass("digit").appendTo(part);

                if (this === "days" && delta_days >= 100) {

                    for(var i = 0; i < String(Math.round(delta_days/100)).length; i++) {
                        $("<div>").addClass("digit").appendTo(part);
                    }
                }

            });

            digit = element.find(".digit");
            digit.append($("<span class='digit-placeholder'>").html("0"));
            digit.append($("<span class='digit-value'>").html("0"));

            this._fireEvent("countdown-create", {
                element: element
            })

            if (o.start === true) {
                this.start();
            } else {
                this.tick();
            }
        },

        _createEvents: function(){
            var that = this;
            $(document).on("visibilitychange", function() {
                if (document.hidden) {
                    that.pause();
                } else {
                    that.resume();
                }
            }, {ns: this.id});
        },

        blink: function(){
            var element = this.element;
            element.toggleClass("blink");

            this._fireEvent("blink", {
                time: this.current
            });
        },

        tick: function(){
            var element = this.element, o = this.options;
            var dm = 24*60*60, hm = 60*60, mm = 60, sm = 1;
            var left, now = datetime().time();
            var d, h, m, s;
            var days = element.find(".days"),
                hours = element.find(".hours"),
                minutes = element.find(".minutes"),
                seconds = element.find(".seconds");

            left = Math.floor((this.breakpoint - now)/1000);

            if (left <= -1) {
                this.stop();
                element.addClass(o.clsAlarm);

                this._fireEvent("alarm", {
                    time: now
                });

                return ;
            }

            d = Math.floor(left / dm);

            left -= d * dm;
            if (this.current.d !== d) {
                this.current.d = d;
                this.draw("days", d);
            }

            if (d === 0) {
                if (this.zeroDaysFired === false) {
                    this.zeroDaysFired = true;
                    days.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "days",
                        value: days
                    });
                }
            }

            h = Math.floor(left / hm);
            left -= h*hm;
            if (this.current.h !== h) {
                this.current.h = h;
                this.draw("hours", h);
            }

            if (d === 0 && h === 0) {
                if (this.zeroHoursFired === false) {
                    this.zeroHoursFired = true;
                    hours.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "hours",
                        value: hours
                    });
                }
            }

            m = Math.floor(left / mm);
            left -= m*mm;
            if (this.current.m !== m) {
                this.current.m = m;
                this.draw("minutes", m);
            }

            if (d === 0 && h === 0 && m === 0) {
                if (this.zeroMinutesFired === false) {
                    this.zeroMinutesFired = true;
                    minutes.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "minutes",
                        value: minutes
                    });

                }
            }

            s = Math.floor(left / sm);
            if (this.current.s !== s) {
                this.current.s = s;
                this.draw("seconds", s);
            }

            if (d === 0 && h === 0 && m === 0 && s === 0) {
                if (this.zeroSecondsFired === false) {
                    this.zeroSecondsFired = true;
                    seconds.addClass(o.clsZero);

                    this._fireEvent("zero", {
                        part: "seconds",
                        value: seconds
                    });

                }
            }

            this._fireEvent("tick", {
                days: d,
                hours: h,
                minutes: m,
                seconds: s
            });
        },

        draw: function(part, value){
            var element = this.element, o = this.options;
            var digits, digits_length, digit_value, digit_current, digit;
            var len, i, duration = this.duration;

            var slideDigit = function(digit, value){
                var digit_copy, height = digit.height();

                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    top: -1 * height + 'px'
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            top: height,
                            opacity: 0
                        },
                        dur: duration,
                        ease: o.ease,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            top: 0,
                            opacity: 1
                        },
                        dur: duration,
                        ease: o.ease
                    });
            };

            var fadeDigit = function(digit, value){
                var digit_copy;
                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    opacity: 0
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            opacity: 0
                        },
                        dur: duration / 2,
                        ease: o.ease,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            opacity: 1
                        },
                        dur: duration,
                        ease: o.ease
                    });
            };

            var zoomDigit = function(digit, value) {
                var digit_copy, height = digit.height(), fs = parseInt(digit.style("font-size"));

                digit.siblings("-old-digit").remove();
                digit_copy = digit.clone().appendTo(digit.parent());
                digit_copy.css({
                    top: 0,
                    left: 0,
                    opacity: 1
                });

                digit
                    .addClass("-old-digit")
                    .animate({
                        draw: {
                            top: height,
                            opacity: 0,
                            fontSize: 0
                        },
                        dur: duration,
                        ease: o.ease,
                        onDone: function(){
                            $(this).remove();
                        }
                    });

                digit_copy
                    .html(value)
                    .animate({
                        draw: {
                            top: 0,
                            opacity: 1,
                            fontSize: [0, fs]
                        },
                        dur: duration,
                        ease: o.ease
                    });
            };

            value = ""+value;

            if (value.length === 1) {
                value = '0'+value;
            }

            len = value.length;

            digits = element.find("."+part+" .digit:not(-old-digit)");
            digits_length = digits.length;

            for(i = 0; i < len; i++){
                digit = digits.eq(digits_length - 1).find(".digit-value");
                digit_value = Math.floor( parseInt(value) / Math.pow(10, i) ) % 10;
                digit_current = parseInt(digit.text());

                digits_length--;

                if (digit_current === digit_value) {
                    continue;
                }

                switch ((""+o.animate).toLowerCase()) {
                    case "slide": slideDigit(digit, digit_value); break;
                    case "fade": fadeDigit(digit, digit_value); break;
                    case "zoom": zoomDigit(digit, digit_value); break;
                    default: digit.html(digit_value);
                }
            }
        },

        start: function(){
            var that = this, element = this.element;

            if (element.data("paused") === false) {
                return;
            }

            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            element.data("paused", false);

            this._setBreakpoint();
            this.tick();

            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        stop: function(){
            var element = this.element;
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);
            element.data("paused", true);
            element.find(".digit").html("0");
            this.current = {
                d: 0, h:0, m: 0, s:0
            };
        },

        pause: function(){
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);
            this.element.data("paused", true);
        },

        resume: function(){
            var that = this;

            this.element.data("paused", false);
            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        reset: function(){
            var that = this, element = this.element, o = this.options;

            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            element.find(".part").removeClass(o.clsZero);
            element.find(".digit").html("0");

            this._setBreakpoint();

            element.data("paused", false);

            this.tick();

            this.blinkInterval = setInterval(function(){that.blink();}, 500);
            this.tickInterval = setInterval(function(){that.tick();}, 1000);
        },

        togglePlay: function(){
            if (this.element.attr("data-pause") === true) {
                this.pause();
            } else {
                this.start();
            }
        },

        isPaused: function(){
            return this.element.data("paused");
        },

        getBreakpoint: function(asDate){
            return asDate === true ? new Date(this.breakpoint) : this.breakpoint;
        },

        getLeft: function(){
            var dm = 24*60*60*1000, hm = 60*60*1000, mm = 60*1000, sm = 1000;
            var now = (new Date()).getTime();
            var left_seconds = Math.floor(this.breakpoint - now);
            return {
                days: Math.round(left_seconds / dm),
                hours: Math.round(left_seconds / hm),
                minutes: Math.round(left_seconds / mm),
                seconds: Math.round(left_seconds / sm)
            };
        },

        i18n: function(val){
            var that = this, element = this.element, o = this.options;
            var parts = ["days", "hours", "minutes", "seconds"];


            if (val === undefined) {
                return o.locale;
            }
            if (Metro.locales[val] === undefined) {
                return false;
            }
            o.locale = val;
            this.locale = Metro.locales[o.locale];

            $.each(parts, function(){
                var cls = ".part." + this;
                var part = element.find(cls);
                part.attr("data-label", that.locale["calendar"]["time"][this]);
            });
        },

        changeAttrLocale: function(){
            var element = this.element;
            var locale = element.attr('data-locale');
            this.i18n(locale);
        },

        changeAttribute: function(attr, newVal){
            switch (attr) {
                case "data-pause": this.togglePlay(); break;
                case "data-locale": this.i18n(newVal); break;
                case "data-duration": this.duration = +newVal <= 0 || +newVal >= 1000 ? 600 : +newVal; break;
            }
        },

        destroy: function(){
            clearInterval(this.blinkInterval);
            clearInterval(this.tickInterval);

            $(document).off("visibilitychange", {ns: this.id});

            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CounterDefaultConfig = {
        startOnViewport: true,
        counterDeferred: 0,
        duration: 2000,
        value: 0,
        from: 0,
        timeout: 0,
        delimiter: ",",
        prefix: "",
        suffix: "",
        onStart: Metro.noop,
        onStop: Metro.noop,
        onTick: Metro.noop,
        onCounterCreate: Metro.noop
    };

    Metro.counterSetup = function (options) {
        CounterDefaultConfig = $.extend({}, CounterDefaultConfig, options);
    };

    if (typeof window["metroCounterSetup"] !== undefined) {
        Metro.counterSetup(window["metroCounterSetup"]);
    }

    Metro.Component('counter', {
        init: function( options, elem ) {
            this._super(elem, options, CounterDefaultConfig, {
                numbers: [],
                html: $(elem).html(),
                started: false,
                id: Utils.elementId("counter")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("counter-create");
            this._run();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $.window().on("scroll", function(){
                if (o.startOnViewport === true && Utils.inViewport(element[0]) && !that.started) {
                    that.start();
                }
            }, {ns: this.id})
        },

        _run: function(){
            var element = this.element, o = this.options;

            this.started = false;

            if (o.startOnViewport !== true) {
                this.start();
            } else {
                if (Utils.inViewport(element[0])) {
                    this.start();
                }
            }
        },

        startInViewport: function(val, from){
            var o = this.options;

            if (Utils.isValue(from)) {
                o.from = +from;
            }

            if (Utils.isValue(val)) {
                o.value = +val;
            }
            this._run();
        },

        start: function(val, from){
            var that = this, element = this.element, o = this.options;

            if (Utils.isValue(from)) {
                o.from = +from;
            }

            if (Utils.isValue(val)) {
                o.value = +val;
            }

            this.started = true;

            this._fireEvent("start");

            element.animate({
                draw: {
                    innerHTML: [o.from, o.value]
                },
                defer: o.timeout,
                dur: o.duration,
                onFrame: function () {
                    that._fireEvent("tick", {
                        value: +this.innerHTML
                    });
                    this.innerHTML = o.prefix + Number(this.innerHTML).format(0, 0, o.delimiter) + o.suffix
                },
                onDone: function(){
                    that._fireEvent("stop");
                }
            })
        },

        reset: function(){
            this.started = false;
            this.element.html(this.html);
        },

        changeAttribute: function(attr, val){
            var o = this.options;

            if (attr === "data-value") {
                o.value = +val;
            }
            if (attr === "data-from") {
                o.from = +val;
            }
        },

        destroy: function(){
            $.window().off("scroll", {ns: this.id});
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var CubeDefaultConfig = {
        cubeDeferred: 0,
        rules: null,
        color: null,
        flashColor: null,
        flashInterval: 1000,
        numbers: false,
        offBefore: true,
        attenuation: .3,
        stopOnBlur: false,
        cells: 4,
        margin: 8,
        showAxis: false,
        axisStyle: "arrow", //line
        cellClick: false,
        autoRestart: 5000,

        clsCube: "",
        clsCell: "",
        clsSide: "",
        clsSideLeft: "",
        clsSideRight: "",
        clsSideTop: "",
        clsSideLeftCell: "",
        clsSideRightCell: "",
        clsSideTopCell: "",
        clsAxis: "",
        clsAxisX: "",
        clsAxisY: "",
        clsAxisZ: "",

        custom: Metro.noop,
        onTick: Metro.noop,
        onCubeCreate: Metro.noop
    };

    Metro.cubeSetup = function (options) {
        CubeDefaultConfig = $.extend({}, CubeDefaultConfig, options);
    };

    if (typeof window["metroCubeSetup"] !== undefined) {
        Metro.cubeSetup(window["metroCubeSetup"]);
    }

    Metro.cubeDefaultRules = [
        {
            on: {'top': [16],      'left': [4],         'right': [1]},
            off: {'top': [13, 4],   'left': [1, 16],     'right': [13, 4]}
        },
        {
            on: {'top': [12, 15],  'left': [3, 8],      'right': [2, 5]},
            off: {'top': [9, 6, 3], 'left': [5, 10, 15], 'right': [14, 11, 8]}
        },
        {
            on: {'top': [11],      'left': [7],         'right': [6]},
            off: {'top': [1, 2, 5], 'left': [9, 13, 14], 'right': [15, 12, 16]}
        },
        {
            on: {'top': [8, 14],   'left': [2, 12],     'right': [9, 3]},
            off: {'top': [16],      'left': [4],         'right': [1]}
        },
        {
            on: {'top': [10, 7],   'left': [6, 11],     'right': [10, 7]},
            off: {'top': [12, 15],  'left': [3, 8],      'right': [2, 5]}
        },
        {
            on: {'top': [13, 4],   'left': [1, 16],     'right': [13, 4]},
            off: {'top': [11],      'left': [7],         'right': [6]}
        },
        {
            on: {'top': [9, 6, 3], 'left': [5, 10, 15], 'right': [14, 11, 8]},
            off: {'top': [8, 14],   'left': [2, 12],     'right': [9, 3]}
        },
        {
            on: {'top': [1, 2, 5], 'left': [9, 13, 14], 'right': [15, 12, 16]},
            off: {'top': [10, 7],   'left': [6, 11],     'right': [10, 7]}
        }
    ];

    Metro.Component('cube', {
        init: function( options, elem ) {
            this._super(elem, options, CubeDefaultConfig, {
                id: Utils.elementId("cube"),
                rules: null,
                interval: false,
                ruleInterval: false,
                running: false,
                intervals: []
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.rules === null) {
                this.rules = Metro.cubeDefaultRules;
            } else {
                this._parseRules(o.rules);
            }

            this._createCube();
            this._createEvents();

            this._fireEvent("cube-create", {
                element: element
            });
        },

        _parseRules: function(rules){

            if (rules === undefined || rules === null) {
                return false;
            }

            if (Utils.isObject(rules)) {
                this.rules = Utils.isObject(rules);
                return true;
            } else {
                try {
                    this.rules = JSON.parse(rules);
                    return true;
                } catch (err) {
                    console.warn("Unknown or empty rules for cell flashing!");
                    return false;
                }
            }
        },

        _createCube: function(){
            var element = this.element, o = this.options;
            var sides = ['left', 'right', 'top'];
            var id = Utils.elementId("cube");
            var cells_count = Math.pow(o.cells, 2);

            element.addClass("cube").addClass(o.clsCube);

            if (!element.attr('id')) {
                element.attr('id', id);
            }

            this.id = element.attr('id');

            this._createCssForFlashColor();
            this._createCssForCellSize();

            $.each(sides, function(){
                var side, cell, i;

                side = $("<div>").addClass("side " + this+"-side").addClass(o.clsSide).appendTo(element);

                if (this === 'left') {side.addClass(o.clsSideLeft);}
                if (this === 'right') {side.addClass(o.clsSideRight);}
                if (this === 'top') {side.addClass(o.clsSideTop);}

                for(i = 0; i < cells_count; i++) {
                    cell = $("<div>").addClass("cube-cell").addClass("cell-id-"+(i+1)).addClass(o.clsCell);
                    cell.data("id", i + 1).data("side", this);
                    cell.appendTo(side);
                    if (o.numbers === true) {
                        cell.html(i + 1);
                    }
                }
            });

            var cells  = element.find(".cube-cell");
            if (o.color !== null) {
                if (Metro.colors.isColor(o.color)) {
                    cells.css({
                        backgroundColor: o.color,
                        borderColor: o.color
                    })
                } else {
                    cells.addClass(o.color);
                }
            }

            var axis = ['x', 'y', 'z'];
            $.each(axis, function(){
                var axis_name = this;
                var ax = $("<div>").addClass("axis " + o.axisStyle).addClass("axis-"+axis_name).addClass(o.clsAxis);
                if (axis_name === "x") ax.addClass(o.clsAxisX);
                if (axis_name === "y") ax.addClass(o.clsAxisY);
                if (axis_name === "z") ax.addClass(o.clsAxisZ);
                ax.appendTo(element);
            });

            if (o.showAxis === false) {
                element.find(".axis").hide();
            }

            this._run();
        },

        _run: function(){
            var that = this, element = this.element, o = this.options;
            var interval = 0;

            clearInterval(this.interval);
            element.find(".cube-cell").removeClass("light");

            if (o.custom !== Metro.noop) {
                Utils.exec(o.custom, [element]);
            } else {

                element.find(".cube-cell").removeClass("light");

                that._start();

                interval = Utils.isObject(this.rules) ? Utils.objectLength(this.rules) : 0;

                this.interval = setInterval(function(){
                    that._start();
                }, interval * o.flashInterval);
            }
        },

        _createCssForCellSize: function(){
            var element = this.element, o = this.options;
            var sheet = Metro.sheet;
            var width;
            var cell_size;

            if (o.margin === 8 && o.cells === 4) {
                return ;
            }

            width = parseInt(Utils.getStyleOne(element, 'width'));
            cell_size = Math.ceil((width / 2 - o.margin * o.cells * 2) / o.cells);
            Utils.addCssRule(sheet, "#"+element.attr('id')+" .side .cube-cell", "width: "+cell_size+"px!important; height: "+cell_size+"px!important; margin: " + o.margin + "px!important;");
        },

        _createCssForFlashColor: function(){
            var element = this.element, o = this.options;
            var sheet = Metro.sheet;
            var rule1;
            var rule2;
            var rules1 = [];
            var rules2 = [];
            var i;

            if (o.flashColor === null) {
                return ;
            }

            rule1 = "0 0 10px " + Metro.colors.toRGBA(o.flashColor, 1);
            rule2 = "0 0 10px " + Metro.colors.toRGBA(o.flashColor, o.attenuation);

            for(i = 0; i < 3; i++) {
                rules1.push(rule1);
                rules2.push(rule2);
            }

            Utils.addCssRule(sheet, "@keyframes pulsar-cell-"+element.attr('id'), "0%, 100% { " + "box-shadow: " + rules1.join(",") + "} 50% { " + "box-shadow: " + rules2.join(",") + " }");
            Utils.addCssRule(sheet, "#"+element.attr('id')+" .side .cube-cell.light", "animation: pulsar-cell-" + element.attr('id') + " 2.5s 0s ease-out infinite; " + "background-color: " + o.flashColor + "!important; border-color: " + o.flashColor+"!important;");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            $(window).on(Metro.events.blur, function(){
                if (o.stopOnBlur === true && that.running === true) {
                    that._stop();
                }
            }, {ns: element.attr("id")});

            $(window).on(Metro.events.focus, function(){
                if (o.stopOnBlur === true && that.running === false) {
                    that._start();
                }
            }, {ns: element.attr("id")});

            element.on(Metro.events.click, ".cube-cell", function(){
                if (o.cellClick === true) {
                    var cell = $(this);
                    cell.toggleClass("light");
                }
            });
        },

        _start: function(){
            var that = this, element = this.element;

            element.find(".cube-cell").removeClass("light");

            this.running = true;

            $.each(this.rules, function(index, rule){
                that._execRule(index, rule);
            });
        },

        _stop: function(){
            this.running = false;
            clearInterval(this.interval);
            $.each(this.intervals, function(){
                clearInterval(this);
            })
        },

        _tick: function(index, speed){
            var that = this, o = this.options;
            if (speed === undefined) {
                speed = o.flashInterval * index;
            }

            var interval = setTimeout(function(){

                that._fireEvent("tick", {
                    index: index
                });

                clearInterval(interval);
                Utils.arrayDelete(that.intervals, interval);
            }, speed);
            this.intervals.push(interval);
        },

        _toggle: function(cell, func, time, speed){
            var that = this;
            if (speed === undefined) {
                speed = this.options.flashInterval * time;
            }
            var interval = setTimeout(function(){
                cell[func === 'on' ? 'addClass' : 'removeClass']("light");
                clearInterval(interval);
                Utils.arrayDelete(that.intervals, interval);
            }, speed);
            this.intervals.push(interval);
        },

        start: function(){
            this._start();
        },

        stop: function(){
            this._stop();
        },

        toRule: function(index, speed){
            var that = this, element = this.element, o = this.options;
            var rules = this.rules;

            if (rules === null || rules === undefined || rules[index] === undefined) {
                return ;
            }
            clearInterval(this.ruleInterval);
            this.ruleInterval = false;
            this.stop();
            element.find(".cube-cell").removeClass("light");
            for (var i = 0; i <= index; i++) {
                this._execRule(i, rules[i], speed);
            }
            if (Utils.isInt(o.autoRestart) && o.autoRestart > 0) {
                this.ruleInterval = setTimeout(function(){
                    that._run();
                }, o.autoRestart);
            }
        },

        _execRule: function(index, rule, speed){
            var that = this, element = this.element;
            var sides = ['left', 'right', 'top'];

            this._tick(index, speed);

            $.each(sides, function(){
                var side_class = "."+this+"-side";
                var side_name = this;
                var cells_on = rule["on"] !== undefined && rule["on"][side_name] !== undefined ? rule["on"][side_name] : false;
                var cells_off = rule["off"] !== undefined && rule["off"][side_name] !== undefined ? rule["off"][side_name] : false;

                if (cells_on !== false) $.each(cells_on, function(){
                    var cell_index = this;
                    var cell = element.find(side_class + " .cell-id-"+cell_index);

                    that._toggle(cell, 'on', index, speed);
                });

                if (cells_off !== false) $.each(cells_off, function(){
                    var cell_index = this;
                    var cell = element.find(side_class + " .cell-id-"+cell_index);

                    that._toggle(cell, 'off', index, speed);
                });
            });
        },

        rule: function(r){
            if (r === undefined) {
                return this.rules;
            }

            if (this._parseRules(r) !== true) {
                return ;
            }
            this.options.rules = r;
            this.stop();
            this.element.find(".cube-cell").removeClass("light");
            this._run();
        },

        axis: function(show){
            var func = show === true ? "show" : "hide";
            this.element.find(".axis")[func]();
        },

        changeRules: function(){
            var element = this.element, o = this.options;
            var rules = element.attr("data-rules");
            if (this._parseRules(rules) !== true) {
                return ;
            }
            this.stop();
            element.find(".cube-cell").removeClass("light");
            o.rules = rules;
            this._run();
        },

        changeAxisVisibility: function(){
            var element = this.element;
            var visibility = JSON.parse(element.attr("data-show-axis")) === true;
            var func = visibility ? "show" : "hide";
            element.find(".axis")[func]();
        },

        changeAxisStyle: function(){
            var element = this.element;
            var style = element.attr("data-axis-style");

            element.find(".axis").removeClass("arrow line no-style").addClass(style);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-rules": this.changeRules(); break;
                case "data-show-axis": this.changeAxisVisibility(); break;
                case "data-axis-style": this.changeAxisStyle(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            clearInterval(this.interval);
            this.interval = null;

            $(window).off(Metro.events.blur, {ns: element.attr("id")});
            $(window).off(Metro.events.focus,{ns: element.attr("id")});

            element.off(Metro.events.click, ".cube-cell");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DatePickerDefaultConfig = {
        label: "",
        datepickerDeferred: 0,
        gmt: 0,
        format: "YYYY-MM-DD",
        inputFormat: null,
        locale: METRO_LOCALE,
        value: null,
        distance: 3,
        month: true,
        day: true,
        year: true,
        minYear: null,
        maxYear: null,
        defaultYearDistance: 100,
        scrollSpeed: 4,
        copyInlineStyles: false,
        clsPicker: "",
        clsPart: "",
        clsMonth: "",
        clsDay: "",
        clsYear: "",
        clsLabel: "",
        clsButton: "",
        clsOkButton: "",
        clsCancelButton: "",
        okButtonIcon: "<span class='default-icon-check'></span>",
        cancelButtonIcon: "<span class='default-icon-cross'></span>",
        onSet: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onScroll: Metro.noop,
        onDatePickerCreate: Metro.noop
    };

    Metro.datePickerSetup = function (options) {
        DatePickerDefaultConfig = $.extend({}, DatePickerDefaultConfig, options);
    };

    if (typeof window["metroDatePickerSetup"] !== undefined) {
        Metro.datePickerSetup(window["metroDatePickerSetup"]);
    }

    Metro.Component('date-picker', {
        init: function( options, elem ) {
            this._super(elem, options, DatePickerDefaultConfig, {
                picker: null,
                isOpen: false,
                value: datetime(),
                locale: null,
                listTimer: {
                    day: null,
                    month: null,
                    year: null
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var date = datetime();

            if (o.distance < 1) {
                o.distance = 1;
            }

            if (Utils.isValue(element.val())) {
                o.value = element.val();
            }

            if (Utils.isValue(o.value)) {
                this.value = o.inputFormat ? Datetime.from(o.value, o.inputFormat, o.locale) : datetime(o.value);
            }

            if (Metro.locales[o.locale] === undefined) {
                o.locale = METRO_LOCALE;
            }

            this.locale = Metro.locales[o.locale]['calendar'];

            if (o.minYear === null) {
                o.minYear = date.year() - o.defaultYearDistance;
            }

            if (o.maxYear === null) {
                o.maxYear = date.year() + o.defaultYearDistance;
            }

            this._createStructure();
            this._createEvents();
            this._set();

            this._fireEvent("datepicker-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var picker, month, day, year, i, j;
            var dateWrapper, selectWrapper, selectBlock, actionBlock;

            var id = Utils.elementId("datepicker");

            picker = $("<div>").attr("id", id).addClass("wheel-picker date-picker " + element[0].className).addClass(o.clsPicker);

            picker.insertBefore(element);
            element.appendTo(picker);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(picker);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            dateWrapper = $("<div>").addClass("date-wrapper").appendTo(picker);

            if (o.month === true) {
                month = $("<div>").addClass("month").addClass(o.clsPart).addClass(o.clsMonth).appendTo(dateWrapper);
            }
            if (o.day === true) {
                day = $("<div>").addClass("day").addClass(o.clsPart).addClass(o.clsDay).appendTo(dateWrapper);
            }
            if (o.year === true) {
                year = $("<div>").addClass("year").addClass(o.clsPart).addClass(o.clsYear).appendTo(dateWrapper);
            }

            selectWrapper = $("<div>").addClass("select-wrapper").appendTo(picker);

            selectBlock = $("<div>").addClass("select-block").appendTo(selectWrapper);

            if (o.month === true) {
                month = $("<ul>").addClass("sel-month").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
                for (i = 0; i < 12; i++) {
                    $("<li>").addClass("js-month-"+i+" js-month-real-"+this.locale['months'][i].toLowerCase()).html(this.locale['months'][i]).data("value", i).appendTo(month);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
            }

            if (o.day === true) {
                day = $("<ul>").addClass("sel-day").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(day);
                for (i = 0; i < 31; i++) {
                    $("<li>").addClass("js-day-"+i+" js-day-real-"+(i+1)).html(i + 1).data("value", i + 1).appendTo(day);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(day);
            }

            if (o.year === true) {
                year = $("<ul>").addClass("sel-year").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(year);
                for (i = o.minYear, j = 0; i <= o.maxYear; i++, j++) {
                    $("<li>").addClass("js-year-"+ j + " js-year-real-" + i).html(i).data("value", i).appendTo(year);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(year);
            }

            selectBlock.height((o.distance * 2 + 1) * 40);

            actionBlock = $("<div>").addClass("action-block").appendTo(selectWrapper);
            $("<button>").attr("type", "button").addClass("button action-ok").addClass(o.clsButton).addClass(o.clsOkButton).html(o.okButtonIcon).appendTo(actionBlock);
            $("<button>").attr("type", "button").addClass("button action-cancel").addClass(o.clsButton).addClass(o.clsCancelButton).html(o.cancelButtonIcon).appendTo(actionBlock);


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    picker.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.prop("disabled")) {
                picker.addClass("disabled");
            }

            this.picker = picker;
        },

        _createEvents: function(){
            var that = this, o = this.options;
            var picker = this.picker;

            picker.on(Metro.events.start, ".select-block ul", function(e){

                if (e.changedTouches) {
                    return ;
                }

                var target = this;
                var pageY = Utils.pageXY(e).y;

                $(document).on(Metro.events.move, function(e){

                    target.scrollTop -= o.scrollSpeed * (pageY  > Utils.pageXY(e).y ? -1 : 1);

                    pageY = Utils.pageXY(e).y;
                }, {ns: picker.attr("id")});

                $(document).on(Metro.events.stop, function(){
                    $(document).off(Metro.events.move, {ns: picker.attr("id")});
                    $(document).off(Metro.events.stop, {ns: picker.attr("id")});
                }, {ns: picker.attr("id")});
            });

            picker.on(Metro.events.click, function(e){
                if (that.isOpen === false) that.open();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-ok", function(e){
                var m, d, y;
                var sm = picker.find(".sel-month li.active"),
                    sd = picker.find(".sel-day li.active"),
                    sy = picker.find(".sel-year li.active");

                m = sm.length === 0 ? that.value.getMonth() : sm.data("value");
                d = sd.length === 0 ? that.value.getDate() : sd.data("value");
                y = sy.length === 0 ? that.value.getFullYear() : sy.data("value");

                that.value = datetime(y, m, d);
                that._correct();
                that._set();

                that.close();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-cancel", function(e){
                that.close();
                e.stopPropagation();
            });

            var scrollLatency = 150;
            $.each(["month", "day", "year"], function(){
                var part = this, list = picker.find(".sel-"+part);

                list.on("scroll", function(){
                    if (that.isOpen) {
                        if (that.listTimer[part]) {
                            clearTimeout(that.listTimer[part]);
                            that.listTimer[part] = null;
                        }

                        if (!that.listTimer[part]) that.listTimer[part] = setTimeout(function () {

                            var target, targetElement, scrollTop;

                            that.listTimer[part] = null;

                            target = Math.round((Math.ceil(list.scrollTop()) / 40));

                            targetElement = list.find(".js-" + part + "-" + target);
                            scrollTop = targetElement.position().top - (o.distance * 40);

                            list.find(".active").removeClass("active");

                            list[0].scrollTop = scrollTop;
                            targetElement.addClass("active");
                            Utils.exec(o.onScroll, [targetElement, list, picker], list[0]);

                        }, scrollLatency);
                    }
                })
            });
        },

        _correct: function(){
            var m = this.value.month(),
                d = this.value.day(),
                y = this.value.year();

            this.value = datetime(y, m, d);
        },

        _set: function(){
            var element = this.element, o = this.options;
            var picker = this.picker;
            var m = this.locale['months'][this.value.month()],
                d = this.value.day(),
                y = this.value.year();

            if (o.month === true) {
                picker.find(".month").html(m);
            }
            if (o.day === true) {
                picker.find(".day").html(d);
            }
            if (o.year === true) {
                picker.find(".year").html(y);
            }

            element.val(this.value.format(o.format, o.locale)).trigger("change");

            this._fireEvent("set", {
                value: this.value.val(),
                elementValue: element.val(),
                picker: picker
            })
        },

        open: function(){
            var o = this.options;
            var picker = this.picker;
            var m = this.value.month(), d = this.value.day() - 1, y = this.value.year();
            var m_list, d_list, y_list;
            var select_wrapper = picker.find(".select-wrapper");
            var select_wrapper_in_viewport, select_wrapper_rect;

            select_wrapper.parent().removeClass("for-top for-bottom");
            select_wrapper.show(0);
            picker.find("li").removeClass("active");

            select_wrapper_in_viewport = Utils.inViewport(select_wrapper[0]);
            select_wrapper_rect = Utils.rect(select_wrapper[0]);

            if (!select_wrapper_in_viewport && select_wrapper_rect.top > 0) {
                select_wrapper.parent().addClass("for-bottom");
            }

            if (!select_wrapper_in_viewport && select_wrapper_rect.top < 0) {
                select_wrapper.parent().addClass("for-top");
            }

            if (o.month === true) {
                m_list = picker.find(".sel-month");
                m_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: m_list.find("li.js-month-" + m).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }
            if (o.day === true) {
                d_list = picker.find(".sel-day");
                d_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: d_list.find("li.js-day-" + d).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }
            if (o.year === true) {
                y_list = picker.find(".sel-year");
                y_list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: y_list.find("li.js-year-real-" + y).addClass("active").position().top - (40 * o.distance)
                        },
                        dur: 100
                    });
            }

            this.isOpen = true;

            this._fireEvent("open", {
                value: this.value.val(),
                picker: picker
            })

        },

        close: function(){
            var picker = this.picker;
            picker.find(".select-wrapper").hide(0);
            this.isOpen = false;

            this._fireEvent("close", {
                value: this.value.val(),
                picker: picker
            });
        },

        val: function(value){
            var o = this.options;

            if (!Utils.isValue(value)) {
                return this.element.val();
            }

            this.value = o.inputFormat ? Datetime.from(value, o.inputFormat, o.locale) : datetime(value);

            this._set();
        },

        date: function(t, f){
            if (t === undefined) {
                return this.value.val();
            }

            try {
                this.value = Datetime.from(t, f, this.options.locale);
                this._set();
            } catch (e) {
                return false;
            }
        },

        i18n: function(locale){
            var element = this.element, o = this.options;
            var month, i;

            o.locale = locale ? locale : element.attr("data-locale");
            this.locale = Metro.locales[o.locale]['calendar'];

            if (o.month === true) {
                month =  element.closest(".date-picker").find(".sel-month").html("");
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
                for (i = 0; i < 12; i++) {
                    $("<li>").addClass("js-month-"+i+" js-month-real-"+this.locale['months'][i].toLowerCase()).html(this.locale['months'][i]).data("value", i).appendTo(month);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(month);
            }

            this._set();
        },


        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attr, newValue){
            switch (attr) {
                case "disabled": this.toggleState(); break;
                case "data-value": this.val(newValue); break;
                case "data-locale": this.i18n(newValue); break;
                case "data-format":
                    this.options.format = newValue;
                    this._set();
                    break;
            }
        },

        destroy: function(){
            var element = this.element, picker = this.picker;

            $.each(["moth", "day", "year"], function(){
                picker.find(".sel-"+this).off("scroll");
            });

            picker.off(Metro.events.start, ".select-block ul");
            picker.off(Metro.events.click);
            picker.off(Metro.events.click, ".action-ok");
            picker.off(Metro.events.click, ".action-cancel");

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $.each($(".date-picker"), function(){
            $(this).find("input").each(function(){
                Metro.getPlugin(this, "datepicker").close();
            });
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DialogDefaultConfig = {
        dialogDeferred: 0,
        closeButton: false,
        leaveOverlayOnClose: false,
        toTop: false,
        toBottom: false,
        locale: METRO_LOCALE,
        title: "",
        content: "",
        actions: {},
        actionsAlign: "right",
        defaultAction: true,
        overlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        overlayClickClose: false,
        width: '480',
        height: 'auto',
        shadow: true,
        closeAction: true,
        clsDialog: "",
        clsTitle: "",
        clsContent: "",
        clsAction: "",
        clsDefaultAction: "",
        clsOverlay: "",
        autoHide: 0,
        removeOnClose: false,
        show: false,

        _runtime: false,

        onShow: Metro.noop,
        onHide: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onDialogCreate: Metro.noop
    };

    Metro.dialogSetup = function (options) {
        DialogDefaultConfig = $.extend({}, DialogDefaultConfig, options);
    };

    if (typeof window["metroDialogSetup"] !== undefined) {
        Metro.dialogSetup(window["metroDialogSetup"]);
    }

    Metro.Component('dialog', {
        _counter: 0,

        init: function( options, elem ) {
            this._super(elem, options, DialogDefaultConfig, {
                interval: null,
                overlay: null,
                id: Utils.elementId("dialog")
            });

            return this;
        },

        _create: function(){
            var o = this.options;
            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];
            this._build();
        },

        _build: function(){
            var that = this, element = this.element, o = this.options;
            var body = $("body");
            var overlay;

            element.addClass("dialog");

            if (o.shadow === true) {
                element.addClass("shadow-on");
            }

            if (o.title !== "") {
                this.setTitle(o.title);
            }

            if (o.content !== "") {
                this.setContent(o.content);
            }

            if (o.defaultAction === true || (o.actions !== false && typeof o.actions === 'object' && Utils.objectLength(o.actions) > 0)) {
                var buttons = element.find(".dialog-actions");
                var button;

                if (buttons.length === 0) {
                    buttons = $("<div>").addClass("dialog-actions").addClass("text-"+o.actionsAlign).appendTo(element);
                }

                if (o.defaultAction === true && (Utils.objectLength(o.actions) === 0 && element.find(".dialog-actions > *").length === 0)) {
                    button = $("<button>").addClass("button js-dialog-close").addClass(o.clsDefaultAction).html(this.locale["buttons"]["ok"]);
                    button.appendTo(buttons);
                }

                if (Utils.isObject(o.actions)) $.each(Utils.isObject(o.actions), function(){
                    var item = this;
                    button = $("<button>").addClass("button").addClass(item.cls).html(item.caption);
                    if (item.onclick !== undefined) button.on(Metro.events.click, function(){
                        Utils.exec(item.onclick, [element]);
                    });
                    button.appendTo(buttons);
                });
            }

            if (o.overlay === true) {
                overlay  = this._overlay();
                this.overlay = overlay;
            }

            if (o.closeAction === true) {
                element.on(Metro.events.click, ".js-dialog-close", function(){
                    that.close();
                });
            }

            var closer = element.find("closer");
            if (closer.length === 0) {
                closer = $("<span>").addClass("button square closer js-dialog-close");
                closer.appendTo(element);
            }
            if (o.closeButton !== true) {
                closer.hide();
            }

            element.css({
                width: o.width,
                height: o.height,
                visibility: "hidden",
                top: '100%',
                left: ( $(window).width() - element.outerWidth() ) / 2
            });

            element.addClass(o.clsDialog);
            element.find(".dialog-title").addClass(o.clsTitle);
            element.find(".dialog-content").addClass(o.clsContent);
            element.find(".dialog-actions").addClass(o.clsAction);

            element.appendTo(body);

            if (o.show) {
                this.open();
            }

            $(window).on(Metro.events.resize, function(){
                that.setPosition();
            }, {ns: this.id});

            this._fireEvent("dialog-create", {
                element: element
            });
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Metro.colors.toRGBA(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        hide: function(callback){
            var element = this.element, o = this.options;
            var timeout = 0;
            if (o.onHide !== Metro.noop) {
                timeout = 500;

                this._fireEvent("hide");
            }
            setTimeout(function(){
                Utils.exec(callback, null, element[0]);
                element.css({
                    visibility: "hidden",
                    top: "100%"
                });
            }, timeout);
        },

        show: function(callback){
            var element = this.element;
            this.setPosition();
            element.css({
                visibility: "visible"
            });

            this._fireEvent("show");

            Utils.exec(callback, null, element[0]);
        },

        setPosition: function(){
            var element = this.element, o = this.options;
            var top, bottom;
            if (o.toTop !== true && o.toBottom !== true) {
                top = ( $(window).height() - element.outerHeight() ) / 2;
                if (top < 0) {
                    top = 0;
                }
                bottom = "auto";
            } else {
                if (o.toTop === true) {
                    top = 0;
                    bottom = "auto";
                }
                if (o.toTop !== true && o.toBottom === true) {
                    bottom = 0;
                    top = "auto";
                }
            }
            element.css({
                top: top,
                bottom: bottom,
                left: ( $(window).width() - element.outerWidth() ) / 2
            });
        },

        setContent: function(c){
            var element = this.element;
            var content = element.find(".dialog-content");
            if (content.length === 0) {
                content = $("<div>").addClass("dialog-content");
                content.appendTo(element);
            }

            if (!Utils.isQ(c) && Utils.isFunc(c)) {
                c = Utils.exec(c);
            }

            if (Utils.isQ(c)) {
                c.appendTo(content);
            } else {
                content.html(c);
            }
        },

        setTitle: function(t){
            var element = this.element;
            var title = element.find(".dialog-title");
            if (title.length === 0) {
                title = $("<div>").addClass("dialog-title");
                title.appendTo(element);
            }
            title.html(t);
        },

        close: function(){
            var that = this, element = this.element, o = this.options;

            if (!Utils.bool(o.leaveOverlayOnClose)) {
                $('body').find('.overlay').remove();
            }

            this.hide(function(){
                element.data("open", false);

                that._fireEvent("close")

                if (o.removeOnClose === true) {
                    element.remove();
                }
            });
        },

        open: function(){
            var that = this, element = this.element, o = this.options;

            if (o.overlay === true && $(".overlay").length === 0) {
                this.overlay.appendTo($("body"));
                if (o.overlayClickClose === true) {
                    this.overlay.on(Metro.events.click, function(){
                        that.close();
                    });
                }
            }

            this.show(function(){

                that._fireEvent("open");

                element.data("open", true);
                if (parseInt(o.autoHide) > 0) {
                    setTimeout(function(){
                        that.close();
                    }, parseInt(o.autoHide));
                }
            });
        },

        toggle: function(){
            var element = this.element;
            if (element.data('open')) {
                this.close();
            } else {
                this.open();
            }
        },

        isOpen: function(){
            return this.element.data('open') === true;
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".js-dialog-close");
            element.find(".button").off(Metro.events.click);
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });

    Metro.dialog = {
        isDialog: function(el){
            return Utils.isMetroObject(el, "dialog");
        },

        open: function(el, content, title){
            if (!this.isDialog(el)) {
                return false;
            }
            var dialog = Metro.getPlugin(el, "dialog");
            if (title !== undefined) {
                dialog.setTitle(title);
            }
            if (content !== undefined) {
                dialog.setContent(content);
            }
            dialog.open();
        },

        close: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").close();
        },

        toggle: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").toggle();
        },

        isOpen: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            Metro.getPlugin($(el)[0], "dialog").isOpen();
        },

        remove: function(el){
            if (!this.isDialog(el)) {
                return false;
            }
            var dialog = Metro.getPlugin($(el)[0], "dialog");
            dialog.options.removeOnClose = true;
            dialog.close();
        },

        create: function(options){
            var dlg;

            dlg = $("<div>").appendTo($("body"));

            var dlg_options = $.extend({}, {
                show: true,
                closeAction: true,
                removeOnClose: true
            }, (options !== undefined ? options : {}));

            dlg_options._runtime = true;

            return Metro.makePlugin(dlg, "dialog", dlg_options);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DonutDefaultConfig = {
        donutDeferred: 0,
        size: 100,
        hole: .8,
        value: 0,
        background: "#ffffff",
        color: "",
        stroke: "#d1d8e7",
        fill: "#49649f",
        fontSize: 0,
        total: 100,
        cap: "%",
        showText: true,
        showValue: false,
        animate: 0,
        onChange: Metro.noop,
        onDrawValue: function(v){return v},
        onDonutCreate: Metro.noop
    };

    Metro.donutSetup = function (options) {
        DonutDefaultConfig = $.extend({}, DonutDefaultConfig, options);
    };

    if (typeof window["metroDonutSetup"] !== undefined) {
        Metro.donutSetup(window["metroDonutSetup"]);
    }

    Metro.Component('donut', {
        init: function( options, elem ) {
            this._super(elem, options, DonutDefaultConfig, {
                value: 0,
                animation_change_interval: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            element.addClass("donut");

            this._setElementSize();
            this._draw();
            this._addEvents();
            this.val(o.value);

            this._fireEvent("donut-create", {
                element: element
            });
        },

        _setElementSize: function(){
            var element = this.element, o = this.options;
            var width = o.size;

            element.css({
                width: width,
                background: o.background
            });

            element.css({
                height: element.width()
            });
        },

        _draw: function(){
            var element = this.element, o = this.options;
            var html = "";
            var radius = element.width() / 2
            var r = radius  * (1 - (1 - o.hole) / 2);
            var width = radius * (1 - o.hole);
            var transform = 'rotate(-90 ' + radius + ',' + radius + ')';
            var fontSize = o.fontSize === 0 ? r * o.hole * 0.6 : o.fontSize;

            html += "<svg>";
            html += "   <circle class='donut-back' r='"+(r)+"px' cx='"+(radius)+"px' cy='"+(radius)+"px' transform='"+(transform)+"' fill='none' stroke='"+(o.stroke)+"' stroke-width='"+(width)+"'/>";
            html += "   <circle class='donut-fill' r='"+(r)+"px' cx='"+(radius)+"px' cy='"+(radius)+"px' transform='"+(transform)+"' fill='none' stroke='"+(o.fill)+"' stroke-width='"+(width)+"'/>";

            if (o.showText === true)
                html += "   <text class='donut-title' x='"+(radius)+"px' y='"+(radius)+"px' dy='"+(fontSize/3)+"px' text-anchor='middle' fill='"+(o.color !== "" ? o.color: o.fill)+"' font-size='"+(fontSize)+"px'></text>";

            html += "</svg>";

            element.html(html);
        },

        _addEvents: function(){
            var that = this;

            $(window).on("resize", function(){
                that._setElementSize();
                that._draw();
                that.val(that.value);
            })
        },

        _setValue: function(v){
            var element = this.element, o = this.options;

            var fill = element.find(".donut-fill");
            var title = element.find(".donut-title");
            var radius = element.width() / 2
            var r = radius  * (1 - (1 - o.hole) / 2);
            var circumference = Math.round(2 * Math.PI * r);
            var title_value = (o.showValue ? v : Utils.percent(o.total, v, true))/*  + (o.cap)*/;
            var fill_value = Math.round(((+v * circumference) / o.total));// + ' ' + circumference;

            var sda = fill.attr("stroke-dasharray");
            if (typeof sda === "undefined") {
                sda = 0;
            } else {
                sda = +sda.split(" ")[0];
            }
            var delta = fill_value - sda;

            fill.animate({
                draw: function(t, p){
                    $(this).attr("stroke-dasharray", (sda + delta * p ) + ' ' + circumference);
                },
                dur: o.animate
            })

            title.html(Metro.utils.exec(o.onDrawValue, [title_value + o.cap]));

            // title.animate({
            //     draw: {
            //         innerHTML: title_value
            //     },
            //     dur: o.animate,
            //     onFrame: function(){
            //         this.innerHTML = Metro.utils.exec(o.onDrawValue, [this.innerHTML + o.cap]);
            //     }
            // });
        },

        val: function(v){
            var o = this.options;

            if (v === undefined) {
                return this.value
            }

            if (parseInt(v) < 0 || parseInt(v) > o.total) {
                return false;
            }

            this._setValue(v);

            this.value = v;

            this._fireEvent("change", {
                value: this.value
            });
        },

        setColor: function(obj){
            var validKeys = ["background, fill, stroke, color"]

            $.each(obj, function(key, val){
                if (validKeys.indexOf(key) !== -1) {
                    this.options[key] = val
                }
            })

            this._draw();
            this.val(this.value);

            return this;
        },

        changeValue: function(){
            this.val(this.element.attr("data-value"));
        },

        changeAttribute: function(attr, val){
            switch (attr) {
                case "data-value": this.changeValue(); break;
                case "data-background": this.setColor({"background": val}); break;
                case "data-fill": this.setColor({"fill": val}); break;
                case "data-stroke": this.setColor({"stroke": val}); break;
                case "data-color": this.setColor({"color": val}); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

/* eslint-disable */
(function(Metro, $) {
    'use strict';

    var DoubleSelectBoxDefaultConfig = {
        height: "auto",
        multiSelect: false,

        moveRightIcon: "<span>&rsaquo;</span>",
        moveRightAllIcon: "<span>&raquo;</span>",
        moveLeftIcon: "<span>&lsaquo;</span>",
        moveLeftAllIcon: "<span>&laquo;</span>",

        clsBox: "",
        clsMoveButton: "",
        clsMoveRightButton: "",
        clsMoveRightAllButton: "",
        clsMoveLeftButton: "",
        clsMoveLeftAllButton: "",
        clsListLeft: "",
        clsListRight: "",

        onDoubleSelectBoxCreate: Metro.noop
    };

    Metro.doubleSelectBoxSetup = function (options) {
        DoubleSelectBoxDefaultConfig = $.extend({}, DoubleSelectBoxDefaultConfig, options);
    };

    if (typeof window["metroDoubleSelectBoxSetup"] !== undefined) {
        Metro.doubleSelectBoxSetup(window["metroDoubleSelectBoxSetup"]);
    }

    Metro.Component('double-select-box', {
        init: function( options, elem ) {
            this._super(elem, options, DoubleSelectBoxDefaultConfig, {
                // define instance vars here
                select1: null,
                select2: null,
                list1: null,
                list2: null
            });
            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;

            if (element.children("select").length !== 2) {
                throw new Error("Component DoubleSelectBox required two select elements!")
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent('double-select-box-create');
        },

        _drawList: function(){
            var that = this;

            this.list1.clear();
            this.select1.find("option").each(function(i, option){
                var $op = $(option);
                var html = $op.attr("data-template") ? $op.attr("data-template").replace(/\$1/g, $op.text()) : $op.text();

                that.list1.append(
                    $("<li>").html(html).attr("data-value", option.value).data("option", option)
                )
            });

            this.list2.clear();
            this.select2.find("option").each(function(i, option){
                var $op = $(option);
                var html = $op.attr("data-template") ? $op.attr("data-template").replace(/\$1/g, $op.text()) : $op.text();

                that.list2.append(
                    $("<li>").html(html).attr("data-value", option.value).data("option", option)
                )
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var selects = element.children("select");
            var select1 = selects.eq(0);
            var select2 = selects.eq(1);
            var controls = $("<div>").addClass("controls").insertBefore(select2);
            var list1, list2;

            element.addClass("double-select-box").addClass(o.clsBox).css({
                height: o.height
            });

            selects.prop("multiple", true);

            controls.append(
                $([
                    $("<button>").attr("type", "button").addClass("button --move-right").addClass(o.clsMoveButton).addClass(o.clsMoveRightButton).html(o.moveRightIcon),
                    $("<button>").attr("type", "button").addClass("button --move-right-all").addClass(o.clsMoveButton).addClass(o.clsMoveRightAllButton).html(o.moveRightAllIcon),
                    $("<button>").attr("type", "button").addClass("button --move-left-all").addClass(o.clsMoveButton).addClass(o.clsMoveLeftAllButton).html(o.moveLeftAllIcon),
                    $("<button>").attr("type", "button").addClass("button --move-left").addClass(o.clsMoveButton).addClass(o.clsMoveLeftButton).html(o.moveLeftIcon),
                ])
            )

            list1 = $("<ul>").addClass("--list1").addClass(o.clsListLeft).insertBefore(select1);
            list2 = $("<ul>").addClass("--list2").addClass(o.clsListRight).insertBefore(select2);


            this.select1 = select1;
            this.select2 = select2;
            this.list1 = list1;
            this.list2 = list2;

            this._drawList();
        },

        _moveItems: function(items, targets){
            $.each(items, function(){
                var $item = $(this);
                var option = $item.data('option');

                $(option).appendTo(targets[0]);
                $item.removeClass("active").appendTo(targets[1]);
            })
        },

        _move: function(dir, scope){
            var that = this;

            if (scope === 'selected') {
                if (dir === 'ltr') { // left to right
                    that._moveItems(this.list1.find("li.active"), [that.select2, that.list2]);
                } else {
                    that._moveItems(this.list2.find("li.active"), [that.select1, that.list1]);
                }
            } else {
                if (dir === 'ltr') { // left to right
                    that._moveItems(this.list1.find("li"), [that.select2, that.list2]);
                } else {
                    that._moveItems(this.list2.find("li"), [that.select1, that.list1]);
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var items = element.find("li");

            items.on("click", function(){
                var $el = $(this);

                if (o.multiSelect === false) {
                    that.list1.find("li").removeClass("active");
                    that.list2.find("li").removeClass("active");
                }

                $el.addClass("active");
            });

            items.on("dblclick", function(){
                var $el = $(this);
                var dir = $el.parent().hasClass("--list1") ? 'ltr' : 'rtl';
                var scope = 'selected';

                that.list1.find("li").removeClass("active");
                that.list2.find("li").removeClass("active");

                $el.addClass("active");

                that._move(dir, scope);
            });

            element.on("click", "button", function(){
                var btn = $(this)
                if (btn.hasClass("--move-right")) {
                    that._move('ltr', 'selected');
                } else if (btn.hasClass("--move-right-all")) {
                    that._move('ltr', 'all');
                } else if (btn.hasClass("--move-left")) {
                    that._move('rtl', 'selected');
                } else if (btn.hasClass("--move-left-all")) {
                    that._move('rtl', 'all');
                } else {
                    throw new Error("Pressed unregistered button!")
                }
            });
        },

        changeAttribute: function(attr, newValue){
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));
/* eslint-enable */


(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DoubleSliderDefaultConfig = {
        doublesliderDeferred: 0,
        roundValue: true,
        min: 0,
        max: 100,
        accuracy: 0,
        showMinMax: false,
        minMaxPosition: Metro.position.TOP,
        valueMin: null,
        valueMax: null,
        hint: false,
        hintAlways: false,
        hintPositionMin: Metro.position.TOP,
        hintPositionMax: Metro.position.TOP,
        hintMaskMin: "$1",
        hintMaskMax: "$1",
        target: null,
        size: 0,

        clsSlider: "",
        clsBackside: "",
        clsComplete: "",
        clsMarker: "",
        clsMarkerMin: "",
        clsMarkerMax: "",
        clsHint: "",
        clsHintMin: "",
        clsHintMax: "",
        clsMinMax: "",
        clsMin: "",
        clsMax: "",

        onStart: Metro.noop,
        onStop: Metro.noop,
        onMove: Metro.noop,
        onChange: Metro.noop,
        onChangeValue: Metro.noop,
        onFocus: Metro.noop,
        onBlur: Metro.noop,
        onDoubleSliderCreate: Metro.noop
    };

    Metro.doubleSliderSetup = function (options) {
        DoubleSliderDefaultConfig = $.extend({}, DoubleSliderDefaultConfig, options);
    };

    if (typeof window["metroDoubleSliderSetup"] !== undefined) {
        Metro.doubleSliderSetup(window["metroDoubleSliderSetup"]);
    }

    Metro.Component('double-slider', {
        init: function( options, elem ) {
            this._super(elem, options, DoubleSliderDefaultConfig, {
                slider: null,
                valueMin: null,
                valueMax: null,
                keyInterval: false,
                id: Utils.elementId("slider")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.valueMin = Utils.isValue(o.valueMin) ? +o.valueMin : +o.min;
            this.valueMax = Utils.isValue(o.valueMax) ? +o.valueMax : +o.max;

            this._createSlider();
            this._createEvents();

            this.val(this.valueMin, this.valueMax);

            this._fireEvent("double-slider-create", {
                element: element
            })
        },

        _createSlider: function(){
            var element = this.element, o = this.options;
            var slider_wrapper = $("<div>").addClass("slider-wrapper");
            var slider = $("<div>").addClass("slider").addClass(o.clsSlider).addClass(this.elem.className);
            var backside = $("<div>").addClass("backside").addClass(o.clsBackside);
            var complete = $("<div>").addClass("complete").addClass(o.clsComplete);
            var markerMin = $("<button>").attr("type", "button").addClass("marker marker-min").addClass(o.clsMarker).addClass(o.clsMarkerMin);
            var markerMax = $("<button>").attr("type", "button").addClass("marker marker-max").addClass(o.clsMarker).addClass(o.clsMarkerMax);
            var hintMin = $("<div>").addClass("hint hint-min").addClass(o.hintPositionMin + "-side").addClass(o.clsHint).addClass(o.clsHintMin);
            var hintMax = $("<div>").addClass("hint hint-max").addClass(o.hintPositionMax + "-side").addClass(o.clsHint).addClass(o.clsHintMax);
            var i;

            if (o.size > 0) {
                slider.outerWidth(o.size);
            }

            slider.insertBefore(element);
            element.appendTo(slider);
            slider_wrapper.insertBefore(slider);
            slider.appendTo(slider_wrapper);

            backside.appendTo(slider);
            complete.appendTo(slider);
            markerMin.appendTo(slider);
            markerMax.appendTo(slider);
            hintMin.appendTo(markerMin);
            hintMax.appendTo(markerMax);

            if (o.hintAlways === true) {
                $([hintMin, hintMax]).css({
                    display: "block"
                }).addClass("permanent-hint");
            }

            if (o.showMinMax === true) {
                var min_max_wrapper = $("<div>").addClass("slider-min-max").addClass(o.clsMinMax);
                $("<span>").addClass("slider-text-min").addClass(o.clsMin).html(o.min).appendTo(min_max_wrapper);
                $("<span>").addClass("slider-text-max").addClass(o.clsMax).html(o.max).appendTo(min_max_wrapper);
                if (o.minMaxPosition === Metro.position.TOP) {
                    min_max_wrapper.insertBefore(slider);
                } else {
                    min_max_wrapper.insertAfter(slider);
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    slider.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.slider = slider;
        },

        _createEvents: function(){
            var that = this, slider = this.slider, o = this.options;
            var marker = slider.find(".marker");

            marker.on(Metro.events.startAll, function(){
                var _marker = $(this);
                var hint = _marker.find(".hint");
                if (o.hint === true && o.hintAlways !== true) {
                    hint.fadeIn(300);
                }

                $(document).on(Metro.events.moveAll, function(e){
                    that._move(e);
                    that._fireEvent("move", {
                        min: that.valueMin,
                        max: that.valueMax
                    });

                }, {ns: that.id});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});

                    if (o.hintAlways !== true) {
                        hint.fadeOut(300);
                    }

                    that._fireEvent("stop", {
                        min: that.valueMin,
                        max: that.valueMax
                    });
                }, {ns: that.id});

                that._fireEvent("start", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            marker.on(Metro.events.focus, function(){
                that._fireEvent("focus", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            marker.on(Metro.events.blur, function(){
                that._fireEvent("blur", {
                    min: that.valueMin,
                    max: that.valueMax
                });
            });

            $(window).on(Metro.events.resize,function(){
                that.val(that.valueMin, that.valueMax);
            }, {ns: that.id});
        },

        _convert: function(v, how){
            var slider = this.slider, o = this.options;
            var length = slider.outerWidth() - slider.find(".marker").outerWidth();
            switch (how) {
                case "pix2prc": return ( v * 100 / length );
                case "pix2val": return ( this._convert(v, 'pix2prc') * ((o.max - o.min) / 100) + o.min );
                case "val2prc": return ( (v - o.min)/( (o.max - o.min) / 100 )  );
                case "prc2pix": return ( v / ( 100 / length ));
                case "val2pix": return ( this._convert(this._convert(v, 'val2prc'), 'prc2pix') );
            }

            return 0;
        },

        _correct: function(value){
            var res = value;
            var accuracy  = this.options.accuracy;
            var min = this.options.min, max = this.options.max;
            var _dec = function(v){
                return v % 1 === 0 ? 0 : v.toString().split(".")[1].length;
            };

            if (accuracy === 0 || isNaN(accuracy)) {
                return res;
            }

            res = Math.round(value/accuracy)*accuracy;

            if (res < min) {
                res = min;
            }

            if (res > max) {
                res = max;
            }

            return res.toFixed(_dec(accuracy));
        },

        _move: function(e){
            var target = $(e.target).closest(".marker");
            var isMin = target.hasClass("marker-min");
            var slider = this.slider;
            var offset = slider.offset(),
                marker_size = slider.find(".marker").outerWidth(),
                markerMin = slider.find(".marker-min"),
                markerMax = slider.find(".marker-max"),
                length = slider.outerWidth(),
                cPix, cStart, cStop;

            cPix = Utils.pageXY(e).x - offset.left - marker_size / 2;

            if (isMin) {
                cStart = 0;
                cStop = parseInt(markerMax.css("left")) - marker_size;
            } else {
                cStart = parseInt(markerMin.css("left")) + marker_size;
                cStop = length - marker_size;
            }

            if (cPix < cStart || cPix > cStop) {
                return ;
            }

            this[isMin ? "valueMin" : "valueMax"] = this._correct(this._convert(cPix, 'pix2val'));

            this._redraw();
        },

        _hint: function(){
            var that = this, o = this.options, slider = this.slider, hint = slider.find(".hint");

            hint.each(function(){
                var _hint = $(this);
                var isMin = _hint.hasClass("hint-min");
                var _mask = isMin ? o.hintMaskMin : o.hintMaskMax;
                var value = +(isMin ? that.valueMin : that.valueMax) || 0;
                _hint.text(_mask.replace("$1", value.toFixed(Utils.decCount(o.accuracy))))
            });
        },

        _value: function(){
            var element = this.element, o = this.options;
            var v1 = +this.valueMin || 0, v2 = +this.valueMax || 0;
            var value;

            if (o.roundValue) {
                v1 = v1.toFixed(Utils.decCount(o.accuracy));
                v2 = v2.toFixed(Utils.decCount(o.accuracy));
            }

            value = [v1, v2].join(", ");

            if (element[0].tagName === "INPUT") {
                element.val(value);
            }

            if (o.target !== null) {
                var target = $(o.target);
                if (target.length !== 0) {

                    $.each(target, function(){
                        var t = $(this);
                        if (this.tagName === "INPUT") {
                            t.val(value);
                        } else {
                            t.text(value);
                        }
                        t.trigger("change");
                    });
                }
            }

            this._fireEvent("change-value", {
                val: value
            });

            this._fireEvent("change", {
                val: value
            });
        },

        _marker: function(){
            var slider = this.slider;
            var markerMin = slider.find(".marker-min");
            var markerMax = slider.find(".marker-max");
            var complete = slider.find(".complete");
            var marker_size = parseInt(Utils.getStyleOne(markerMin, "width"));
            var slider_visible = Utils.isVisible(slider);

            if (slider_visible) {
                $([markerMin, markerMax]).css({
                    'margin-top': 0,
                    'margin-left': 0
                });
            }

            if (slider_visible) {
                markerMin.css('left', this._convert(this.valueMin, 'val2pix'));
                markerMax.css('left', this._convert(this.valueMax, 'val2pix'));
            } else {
                markerMin.css({
                    'left': (this._convert(this.valueMin, 'val2prc')) + "%",
                    'margin-top': this._convert(this.valueMin, 'val2prc') === 0 ? 0 : -1 * marker_size / 2
                });
                markerMax.css({
                    'left': (this._convert(this.valueMax, 'val2prc')) + "%",
                    'margin-top': this._convert(this.valueMax, 'val2prc') === 0 ? 0 : -1 * marker_size / 2
                });
            }

            complete.css({
                "left": this._convert(this.valueMin, 'val2pix'),
                "width": this._convert(this.valueMax, 'val2pix') - this._convert(this.valueMin, 'val2pix')
            });
        },

        _redraw: function(){
            this._marker();
            this._value();
            this._hint();
        },

        val: function(vMin, vMax){
            var o = this.options;

            if (!Utils.isValue(vMin) && !Utils.isValue(vMax)) {
                return [this.valueMin, this.valueMax];
            }

            if (vMin < o.min) vMin = o.min;
            if (vMax < o.min) vMax = o.min;

            if (vMin > o.max) vMin = o.max;
            if (vMax > o.max) vMax = o.max;

            this.valueMin = this._correct(vMin);
            this.valueMax = this._correct(vMax);

            this._redraw();
        },

        changeValue: function(){
            var element = this.element;
            var valMin = +element.attr("data-value-min");
            var valMax = +element.attr("data-value-max");
            this.val(valMin, valMax);
        },

        disable: function(){
            var element = this.element;
            element.data("disabled", true);
            element.parent().addClass("disabled");
        },

        enable: function(){
            var element = this.element;
            element.data("disabled", false);
            element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value-min": this.changeValue(); break;
                case "data-value-max": this.changeValue(); break;
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, slider = this.slider;
            var marker = slider.find(".marker");

            marker.off(Metro.events.startAll);
            marker.off(Metro.events.focus);
            marker.off(Metro.events.blur);
            marker.off(Metro.events.keydown);
            marker.off(Metro.events.keyup);
            slider.off(Metro.events.click);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DragItemsDefaultConfig = {
        dragitemsDeferred: 0,
        target: null,
        dragItem: "li",
        dragMarker: ".drag-item-marker",
        drawDragMarker: false,
        clsDragItemAvatar: "",
        clsDragItem: "",
        canDrag: true,
        onDragStartItem: Metro.noop,
        onDragMoveItem: Metro.noop,
        onDragDropItem: Metro.noop,
        onTarget: Metro.noop,
        onTargetIn: Metro.noop, //TODO
        onTargetOut: Metro.noop, //TODO
        onDragItemsCreate: Metro.noop
    };

    Metro.dragItemsSetup = function (options) {
        DragItemsDefaultConfig = $.extend({}, DragItemsDefaultConfig, options);
    };

    if (typeof window["metroDragItemsSetup"] !== undefined) {
        Metro.dragItemsSetup(window["metroDragItemsSetup"]);
    }

    Metro.Component('drag-items', {
        init: function( options, elem ) {
            this._super(elem, options, DragItemsDefaultConfig, {
                id: Utils.elementId("dragItems"),
                canDrag: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("drag-items-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("drag-items-target");

            if (o.drawDragMarker === true) {
                element.find(o.dragItem).each(function(){
                    $("<span>").addClass("drag-item-marker").appendTo(this);
                })
            }

            o.canDrag ? this.on() : this.off();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var doc = $.document(), body = $.body();
            var offset, shift = {top: 0, left: 0}, width, height;

            var move = function(e, avatar, dragItem){
                var x = Utils.pageXY(e).x, y = Utils.pageXY(e).y;
                var _top = y - shift.top;
                var _left = x - shift.left;

                avatar.css({
                    top: _top,
                    left: _left
                });

                var target = document.elementsFromPoint(x, y).filter(function(el){
                    return $(el).hasClass('drag-items-target');
                });

                if (target.length === 0) {
                    return;
                }

                that._fireEvent("target", {
                    target: target
                });

                var sibling = document.elementsFromPoint(x, y).filter(function(el){
                    var $el = $(el);
                    return $.matches(el, o.dragItem) && !$el.hasClass("dragged-item-avatar");
                })[0];

                if (!Utils.isValue(sibling)) {
                    dragItem.appendTo(target);
                } else {
                    var $sibling = $(sibling);
                    var $sibling_offset = $sibling.offset();
                    var offsetY = y - $sibling_offset.top;
                    var offsetX = x - $sibling_offset.left;
                    var side;
                    var dim = {w: $sibling.width(), h: $sibling.height()};

                    if (offsetX < dim.w / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
                        side = 'left';
                    } else if (offsetX > dim.w * 2 / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
                        side = 'right';
                    } else if (offsetX > dim.w / 3 && offsetX < dim.w * 2 / 3 && offsetY > dim.h / 2) {
                        side = 'bottom';
                    } else {
                        side = "top";
                    }

                    if (!$sibling.hasClass("dragged-item")) {
                        if (side === "top" || side === "left") {
                            dragItem.insertBefore($sibling);
                        } else {
                            dragItem.insertAfter($sibling);
                        }
                    }
                }
            };

            element.on(Metro.events.startAll, (o.drawDragMarker ? o.dragMarker : o.dragItem), function(e_start){
                var dragItem = $(e_start.target).closest(o.dragItem);
                var avatar;

                if (Utils.isRightMouse(e_start)) {
                    return ;
                }

                if (that.canDrag !== true) {
                    return ;
                }

                dragItem.addClass("dragged-item").addClass(o.clsDragItem);
                avatar = $("<div>").addClass("dragged-item-avatar").addClass(o.clsDragItemAvatar);
                offset = dragItem.offset();
                width = dragItem.width();
                height = dragItem.height();
                shift.top = Utils.pageXY(e_start).y - offset.top;
                shift.left = Utils.pageXY(e_start).x - offset.left;

                avatar.css({
                    top: offset.top,
                    left: offset.left,
                    width: width,
                    height: height
                }).appendTo(body);

                that._fireEvent("drag-start-item", {
                    dragItem: dragItem[0],
                    avatar: avatar[0]
                });

                doc.on(Metro.events.moveAll, function(e_move){

                    move(e_move, avatar, dragItem);

                    that._fireEvent("drag-move-item", {
                        dragItem: dragItem[0],
                        avatar: avatar[0]
                    });

                    e_move.preventDefault();

                }, {ns: that.id, passive: false});

                doc.on(Metro.events.stopAll, function(){

                    that._fireEvent("drag-drop-item", {
                        dragItem: dragItem[0],
                        avatar: avatar[0]
                    });

                    dragItem.removeClass("dragged-item").removeClass(o.clsDragItem);
                    avatar.remove();

                    doc.off(Metro.events.moveAll, {ns: that.id});
                    doc.off(Metro.events.stopAll, {ns: that.id});

                }, {ns: that.id});

                if (o.drawDragMarker) {
                    e_start.preventDefault();
                    e_start.stopPropagation();
                }
            });
        },

        on: function(){
            this.canDrag = true;
            this.element.find(".drag-item-marker").show();
        },

        off: function(){
            this.canDrag = false;
            this.element.find(".drag-item-marker").hide();
        },

        toggle: function(){
            this.canDrag = this.canDrag ? this.off() : this.on();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;
            var changeCanDrag = function(){
                o.canDtag = JSON.parse(element.attr("data-can-drag"));
                o.canDtag ? that.on() : that.off();
            };

            if (attributeName === "data-can-drag") {
                changeCanDrag();
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            element.off(Metro.events.startAll, (o.drawDragMarker ? o.dragMarker : o.dragItem));
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DraggableDefaultConfig = {
        dragContext: null,
        draggableDeferred: 0,
        dragElement: 'self',
        dragArea: "parent",
        timeout: 0,
        boundaryRestriction: true,
        onCanDrag: Metro.noop_true,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onDraggableCreate: Metro.noop
    };

    Metro.draggableSetup = function (options) {
        DraggableDefaultConfig = $.extend({}, DraggableDefaultConfig, options);
    };

    if (typeof window["metroDraggableSetup"] !== undefined) {
        Metro.draggableSetup(window["metroDraggableSetup"]);
    }

    Metro.Component('draggable', {
        init: function( options, elem ) {
            this._super(elem, options, DraggableDefaultConfig, {
                drag: false,
                move: false,
                backup: {
                    cursor: 'default',
                    zIndex: '0'
                },
                dragArea: null,
                dragElement: null,
                id: Utils.elementId("draggable")
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("draggable-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var offset = element.offset();
            var dragElement  = o.dragElement !== 'self' ? element.find(o.dragElement) : element;

            element.data("canDrag", true);

            this.dragElement = dragElement;

            dragElement[0].ondragstart = function(){return false;};

            element.css("position", "absolute");

            if (o.dragArea === 'document' || o.dragArea === 'window') {
                o.dragArea = "body";
            }

            setImmediate(function(){
                that.dragArea = o.dragArea === 'parent' ? element.parent() : $(o.dragArea);
                if (o.dragArea !== 'parent') {
                    element.appendTo(that.dragArea);
                    element.css({
                        top: offset.top,
                        left: offset.left
                    });
                }
            });

            if (!element.attr("id")) {
                element.attr("id", Utils.elementId("draggable"));
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var position = {
                x: 0,
                y: 0
            };

            this.dragElement.on(Metro.events.startAll, function(e){

                var coord = o.dragArea !== "parent" ? element.offset() : element.position(),
                    shiftX = Utils.pageXY(e).x - coord.left,
                    shiftY = Utils.pageXY(e).y - coord.top;

                var moveElement = function(e){
                    var top = Utils.pageXY(e).y - shiftY;
                    var left = Utils.pageXY(e).x - shiftX;

                    if (o.boundaryRestriction) {
                        if (top < 0) top = 0;
                        if (left < 0) left = 0;

                        if (top > that.dragArea.outerHeight() - element.outerHeight()) top = that.dragArea.outerHeight() - element.outerHeight();
                        if (left > that.dragArea.outerWidth() - element.outerWidth()) left = that.dragArea.outerWidth() - element.outerWidth();
                    }

                    position.y = top;
                    position.x = left;

                    element.css({
                        left: left,
                        top: top
                    });
                };


                if (element.data("canDrag") === false || Utils.exec(o.onCanDrag, [element]) !== true) {
                    return ;
                }

                if (Metro.isTouchable === false && e.which !== 1) {
                    return ;
                }

                that.drag = true;

                that.backup.cursor = element.css("cursor");
                that.backup.zIndex = element.css("z-index");

                element.addClass("draggable");

                moveElement(e);

                that._fireEvent("drag-start", {
                    position: position,
                    context: o.dragContext
                });

                $(document).on(Metro.events.moveAll, function(e){
                    e.preventDefault();
                    moveElement(e);

                    that._fireEvent("drag-move", {
                        position: position,
                        context: o.dragContext
                    });

                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    // element.css({
                    //     cursor: that.backup.cursor,
                    //     zIndex: that.backup.zIndex
                    // });
                    element.removeClass("draggable");

                    if (that.drag) {
                        $(document).off(Metro.events.moveAll, {ns: that.id});
                        $(document).off(Metro.events.stopAll, {ns: that.id});
                    }

                    that.drag = false;
                    that.move = false;

                    that._fireEvent("drag-stop", {
                        position: position,
                        context: o.dragContext
                    });

                }, {ns: that.id});
            });
        },

        off: function(){
            this.element.data("canDrag", false);
        },

        on: function(){
            this.element.data("canDrag", true);
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName, newValue){
        },

        destroy: function(){
            var element = this.element;
            this.dragElement.off(Metro.events.startAll);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var DropdownDefaultConfig = {
        dropdownDeferred: 0,
        dropFilter: null,
        toggleElement: null,
        noClose: false,
        duration: 50,
        checkDropUp: false,
        dropUp: false,
        onDrop: Metro.noop,
        onUp: Metro.noop,
        onDropdownCreate: Metro.noop
    };

    Metro.dropdownSetup = function (options) {
        DropdownDefaultConfig = $.extend({}, DropdownDefaultConfig, options);
    };

    if (typeof window["metroDropdownSetup"] !== undefined) {
        Metro.dropdownSetup(window["metroDropdownSetup"]);
    }

    Metro.Component('dropdown', {
        init: function( options, elem ) {
            this._super(elem, options, DropdownDefaultConfig, {
                _toggle: null,
                displayOrigin: null,
                isOpen: false
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("dropdown-create", {
                element: element
            });

            if (element.hasClass("open")) {
                element.removeClass("open");
                setTimeout(function(){
                    that.open(true);
                },0);
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var toggle;

            if (o.dropUp) {
                element.addClass("drop-up");
            }

            toggle = o.toggleElement !== null ? $(o.toggleElement) : element.siblings('.dropdown-toggle').length > 0 ? element.siblings('.dropdown-toggle') : element.prev();

            this.displayOrigin = Utils.getStyleOne(element, "display");

            if (element.hasClass("v-menu")) {
                element.addClass("for-dropdown");
            }

            element.css("display", "none");

            this._toggle = toggle;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var toggle = this._toggle, parent = element.parent();

            toggle.on(Metro.events.click, function(e){
                parent.siblings(parent[0].tagName).removeClass("active-container");
                $(".active-container").removeClass("active-container");

                if (element.css('display') !== 'none' && !element.hasClass('keep-open')) {
                    that._close(element);
                } else {
                    $('[data-role*=dropdown]').each(function(i, el){
                        if (!element.parents('[data-role*=dropdown]').is(el) && !$(el).hasClass('keep-open') && $(el).css('display') !== 'none') {
                            if (!Utils.isValue(o.dropFilter)) {
                                that._close(el);
                            } else {
                                if ($(el).closest(o.dropFilter).length > 0) {
                                    that._close(el);
                                }
                            }
                        }
                    });
                    if (element.hasClass('horizontal')) {
                        element.css({
                            'visibility': 'hidden',
                            'display': 'block'
                        });
                        var children_width = 0;
                        $.each(element.children('li'), function(){
                            children_width += $(this).outerWidth(true);
                        });

                        element.css({
                            'visibility': 'visible',
                            'display': 'none'
                        });
                        element.css('width', children_width);
                    }
                    that._open(element);
                    parent.addClass("active-container");
                }
                e.preventDefault();
                e.stopPropagation();
            });

            if (o.noClose === true) {
                element.addClass("keep-open").on(Metro.events.click, function (e) {
                    //e.preventDefault();
                    e.stopPropagation();
                });
            }

            $(element).find('li.disabled a').on(Metro.events.click, function(e){
                e.preventDefault();
            });
        },

        _close: function(el, immediate){
            el = $(el);

            var dropdown  = Metro.getPlugin(el, "dropdown");
            var toggle = dropdown._toggle;
            var options = dropdown.options;
            var func = "slideUp";

            toggle.removeClass('active-toggle').removeClass("active-control");
            dropdown.element.parent().removeClass("active-container");

            if (immediate) {
                func = 'hide'
            }

            el[func](immediate ? 0 : options.duration, function(){
                dropdown._fireEvent("close");
                dropdown._fireEvent("up");

                if (!options.dropUp && options.checkDropUp) {
                    dropdown.element.removeClass("drop-up");
                }
            });

            this.isOpen = false;
        },

        // TODO Add control: if no space for drop-down and no space for drop-up, element will must drop-down
        _open: function(el, immediate){
            el = $(el);

            var dropdown  = Metro.getPlugin(el, "dropdown");
            var toggle = dropdown._toggle;
            var options = dropdown.options;
            var func = "slideDown";

            toggle.addClass('active-toggle').addClass("active-control");

            el[func](immediate ? 0 : options.duration, function(){

                if (!options.dropUp && options.checkDropUp) {
                    // dropdown.element.removeClass("drop-up");
                    if (!Utils.inViewport(dropdown.element[0])) {
                        dropdown.element.addClass("drop-up");

                        if (!Utils.inViewport(dropdown.element[0])) {
                            dropdown.element.removeClass("drop-up");
                        }
                    }
                }

                dropdown._fireEvent("open");
                dropdown._fireEvent("drop");
            });

            // this._fireEvent("drop");

            this.isOpen = true;
        },

        close: function(immediate){
            this._close(this.element, immediate);
        },

        open: function(immediate){
            this._open(this.element, immediate);
        },

        toggle: function(){
            if (this.isOpen)
                this.close();
            else
                this.open();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(){
        },

        destroy: function(){
            this._toggle.off(Metro.events.click);
        }
    });

    $(document).on(Metro.events.click, function(){
        $('[data-role*=dropdown]').each(function(){
            var el = $(this);

            if (el.css('display')!=='none' && !el.hasClass('keep-open') && !el.hasClass('stay-open') && !el.hasClass('ignore-document-click')) {
                Metro.getPlugin(el, 'dropdown').close();
            }
        });
    });
}(Metro, m4q));

(function (Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Export = {

        init: function () {
            return this;
        },

        options: {
            csvDelimiter: "\t",
            csvNewLine: "\r\n",
            includeHeader: true
        },

        setup: function (options) {
            this.options = $.extend({}, this.options, options);
            return this;
        },

        base64: function (data) {
            return window.btoa(unescape(encodeURIComponent(data)));
        },

        b64toBlob: function (b64Data, contentType, sliceSize) {
            contentType = contentType || '';
            sliceSize = sliceSize || 512;

            var byteCharacters = window.atob(b64Data);
            var byteArrays = [];

            var offset;
            for (offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                var slice = byteCharacters.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                var i;
                for (i = 0; i < slice.length; i = i + 1) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new window.Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, {
                type: contentType
            });
        },

        tableToCSV: function (table, filename, options) {
            var o;
            var body, head, data = "";
            var i, j, row, cell;

            o = $.extend({}, this.options, options);

            table = $(table)[0];

            if (Utils.bool(o.includeHeader)) {

                head = table.querySelectorAll("thead")[0];

                for (i = 0; i < head.rows.length; i++) {
                    row = head.rows[i];
                    for (j = 0; j < row.cells.length; j++) {
                        cell = row.cells[j];
                        data += (j ? o.csvDelimiter : '') + cell.textContent.trim();
                    }
                    data += o.csvNewLine;
                }
            }

            body = table.querySelectorAll("tbody")[0];

            for (i = 0; i < body.rows.length; i++) {
                row = body.rows[i];
                for (j = 0; j < row.cells.length; j++) {
                    cell = row.cells[j];
                    data += (j ? o.csvDelimiter : '') + cell.textContent.trim();
                }
                data += o.csvNewLine;
            }

            if (Utils.isValue(filename)) {
                return this.createDownload(this.base64("\uFEFF" + data), 'application/csv', filename);
            }

            return data;
        },

        createDownload: function (data, contentType, filename) {
            var blob, anchor, url;

            anchor = document.createElement('a');
            anchor.style.display = "none";
            document.body.appendChild(anchor);

            blob = this.b64toBlob(data, contentType);

            url = window.URL.createObjectURL(blob);
            anchor.href = url;
            anchor.download = filename || Utils.elementId("download");
            anchor.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(anchor);
            return true;
        },

        arrayToCsv: function(array, filename, options){
            var o, data = "", i, row;

            o = $.extend({}, this.options, options);

            for (i = 0; i < array.length; i++) {
                row = array[i];

                if (typeof row !== "object") {
                    data += row + o.csvNewLine;
                } else {
                    $.each(row, function(key, val){
                        data += (key ? o.csvDelimiter : '') + val.toString();
                    });
                    data += o.csvNewLine;
                }
            }

            if (Utils.isValue(filename)) {
                return this.createDownload(this.base64("\uFEFF" + data), 'application/csv', filename);
            }

            return data;
        }
    };

    Metro.export = Export.init();

    if (window.METRO_GLOBAL_COMMON === true) {
        window.Export = Metro.export;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var FileDefaultConfig = {
        fileDeferred: 0,
        label: "",
        mode: "input",
        buttonTitle: "Choose file(s)",
        filesTitle: "file(s) selected",
        dropTitle: "<strong>Choose a file(s)</strong> or drop it here",
        dropIcon: "<span class='default-icon-upload'></span>",
        prepend: "",
        clsComponent: "",
        clsPrepend: "",
        clsButton: "",
        clsCaption: "",
        clsLabel: "",
        copyInlineStyles: false,
        onSelect: Metro.noop,
        onFileCreate: Metro.noop
    };

    Metro.fileSetup = function (options) {
        FileDefaultConfig = $.extend({}, FileDefaultConfig, options);
    };

    if (typeof window["metroFileSetup"] !== undefined) {
        Metro.fileSetup(window["metroFileSetup"]);
    }

    Metro.Component('file', {
        init: function( options, elem ) {
            this._super(elem, options, FileDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("file-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container = $("<label>").addClass((o.mode === "input" ? " file " : o.mode === "button" ? " file-button " : " drop-zone ") + element[0].className).addClass(o.clsComponent);
            var caption = $("<span>").addClass("caption").addClass(o.clsCaption);
            var files = $("<span>").addClass("files").addClass(o.clsCaption);
            var icon, button;


            container.insertBefore(element);
            element.appendTo(container);

            if (o.mode === 'drop' || o.mode === 'dropzone') {
                icon = $(o.dropIcon).addClass("icon").appendTo(container);
                caption.html(o.dropTitle).insertAfter(icon);
                files.html("0" + " " + o.filesTitle).insertAfter(caption);
            } else if (o.mode === 'button') {

                button = $("<span>").addClass("button").attr("tabindex", -1).html(o.buttonTitle);
                button.appendTo(container);
                button.addClass(o.clsButton);

            } else {
                caption.insertBefore(element);

                button = $("<span>").addClass("button").attr("tabindex", -1).html(o.buttonTitle);
                button.appendTo(container);
                button.addClass(o.clsButton);

                if (element.attr('dir') === 'rtl' ) {
                    container.addClass("rtl");
                }

                if (o.prepend !== "") {
                    var prepend = $("<div>").html(o.prepend);
                    prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
                }
            }

            element[0].className = '';

            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest("label");
            var caption = container.find(".caption");
            var files = container.find(".files");
            var form = element.closest("form");

            if (form.length) {
                form.on("reset", function(){
                    that.clear();
                })
            }

            container.on(Metro.events.click, "button", function(){
                element[0].click();
            });

            element.on(Metro.events.change, function(){
                var fi = this;
                var file_names = [];
                var entry;

                // if (fi.files.length === 0) {
                //     return ;
                // }

                Array.from(fi.files).forEach(function(file){
                    file_names.push(file.name);
                });

                if (o.mode === "input") {

                    entry = file_names.join(", ");

                    caption.html(entry);
                    caption.attr('title', entry);
                } else {
                    files.html(element[0].files.length + " " +o.filesTitle);
                }

                that._fireEvent("select", {
                    files: fi.files
                });
            });

            element.on(Metro.events.focus, function(){container.addClass("focused");});
            element.on(Metro.events.blur, function(){container.removeClass("focused");});

            if (o.mode !== "input") {
                container.on('drag dragstart dragend dragover dragenter dragleave drop', function(e){
                    e.preventDefault();
                });

                container.on('dragenter dragover', function(){
                    container.addClass("drop-on");
                });

                container.on('dragleave', function(){
                    container.removeClass("drop-on");
                });

                container.on('drop', function(e){
                    element[0].files = e.dataTransfer.files;
                    files.html(element[0].files.length + " " +o.filesTitle);
                    container.removeClass("drop-on");
                    element.trigger("change");
                });
            }
        },

        clear: function(){
            var element = this.element, o = this.options;
            if (o.mode === "input") {
                element.siblings(".caption").html("");
            } else {
                element.siblings(".caption").html(o.dropTitle);
                element.siblings(".files").html("0" + " " + o.filesTitle);
            }

            element.val("");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggleDir: function(){
            if (this.element.attr("dir") === 'rtl') {
                this.element.parent().addClass("rtl");
            } else {
                this.element.parent().removeClass("rtl");
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'dir': this.toggleDir(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var parent = element.parent();
            element.off(Metro.events.change);
            parent.off(Metro.events.click, "button");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var GradientBoxDefaultConfig = {
        gradientType: "linear", // linear, radial
        gradientShape: "",
        gradientPosition: "",
        gradientSize: "",
        gradientColors: "#000, #fff",
        gradientRepeat: false,
        onGradientBoxCreate: Metro.noop
    };

    Metro.gradientBoxSetup = function (options) {
        GradientBoxDefaultConfig = $.extend({}, GradientBoxDefaultConfig, options);
    };

    if (typeof window["metroGradientBoxSetup"] !== undefined) {
        Metro.gradientBoxSetup(window["metroGradientBoxSetup"]);
    }

    Metro.Component('gradient-box', {
        init: function( options, elem ) {
            this._super(elem, options, GradientBoxDefaultConfig, {
                // define instance vars here
                colors: [],
                shape: "",
                size: "",
                position: "",
                type: "linear",
                func: "linear-gradient",
                repeat: false
            });
            return this;
        },

        _create: function(){
            var o = this.options;

            this.colors = o.gradientColors.toArray(",");
            this.type = o.gradientType.toLowerCase();
            this.shape = o.gradientShape.toLowerCase();
            this.size = o.gradientSize.toLowerCase();
            this.repeat = o.gradientRepeat;
            this.func = (this.repeat ? "repeating-" : "") + this.type + "-gradient";


            if (this.type === "linear") {
                if ( !o.gradientPosition ) {
                    this.position = "to bottom";
                } else {
                    this.position = isNaN(o.gradientPosition) === false ? o.gradientPosition + "deg" : o.gradientPosition;

                    if (this.position.indexOf("deg") === -1 && this.position.indexOf("to ") === -1) {
                        this.position = "to " + this.position;
                    }
                }
            } else {
                this.position = o.gradientPosition.toLowerCase();
                if (this.position && this.position.indexOf("at ") === -1) {
                    this.position = "at " + this.position;
                }
            }

            this._createStructure();
            this._setGradient();
            this._fireEvent('gradient-box-create');
        },

        _createStructure: function(){
            this.element.addClass("gradient-box");
        },

        _setGradient: function (){
            var element = this.element;
            var gradientRule, gradientOptions = [];

            if (this.type === "radial" && this.shape) {
                gradientOptions.push(this.shape);
            }

            if (this.type === "radial" && this.size) {
                gradientOptions.push(this.size);
            }

            if (this.position) {
                gradientOptions.push((this.position.indexOf("at") === -1 ? "at " : "") + this.position);
            }

            gradientRule = this.func + "(" + (gradientOptions.length ? gradientOptions.join(" ") + ", " : "") + this.colors.join(", ") + ")";

            element.css({
                background: gradientRule
            });
        },

        changeAttribute: function(attr, newValue){
            if (attr.indexOf("data-gradient-") === -1) {
                return ;
            }

            switch (attr) {
                case "data-gradient-type": this.type = newValue; this.func = newValue.toLowerCase() + "-gradient"; break;
                case "data-gradient-colors": this.colors = newValue ? newValue.toArray(",") : ["#fff", "#000"]; break;
                case "data-gradient-shape": this.shape = newValue.toLowerCase(); break;
                case "data-gradient-size": this.size = newValue.toLowerCase(); break;
                case "data-gradient-position": this.position = newValue.toLowerCase(); break;
                case "data-gradient-repeat": this.repeat = Utils.bool(newValue); break;
            }

            this._setGradient();
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var GravatarDefaultConfig = {
        gravatarDeferred: 0,
        email: "",
        size: 80,
        default: "mp",
        onGravatarCreate: Metro.noop
    };

    Metro.gravatarSetup = function (options) {
        GravatarDefaultConfig = $.extend({}, GravatarDefaultConfig, options);
    };

    if (typeof window["metroGravatarSetup"] !== undefined) {
        Metro.gravatarSetup(window["metroGravatarSetup"]);
    }

    Metro.Component('gravatar', {
        init: function( options, elem ) {
            this._super(elem, options, GravatarDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this.get();

            this._fireEvent("gravatar-create", {
                element: element
            });
        },

        getImage: function(email, size, def, is_object){
            var image = $("<img>").attr('alt', email);

            image.attr("src", this.getImageSrc(email, size));

            return is_object === true ? image : image[0];
        },

        getImageSrc: function(email, size, def){
            if (email === undefined || email.trim() === '') {
                return "";
            }

            size = size || 80;
            def = Metro.utils.encodeURI(def) || '404';

            return "//www.gravatar.com/avatar/" + Metro.md5((email.toLowerCase()).trim()) + '?size=' + size + '&d=' + def;
        },

        get: function(){
            var element = this.element, o = this.options;
            var img = element[0].tagName === 'IMG' ? element : element.find("img");

            if (img.length === 0) {
                return;
            }
            img.attr("src", this.getImageSrc(o.email, o.size, o.default));

            return this;
        },

        resize: function(new_size){
            this.options.size = new_size !== undefined ? new_size : this.element.attr("data-size");
            this.get();
        },

        email: function(new_email){
            this.options.email = new_email !== undefined ? new_email : this.element.attr("data-email");
            this.get();
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-size': this.resize(); break;
                case 'data-email': this.email(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var HintDefaultConfig = {
        hintDeferred: 0,
        hintHide: 5000,
        clsHint: "",
        hintText: "",
        hintPosition: Metro.position.TOP,
        hintOffset: 4,
        onHintShow: Metro.noop,
        onHintHide: Metro.noop,
        onHintCreate: Metro.noop
    };

    Metro.hintSetup = function (options) {
        HintDefaultConfig = $.extend({}, HintDefaultConfig, options);
    };

    if (typeof window["metroHintSetup"] !== undefined) {
        Metro.hintSetup(window["metroHintSetup"]);
    }

    Metro.Component('hint', {
        init: function( options, elem ) {
            this._super(elem, options, HintDefaultConfig, {
                hint: null,
                hint_size: {
                    width: 0,
                    height: 0
                },
                id: Utils.elementId("hint")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("hint-create", {
                element: this.element
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var over = false;

            element.on(Metro.events.enter, function(){
                over = true;
                setTimeout(function(){
                    if (!over) return;

                    that.createHint();
                    if (+o.hintHide > 0) {
                        setTimeout(function(){
                            that.removeHint();
                        }, o.hintHide);
                    }
                }, o.hintDeferred);
            });

            element.on(Metro.events.leave, function(){
                over = false;
                that.removeHint();
            });

            $(window).on(Metro.events.scroll+" "+Metro.events.resize, function(){
                if (that.hint !== null) that.setPosition();
            }, {ns: this.id});
        },

        createHint: function(){
            var elem = this.elem, element = this.element, o = this.options;
            var hint = $("<div>").addClass("hint").addClass(o.clsHint).html(o.hintText);

            this.hint = hint;
            this.hint_size = Utils.hiddenElementSize(hint);

            $(".hint:not(.permanent-hint)").remove();

            if (elem.tagName === 'TD' || elem.tagName === 'TH') {
                var wrp = $("<div/>").css("display", "inline-block").html(element.html());
                element.html(wrp);
                this.element = wrp;
            }

            this.setPosition();

            hint.appendTo($('body'));

            this._fireEvent("hint-show", {
                hint: hint[0]
            })
        },

        setPosition: function(){
            var hint = this.hint, hint_size = this.hint_size, o = this.options, element = this.element;

            if (o.hintPosition === Metro.position.BOTTOM) {
                hint.addClass('bottom');
                hint.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + o.hintOffset,
                    left: element.offset().left + element.outerWidth()/2 - hint_size.width/2  - $(window).scrollLeft()
                });
            } else if (o.hintPosition === Metro.position.RIGHT) {
                hint.addClass('right');
                hint.css({
                    top: element.offset().top + element.outerHeight()/2 - hint_size.height/2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + o.hintOffset
                });
            } else if (o.hintPosition === Metro.position.LEFT) {
                hint.addClass('left');
                hint.css({
                    top: element.offset().top + element.outerHeight()/2 - hint_size.height/2 - $(window).scrollTop(),
                    left: element.offset().left - hint_size.width - $(window).scrollLeft() - o.hintOffset
                });
            } else {
                hint.addClass('top');
                hint.css({
                    top: element.offset().top - $(window).scrollTop() - hint_size.height - o.hintOffset,
                    left: element.offset().left - $(window).scrollLeft() + element.outerWidth()/2 - hint_size.width/2
                });
            }
        },

        removeHint: function(){
            var that = this;
            var hint = this.hint;
            var options = this.options;
            var timeout = options.onHintHide === Metro.noop ? 0 : 300;

            if (hint !== null) {

                this._fireEvent("hint-hide", {
                    hint: hint[0]
                });

                setTimeout(function(){
                    hint.hide(0, function(){
                        hint.remove();
                        that.hint = null;
                    });
                }, timeout);
            }
        },

        changeText: function(){
            this.options.hintText = this.element.attr("data-hint-text");
        },

        changeAttribute: function(attributeName){
            if (attributeName === "data-hint-text") {
                this.changeText();
            }
        },

        destroy: function(){
            var element = this.element;
            this.removeHint();
            element.off(Metro.events.enter + "-hint");
            element.off(Metro.events.leave + "-hint");
            $(window).off(Metro.events.scroll + "-hint");
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Hotkey = {
        specialKeys: {
            8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
            20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
            37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
            96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
            104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/",
            112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8",
            120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 188: ",", 190: ".",
            191: "/", 224: "meta" },

        shiftNums: {
            "~":"`", "!":"1", "@":"2", "#":"3", "$":"4", "%":"5", "^":"6", "&":"7",
            "*":"8", "(":"9", ")":"0", "_":"-", "+":"=", ":":";", "\"":"'", "<":",",
            ">":".",  "?":"/",   "|":"\\"
        },

        shiftNumsInverse: {
            "`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&",
            "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<",
            ".": ">",  "/": "?",  "\\": "|"
        },

        textAcceptingInputTypes: [
            "text", "password", "number", "email", "url", "range", "date", "month", "week", "time", "datetime",
            "datetime-local", "search", "color", "tel"
        ],

        getKey: function(e){
            var key, k = e.keyCode, char = String.fromCharCode( k ).toLowerCase();
            if( e.shiftKey ){
                key = Hotkey.shiftNums[ char ] ? Hotkey.shiftNums[ char ] : char;
            }
            else {
                key = Hotkey.specialKeys[ k ] === undefined
                    ? char
                    : Hotkey.specialKeys[ k ];
            }

            return Hotkey.getModifier(e).length ? Hotkey.getModifier(e).join("+") + "+" + key : key;
        },

        getModifier: function(e){
            var m = [];
            if (e.altKey) {m.push("alt");}
            if (e.ctrlKey) {m.push("ctrl");}
            if (e.shiftKey) {m.push("shift");}
            return m;
        }
    };

    function bindKey(key, fn){
        return this.each(function(){
            $(this).on(Metro.events.keyup+".hotkey-method-"+key, function(e){
                var _key = Hotkey.getKey(e);
                var el = $(this);
                var href = ""+el.attr("href");

                if (key !== _key) {
                    return;
                }

                if (el.is("a")) {
                    if (href && href.trim() !== "#") {
                        window.location.href = href;
                    }
                }

                Utils.exec(fn, [e, _key, key], this);
            })
        })
    }

    $.fn.hotkey = bindKey;

    if (window.METRO_JQUERY && window.jquery_present) {
        jQuery.fn.hotkey = bindKey;
    }

    // TODO keyup or keydown ?
    $(document).on(Metro.events.keyup + ".hotkey-data", function(e){
        var el, fn, key, href;

        if (
            (METRO_HOTKEYS_FILTER_INPUT_ACCEPTING_ELEMENTS && /textarea|input|select/i.test(e.target.nodeName)) ||
            (METRO_HOTKEYS_FILTER_CONTENT_EDITABLE && $(e.target).attr('contenteditable')) ||
            (METRO_HOTKEYS_FILTER_TEXT_INPUTS && Hotkey.textAcceptingInputTypes.indexOf(e.target.type) > -1)
        )
        {
            return;
        }

        key = Hotkey.getKey(e);

        if (Utils.keyInObject(Metro.hotkeys, key)) {
            el = $(Metro.hotkeys[key][0]);
            fn = Metro.hotkeys[key][1];
            href = (""+el.attr("href")).trim();

            if (fn) {
                Utils.exec(fn);
            } else {
                if (el.is("a") && href && href.length > 0 && href.trim() !== "#") {
                    window.location.href = href;
                } else {
                    el.click();
                }
            }
        }
    });

    // TODO add destroy
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var HtmlContainerDefaultConfig = {
        htmlcontainerDeferred: 0,
        method: "get",
        htmlSource: null,
        requestData: null,
        requestOptions: null,
        insertMode: "default", // replace, append, prepend
        onHtmlLoad: Metro.noop,
        onHtmlLoadFail: Metro.noop,
        onHtmlLoadDone: Metro.noop,
        onHtmlContainerCreate: Metro.noop
    };

    Metro.htmlContainerSetup = function (options) {
        HtmlContainerDefaultConfig = $.extend({}, HtmlContainerDefaultConfig, options);
    };

    if (typeof window["metroHtmlContainerSetup"] !== undefined) {
        Metro.htmlContainerSetup(window["metroHtmlContainerSetup"]);
    }

    Metro.Component('html-container', {
        init: function( options, elem ) {
            this._super(elem, options, HtmlContainerDefaultConfig, {
                data: null,
                opt: {},
                htmlSource: ''
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (typeof o.requestData === 'string') {
                o.requestData = JSON.parse(o.requestData);
            }

            if (Utils.isObject(o.requestData)) {
                this.data = Utils.isObject(o.requestData);
            }

            if (typeof o.requestOptions === 'string') {
                o.requestOptions = JSON.parse(o.requestOptions);
            }

            if (Utils.isObject(o.requestOptions)) {
                this.opt = Utils.isObject(o.requestOptions);
            }

            o.method = o.method.toUpperCase();

            if (Utils.isValue(o.htmlSource)) {
                this.htmlSource = o.htmlSource;
                this._load();
            }

            this._fireEvent("html-container-create", {
                element: element
            });
        },

        _load: function(){
            var that = this, element = this.element, o = this.options;
            var fetchData = {
                method: o.method
            };

            if (this.data) fetchData['body'] = this.data;
            if (this.opt) fetchData['headers'] = this.opt;

            fetch(this.htmlSource, fetchData)
            .then(Metro.fetch.status)
            .then(Metro.fetch.text)
            .then(function(data){
                var _data = $(data);

                if (_data.length === 0) {
                    _data = $("<div>").html(data);
                }

                switch (o.insertMode.toLowerCase()) {
                    case "prepend": element.prepend(_data); break;
                    case "append": element.append(_data); break;
                    case "replace": _data.insertBefore(element).script(); element.remove(); break;
                    default: {
                        element.html(_data);
                    }
                }
                that._fireEvent("html-load", {
                    data: data,
                    source: o.htmlSource,
                    requestData: that.data,
                    requestOptions: that.opt
                });
            })
            .catch(function(error){
                that._fireEvent("html-load-fail", {
                    error: error
                });
            });
        },

        load: function(source, data, opt){
            if (source) {
                this.htmlSource = source;
            }

            if (data) {
                this.data = Utils.isObject(data);
            }

            if (opt) {
                this.opt = Utils.isObject(opt);
            }

            this._load();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeHTMLSource = function(){
                var html = element.attr("data-html-source");
                if (Utils.isNull(html)) {
                    return ;
                }
                if (html.trim() === "") {
                    element.html("");
                }
                o.htmlSource = html;
                that._load();
            };

            var changeInsertMode = function(){
                var attr = element.attr("data-insert-mode");
                if (Utils.isValue(attr)) {
                    o.insertMode = attr;
                }
            };

            var changeRequestData = function(){
                var data = element.attr("data-request-data");
                that.load(o.htmlSource, data);
            };

            switch (attributeName) {
                case "data-html-source": changeHTMLSource(); break;
                case "data-insert-mode": changeInsertMode(); break;
                case "data-request-data": changeRequestData(); break;
            }
        },

        destroy: function(){}
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var ImageBoxDefaultConfig = {
        image: null,
        size: "cover",
        repeat: false,
        color: "transparent",
        attachment: "scroll",
        origin: "border",
        onImageBoxCreate: Metro.noop
    };

    Metro.imageBoxSetup = function (options) {
        ImageBoxDefaultConfig = $.extend({}, ImageBoxDefaultConfig, options);
    };

    if (typeof window["metroImageBoxSetup"] !== undefined) {
        Metro.imageBoxSetup(window["metroImageBoxSetup"]);
    }

    Metro.Component('image-box', {
        init: function( options, elem ) {
            this._super(elem, options, ImageBoxDefaultConfig, {
                // define instance vars here
            });
            return this;
        },

        _create: function(){
            this._createStructure();

            this._fireEvent('image-box-create');
        },

        _createStructure: function(){
            var element = this.element;

            element.addClass("image-box");

            this._drawImage();
        },

        _drawImage: function(){
            var element = this.element, o = this.options;
            var image = new Image();
            var portrait;

            if (!element.attr("data-original"))
                element.attr("data-original", o.image);

            element.css({
                backgroundImage: "url("+o.image+")",
                backgroundSize: o.size,
                backgroundRepeat: o.repeat ? "repeat" : "no-repeat",
                backgroundColor: o.color,
                backgroundAttachment: o.attachment,
                backgroundOrigin: o.origin
            });

            image.src = o.image;
            image.onload = function(){
                portrait = this.height >= this.width;
                element
                    .removeClass("image-box__portrait image-box__landscape")
                    .addClass("image-box__" + (portrait ? "portrait" : "landscape"));
            }
        },

        changeAttribute: function(attr, newValue){
            var attrName = attr.replace("data-", "");

            if (["image", "size", "repeat", "color", "attachment", "origin"].indexOf(attrName) > -1) {
                this.options[attrName] = newValue;
                this._drawImage();
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ImageCompareDefaultConfig = {
        imagecompareDeferred: 0,
        width: "100%",
        height: "auto",
        onSliderMove: Metro.noop,
        onImageCompareCreate: Metro.noop
    };

    Metro.imageCompareSetup = function (options) {
        ImageCompareDefaultConfig = $.extend({}, ImageCompareDefaultConfig, options);
    };

    if (typeof window["metroImageCompareSetup"] !== undefined) {
        Metro.imageCompareSetup(window["metroImageCompareSetup"]);
    }

    Metro.Component('image-compare', {
        init: function( options, elem ) {
            this._super(elem, options, ImageCompareDefaultConfig, {
                id: Utils.elementId("image-compare")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("image-compare-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container, container_overlay, slider;
            var images, element_width, element_height;

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("image-compare"));
            }

            element.addClass("image-compare").css({
                width: o.width
            });

            element_width = element.width();

            switch (o.height) {
                case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                default: element_height = o.height;
            }

            element.css({
                height: element_height
            });

            container = $("<div>").addClass("image-container").appendTo(element);
            container_overlay = $("<div>").addClass("image-container-overlay").appendTo(element).css({
                width: element_width / 2
            });

            slider = $("<div>").addClass("image-slider").appendTo(element);
            slider.css({
                top: element_height / 2 - slider.height() / 2,
                left: element_width / 2 - slider.width() / 2
            });

            images = element.find("img");

            $.each(images, function(i){
                var img = $("<div>").addClass("image-wrapper");
                img.css({
                    width: element_width,
                    height: element_height,
                    backgroundImage: "url("+this.src+")"
                });
                img.appendTo(i === 0 ? container : container_overlay);
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            var overlay = element.find(".image-container-overlay");
            var slider = element.find(".image-slider");

            slider.on(Metro.events.startAll, function(){
                var w = element.width();
                $(document).on(Metro.events.moveAll, function(e){
                    var x = Utils.getCursorPositionX(element[0], e), left_pos;
                    if (x < 0) x = 0;
                    if (x > w) x = w;
                    overlay.css({
                        width: x
                    });
                    left_pos = x - slider.width() / 2;
                    slider.css({
                        left: left_pos
                    });

                    that._fireEvent("slider-move", {
                        x: x,
                        l: left_pos
                    });
                }, {ns: that.id});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});
                }, {ns: that.id})
            });

            $(window).on(Metro.events.resize, function(){
                var element_width = element.width(), element_height;

                if (o.width !== "100%") {
                    return ;
                }

                switch (o.height) {
                    case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                    case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                    case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                    case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                    default: element_height = o.height;
                }

                element.css({
                    height: element_height
                });

                $.each(element.find(".image-wrapper"), function(){
                    $(this).css({
                        width: element_width,
                        height: element_height
                    })
                });

                element.find(".image-container-overlay").css({
                    width: element_width / 2
                });

                slider.css({
                    top: element_height / 2 - slider.height() / 2,
                    left: element_width / 2 - slider.width() / 2
                });

            }, {ns: this.id});
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.start);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ImageGridDefaultConfig = {
        useBackground: false,
        backgroundSize: "cover",
        backgroundPosition: "top left",

        clsImageGrid: "",
        clsImageGridItem: "",
        clsImageGridImage: "",

        onItemClick: Metro.noop,
        onDrawItem: Metro.noop,
        onImageGridCreate: Metro.noop
    };

    Metro.imageGridSetup = function (options) {
        ImageGridDefaultConfig = $.extend({}, ImageGridDefaultConfig, options);
    };

    if (typeof window["metroImageGridSetup"] !== undefined) {
        Metro.imageGridSetup(window["metroImageGridSetup"]);
    }

    Metro.Component('image-grid', {
        init: function( options, elem ) {
            this._super(elem, options, ImageGridDefaultConfig, {
                // define instance vars here
                items: []
            });
            return this;
        },

        _create: function(){
            this.items = this.element.children("img");
            this._createStructure();
            this._createEvents();
            this._fireEvent('image-grid-create');
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("image-grid").addClass(o.clsImageGrid);

            this._createItems();
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".image-grid__item", function(){
                that._fireEvent("item-click", {
                    item: this
                });
            });
        },

        _createItems: function(){
            var that = this, element = this.element, o = this.options;
            var items = this.items;

            element.clear();

            items.each(function(){
                var el = $(this);
                var src = this.src;
                var wrapper = $("<div>").addClass("image-grid__item").addClass(o.clsImageGridItem).appendTo(element);
                var img = new Image();

                img.src = src;
                img.onload = function(){
                    var port = this.height >= this.width;
                    wrapper.addClass(port ? "image-grid__item-portrait" : "image-grid__item-landscape");
                    el.addClass(o.clsImageGridImage).appendTo(wrapper);

                    if (o.useBackground) {
                        wrapper
                            .css({
                                background: "url("+src+")",
                                backgroundRepeat: "no-repeat",
                                backgroundSize: o.backgroundSize,
                                backgroundPosition: o.backgroundPosition
                            })
                            .attr("data-original", el.attr("data-original") || src)
                            .attr("data-title", el.attr("alt") || el.attr("data-title") || "");
                        el.visible(false);
                    }

                    that._fireEvent("draw-item", {
                        item: wrapper[0],
                        image: el[0]
                    });
                }
            });
        },

        changeAttribute: function(attr, val){
            var o = this.options;

            if (attr === "data-use-background") {
                o.useBackground = Utils.bool(val);
                this._createItems();
            }

            if (attr === "data-background-size") {
                o.backgroundSize = val;
                this._createItems();
            }

            if (attr === "data-background-position") {
                o.backgroundPosition = val;
                this._createItems();
            }
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ImageMagnifierDefaultConfig = {
        imagemagnifierDeferred: 0,
        width: "100%",
        height: "auto",
        lensSize: 100,
        lensType: "square", // square, circle
        magnifierZoom: 2,
        magnifierMode: "glass", // glass, zoom
        magnifierZoomElement: null,

        clsMagnifier: "",
        clsLens: "",
        clsZoom: "",

        onMagnifierMove: Metro.noop,
        onImageMagnifierCreate: Metro.noop
    };

    Metro.imageMagnifierSetup = function (options) {
        ImageMagnifierDefaultConfig = $.extend({}, ImageMagnifierDefaultConfig, options);
    };

    if (typeof window["metroImageMagnifierSetup"] !== undefined) {
        Metro.imageMagnifierSetup(window["metroImageMagnifierSetup"]);
    }

    Metro.Component('image-magnifier', {
        init: function( options, elem ) {
            this._super(elem, options, ImageMagnifierDefaultConfig, {
                zoomElement: null,
                id: Utils.elementId("image-magnifier")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("image-magnifier-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var magnifier, element_width, element_height;
            var image = element.find("img");

            if (image.length === 0) {
                throw new Error("Image not defined");
            }

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", Utils.elementId("image-magnifier"));
            }

            element.addClass("image-magnifier").css({
                width: o.width
            }).addClass(o.clsMagnifier);

            element_width = element.width();

            switch (o.height) {
                case "16/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "21/9": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "4/3": element_height = Utils.aspectRatioH(element_width, o.height); break;
                case "auto": element_height = Utils.aspectRatioH(element_width, "16/9"); break;
                default: element_height = o.height;
            }

            element.css({
                height: element_height
            });

            var x = element_width / 2 - o.lensSize / 2;
            var y = element_height / 2 - o.lensSize / 2;

            if (o.magnifierMode === "glass") {

                magnifier = $("<div>").addClass("image-magnifier-glass").appendTo(element);
                magnifier.css({
                    width: o.lensSize,
                    height: o.lensSize,
                    borderRadius: o.lensType !== "circle" ? 0 : "50%",
                    top: y,
                    left: x,
                    backgroundImage: "url(" + image[0].src + ")",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "-" + ((x * o.magnifierZoom) - o.lensSize / 4 + 4) + "px -" + ((y * o.magnifierZoom) - o.lensSize / 4 + 4) + "px",
                    backgroundSize: (image[0].width * o.magnifierZoom) + "px " + (image[0].height * o.magnifierZoom) + "px"
                }).addClass(o.clsLens);

            } else {

                magnifier = $("<div>").addClass("image-magnifier-glass").appendTo(element);
                magnifier.css({
                    width: o.lensSize,
                    height: o.lensSize,
                    borderRadius: 0,
                    borderWidth: 1,
                    top: y,
                    left: x
                }).addClass(o.clsLens);

                if (!Utils.isValue(o.magnifierZoomElement) || $(o.magnifierZoomElement).length === 0) {
                    this.zoomElement = $("<div>").insertAfter(element);
                } else {
                    this.zoomElement = $(o.magnifierZoomElement);
                }

                var zoom_element_width = magnifier[0].offsetWidth * o.magnifierZoom;
                var zoom_element_height = magnifier[0].offsetHeight * o.magnifierZoom;
                var cx = zoom_element_width / o.lensSize;
                var cy = zoom_element_height / o.lensSize;

                this.zoomElement.css({
                    width: zoom_element_width,
                    height: zoom_element_height,
                    backgroundImage: "url(" + image[0].src + ")",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "-" + (x * cx) + "px -" + (y * cy) + "px",
                    backgroundSize: (image[0].width * cx) + "px " + (image[0].height * cy) + "px"
                }).addClass(o.clsZoom);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var glass = element.find(".image-magnifier-glass");
            var glass_size = glass[0].offsetWidth / 2;
            var image = element.find("img")[0];
            var zoomElement = this.zoomElement;
            var cx, cy;

            $(window).on(Metro.events.resize, function(){
                var x = element.width() / 2 - o.lensSize / 2;
                var y = element.height() / 2 - o.lensSize / 2;

                if (o.magnifierMode === "glass") {
                    glass.css({
                        backgroundPosition: "-" + ((x * o.magnifierZoom) - o.lensSize / 4 + 4) + "px -" + ((y * o.magnifierZoom) - o.lensSize / 4 + 4) + "px",
                        backgroundSize: (image.width * o.magnifierZoom) + "px " + (image.height * o.magnifierZoom) + "px"
                    });
                }
            }, {ns: this.id})

            if (o.magnifierMode !== "glass") {
                cx = zoomElement[0].offsetWidth / glass_size / 2;
                cy = zoomElement[0].offsetHeight / glass_size / 2;

                zoomElement.css({
                    backgroundSize: (image.width * cx) + "px " + (image.height * cy) + "px"
                });
            }

            var lens_move = function(pos){
                var x, y;
                var magic = 4, zoom = parseInt(o.magnifierZoom);

                if (o.magnifierMode === "glass") {

                    x = pos.x;
                    y = pos.y;

                    if (x > image.width - (glass_size / zoom)) {
                        x = image.width - (glass_size / zoom);
                    }
                    if (x < glass_size / zoom) {
                        x = glass_size / zoom;
                    }
                    if (y > image.height - (glass_size / zoom)) {
                        y = image.height - (glass_size / zoom);
                    }
                    if (y < glass_size / zoom) {
                        y = glass_size / zoom;
                    }

                    glass.css({
                        top: y - glass_size,
                        left: x - glass_size,
                        backgroundPosition: "-" + ((x * zoom) - glass_size + magic) + "px -" + ((y * zoom) - glass_size + magic) + "px"
                    });
                } else {

                    x = pos.x - (glass_size);
                    y = pos.y - (glass_size);

                    if (x > image.width - glass_size * 2) {x = image.width - glass_size * 2;}
                    if (x < 0) {x = 0;}
                    if (y > image.height - glass_size * 2) {y = image.height - glass_size * 2;}
                    if (y < 0) {y = 0;}

                    glass.css({
                        top: y,
                        left: x
                    });

                    zoomElement.css({
                        backgroundPosition: "-" + (x * cx) + "px -" + (y * cy) + "px"
                    });
                }
            };

            element.on(Metro.events.move, function(e){
                var pos = Utils.getCursorPosition(image, e);

                lens_move(pos);

                that._fireEvent("magnifier-move", {
                    pos: pos,
                    glass: glass[0],
                    zoomElement: zoomElement ? zoomElement[0] : undefined
                });

                e.preventDefault();
            });

            element.on(Metro.events.leave, function(){
                var x = element.width() / 2 - o.lensSize / 2;
                var y = element.height() / 2 - o.lensSize / 2;

                glass.animate({
                    draw: {
                        top: y,
                        left: x
                    }
                });

                lens_move({
                    x: x + o.lensSize / 2, y: y + o.lensSize / 2
                });
            });
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.move);
            element.off(Metro.events.leave);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var ImagePlaceholderDefaultConfig = {
        size: "100x100",
        width: null,
        height: null,
        color: "#f8f8f8",
        textColor: "#292929",
        font: "12px sans-serif",
        text: "",
        showText: true,
        onImagePlaceholderCreate: Metro.noop
    };

    Metro.imagePlaceholderSetup = function (options) {
        ImagePlaceholderDefaultConfig = $.extend({}, ImagePlaceholderDefaultConfig, options);
    };

    if (typeof window["metroImagePlaceholderSetup"] !== undefined) {
        Metro.imagePlaceholderSetup(window["metroImagePlaceholderSetup"]);
    }

    Metro.Component('image-placeholder', {
        init: function( options, elem ) {
            this._super(elem, options, ImagePlaceholderDefaultConfig, {
                // define instance vars here
                width: 0,
                height: 0
            });
            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent('image-placeholder-create');
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var size = o.size.toArray("x");

            this.width = o.width ? o.width : size[0];
            this.height = o.height ? o.height : size[1];

            element.attr("src", this._createPlaceholder());
        },

        _createEvents: function(){
        },

        _createPlaceholder: function(){
            var o = this.options;
            var canvas = document.createElement("canvas"),
                context = canvas.getContext("2d");

            var width = this.width, height = this.height;

            canvas.width = parseInt(width);
            canvas.height = parseInt(height);

            // background
            context.clearRect(0, 0, width, height);
            context.fillStyle = o.color;
            context.fillRect(0, 0, width, height);

            // text
            context.fillStyle = o.textColor;
            context.font = o.font;

            context.translate(width / 2, height / 2);
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            if (o.showText)
                context.fillText(o.text ? o.text : width + " \u00d7 " + height, 0, 0);

            return canvas.toDataURL();
        },

        // changeAttribute: function(attr, newValue){
        // },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var InfoBoxDefaultConfig = {
        infoboxDeferred: 0,
        type: "",
        width: 480,
        height: "auto",
        overlay: true,
        overlayColor: '#000000',
        overlayAlpha: .5,
        overlayClickClose: false,
        autoHide: 0,
        removeOnClose: false,
        closeButton: true,
        clsBox: "",
        clsBoxContent: "",
        clsOverlay: "",
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onInfoBoxCreate: Metro.noop
    };

    Metro.infoBoxSetup = function (options) {
        InfoBoxDefaultConfig = $.extend({}, InfoBoxDefaultConfig, options);
    };

    if (typeof window["metroInfoBoxSetup"] !== undefined) {
        Metro.infoBoxSetup(window["metroInfoBoxSetup"]);
    }

    Metro.Component('info-box', {
        init: function( options, elem ) {
            this._super(elem, options, InfoBoxDefaultConfig, {
                overlay: null,
                id: Utils.elementId("info-box")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("info-box-create", {
                element: element
            });
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay").addClass(o.clsOverlay);

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Metro.colors.toRGBA(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var closer, content;

            if (o.overlay === true) {
                this.overlay = this._overlay();
            }

            element.addClass("info-box").addClass(o.type).addClass(o.clsBox);

            closer = element.find("closer");
            if (closer.length === 0) {
                closer = $("<span>").addClass("button square closer");
                closer.appendTo(element);
            }

            if (o.closeButton !== true) {
                closer.hide();
            }

            content = element.find(".info-box-content");
            if (content.length > 0) {
                content.addClass(o.clsBoxContent);
            }

            element.css({
                width: o.width,
                height: o.height,
                visibility: "hidden",
                top: '100%',
                left: ( $(window).width() - element.outerWidth() ) / 2
            });

            element.appendTo($('body'));
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".closer", function(){
                that.close();
            });

            element.on(Metro.events.click, ".js-dialog-close", function(){
                that.close();
            });

            $(window).on(Metro.events.resize, function(){
                that.reposition();
            }, {ns: this.id});
        },

        _setPosition: function(){
            var element = this.element;
            element.css({
                top: ( $(window).height() - element.outerHeight() ) / 2,
                left: ( $(window).width() - element.outerWidth() ) / 2
            });
        },

        reposition: function(){
            this._setPosition();
        },

        setContent: function(c){
            var element = this.element;
            var content = element.find(".info-box-content");
            if (content.length === 0) {
                return ;
            }
            content.html(c);
            this.reposition();
        },

        setType: function(t){
            var element = this.element;
            element.removeClass("success info alert warning").addClass(t);
        },

        open: function(){
            var that = this, element = this.element, o = this.options;

            // if (o.overlay === true) {
            //     this.overlay.appendTo($("body"));
            // }
            if (o.overlay === true && $(".overlay").length === 0) {
                this.overlay.appendTo($("body"));
                if (o.overlayClickClose === true) {
                    this.overlay.on(Metro.events.click, function(){
                        that.close();
                    });
                }
            }

            this._setPosition();

            element.css({
                visibility: "visible"
            });

            this._fireEvent("open");

            element.data("open", true);

            if (parseInt(o.autoHide) > 0) {
                setTimeout(function(){
                    that.close();
                }, parseInt(o.autoHide));
            }
        },

        close: function(){
            var element = this.element, o = this.options;

            if (o.overlay === true) {
                $('body').find('.overlay').remove();
            }

            element.css({
                visibility: "hidden",
                top: "100%"
            });

            this._fireEvent("close");

            element.data("open", false);

            if (o.removeOnClose === true) {
                this.destroy();
                element.remove();
            }
        },

        isOpen: function(){
            return this.element.data("open") === true;
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off("all");
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });

    Metro['infobox'] = {
        isInfoBox: function(el){
            return Utils.isMetroObject(el, "infobox");
        },

        open: function(el, c, t){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            if (c !== undefined) {
                ib.setContent(c);
            }
            if (t !== undefined) {
                ib.setType(t);
            }
            ib.open();
        },

        close: function(el){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            ib.close();
        },

        setContent: function(el, c){
            if (!this.isInfoBox(el)) {
                return false;
            }

            if (c === undefined) {
                c = "";
            }

            var ib = Metro.getPlugin(el, "infobox");
            ib.setContent(c);
            ib.reposition();
        },

        setType: function(el, t){
            if (!this.isInfoBox(el)) {
                return false;
            }

            var ib = Metro.getPlugin(el, "infobox");
            ib.setType(t);
            ib.reposition();
        },

        isOpen: function(el){
            if (!this.isInfoBox(el)) {
                return false;
            }
            var ib = Metro.getPlugin(el, "infobox");
            return ib.isOpen();
        },

        create: function(c, t, o, open){
            var $$ = Utils.$();
            var el, ib, box_type;

            box_type = t !== undefined ? t : "";

            el = $$("<div>").appendTo($$("body"));
            $$("<div>").addClass("info-box-content").appendTo(el);

            var ib_options = $$.extend({}, {
                removeOnClose: true,
                type: box_type
            }, (o !== undefined ? o : {}));

            ib_options._runtime = true;

            el.infobox(ib_options);

            ib = Metro.getPlugin(el, 'infobox');
            ib.setContent(c);
            if (open !== false) {
                ib.open();
            }

            return el;
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var InputMaskDefaultConfig = {
        maskPattern: ".",
        mask: null,
        maskPlaceholder: "_",
        maskEditableStart: 0,
        thresholdInterval: 300,
        onChar: Metro.noop,
        onInputMaskCreate: Metro.noop
    };

    Metro.inputMaskSetup = function (options) {
        InputMaskDefaultConfig = $.extend({}, InputMaskDefaultConfig, options);
    };

    if (typeof window["metroInputMaskSetup"] !== undefined) {
        Metro.inputMaskSetup(window["metroInputMaskSetup"]);
    }

    Metro.Component('input-mask', {
        init: function( options, elem ) {
            if ($.device) {
                if (elem.setAttribute) elem.setAttribute("placeholder", options.mask);
                console.warn("The component input-mask can't be initialized, because you run it on a mobile device!");
                return ;
            }
            this._super(elem, options, InputMaskDefaultConfig, {
                // define instance vars here
                pattern: null,
                mask: "",
                maskArray: [],
                placeholder: "",
                length: 0,
                thresholdTimer: null,
                id: Utils.elementId("input-mask")
            });
            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent('input-mask-create');
        },

        _createStructure: function(){
            var o = this.options;

            if (!o.mask) {
                throw new Error('You must provide a pattern for masked input.')
            }

            if (typeof o.maskPlaceholder !== 'string' || o.maskPlaceholder.length > 1) {
                throw new Error('Mask placeholder should be a single character or an empty string.')
            }

            this.placeholder = o.maskPlaceholder;
            this.mask = (""+o.mask);
            this.maskArray = this.mask.split("");
            this.pattern = new RegExp("^"+o.maskPattern+"+$");
            this.length = this.mask.length;

            this._showValue();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var editableStart = o.maskEditableStart;
            var id = this.id;

            var checkEditablePosition = function(pos){
                if (pos < editableStart) {
                    setPosition(editableStart);
                    return false;
                }
                return true;
            }

            var checkEditableChar = function(pos){
                return pos < that.mask.length && that.mask.charAt(pos) === that.placeholder;
            }

            var findNextEditablePosition = function (pos){
                var i, a = that.maskArray;

                for (i = pos; i <= a.length; i++) {
                    if (a[i] === that.placeholder) {
                        return i;
                    }
                }
                return pos;
            }

            var setPosition = function(pos){
                that.elem.setSelectionRange(pos, pos);
            }

            var clearThresholdInterval = function(){
                clearInterval(that.thresholdTimer);
                that.thresholdTimer = null;
            }

            element.on("change", function(){
                if (this.value === "") {
                    this.value = that.mask;
                    setPosition(editableStart);
                }
            }, {ns: id});

            element.on("focus click", function(){
                checkEditablePosition(this.selectionStart);
                setPosition(findNextEditablePosition(this.selectionStart));
            }, {ns: id});

            element.on("keydown", function(e){
                var pos = this.selectionStart;
                var val = this.value;
                var code = e.code, key = e.key;

                if (code === "ArrowRight" || code === "End") {
                    return true;
                } else {
                    if (pos >= that.length && (["Backspace", "Home", "ArrowLeft", "ArrowUp"].indexOf(code) === -1)) {
                        // Don't move over mask length
                        e.preventDefault();
                    } else if (code === "Home" || code === "ArrowUp") {
                        // Goto editable start position
                        e.preventDefault();
                        setPosition(editableStart);
                    } else if (code === "ArrowLeft") {
                        if (pos - 1 < editableStart) {
                            // Don't move behind a editable start position
                            e.preventDefault();
                        }
                    } else if (code === "Backspace") {
                        e.preventDefault();
                        if (pos - 1 >= editableStart) {
                            if (checkEditableChar(pos - 1)) {
                                if (this.value.charAt(pos - 1) !== that.placeholder) {
                                    // Replace char if it is not a mask placeholder
                                    this.value = val.substr(0, pos - 1) + that.placeholder + val.substr(pos);
                                }
                            }
                            // Move to prev char position
                            setPosition(pos - 1);
                        }
                    } else if (code === "Space") {
                        e.preventDefault();
                        setPosition(pos + 1);
                    } else if (!that.pattern.test(key)) {
                        e.preventDefault();
                    } else {
                        e.preventDefault();
                        if (checkEditableChar(pos)) {
                            this.value = val.substr(0, pos) + (o.onChar === Metro.noop ? key : Utils.exec(o.onChar, [key], this)) + val.substr(pos + 1);
                            setPosition(findNextEditablePosition(pos + 1));
                        }
                    }
                }
            }, {ns: id});

            element.on("keyup", function(){
                var el = this;

                clearThresholdInterval();

                that.thresholdTimer = setInterval(function(){
                    clearThresholdInterval();
                    setPosition(findNextEditablePosition(el.selectionStart));
                }, o.thresholdInterval)
            }, {ns: id});
        },

        _showValue: function(){
            var that = this, elem = this.elem;
            var a = new Array(this.length);
            var val;
            if (!elem.value) {
                elem.value = this.mask;
            } else {
                val = elem.value;
                $.each(this.maskArray, function(i, v){
                    if (val[i] !== v && !that.pattern.test(val[i])) {
                        a[i] = that.placeholder;
                    } else {
                        a[i] = val[i];
                    }
                });
                this.elem.value = a.join("");
            }
        },

        destroy: function(){
            var element = this.element, id = this.id;

            element.off("change", {ns: id});
            element.off("focus", {ns: id});
            element.off("click", {ns: id});
            element.off("keydown", {ns: id});
            element.off("keyup", {ns: id});

            return element;
        }
    });
}(Metro, m4q));


(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var MaterialInputDefaultConfig = {
        materialinputDeferred: 0,
        label: "",
        informer: "",
        icon: "",

        permanentLabel: false,

        clsComponent: "",
        clsInput: "",
        clsLabel: "",
        clsInformer: "",
        clsIcon: "",
        clsLine: "",

        onInputCreate: Metro.noop
    };

    Metro.materialInputSetup = function (options) {
        MaterialInputDefaultConfig = $.extend({}, MaterialInputDefaultConfig, options);
    };

    if (typeof window["metroMaterialInputSetup"] !== undefined) {
        Metro.materialInputSetup(window["metroMaterialInputSetup"]);
    }

    Metro.Component('material-input', {
        init: function( options, elem ) {
            this._super(elem, options, MaterialInputDefaultConfig, {
                history: [],
                historyIndex: -1
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("input-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var container = $("<div>").addClass("input-material " + element[0].className);

            element[0].className = "";
            element.attr("autocomplete", "nope");

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            container.insertBefore(element);
            element.appendTo(container);

            if (Utils.isValue(o.label)) {
                $("<span>").html(o.label).addClass("label").addClass(o.clsLabel).insertAfter(element);
            }
            if (Utils.isValue(o.informer)) {
                $("<span>").html(o.informer).addClass("informer").addClass(o.clsInformer).insertAfter(element);
            }
            if (Utils.isValue(o.icon)) {
                container.addClass("with-icon");
                $("<span>").html(o.icon).addClass("icon").addClass(o.clsIcon).insertAfter(element);
            }

            container.append($("<hr>").addClass(o.clsLine));

            if (o.permanentLabel === true) {
                container.addClass("permanent-label");
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsInput);

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){

        },

        clear: function(){
            this.element.val('');
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            if (attributeName === 'disabled') {
                this.toggleState();
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var InputDefaultConfig = {
        inputDeferred: 0,

        label: "",

        autocomplete: null,
        autocompleteUrl: null,
        autocompleteUrlMethod: "GET",
        autocompleteUrlKey: null,
        autocompleteDivider: ",",
        autocompleteListHeight: 200,

        history: false,
        historyPreset: "",
        historyDivider: "|",
        preventSubmit: false,
        defaultValue: "",
        size: "default",
        prepend: "",
        append: "",
        copyInlineStyles: false,
        searchButton: false,
        clearButton: true,
        revealButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        revealButtonIcon: "<span class='default-icon-eye'></span>",
        searchButtonIcon: "<span class='default-icon-search'></span>",
        customButtons: [],
        searchButtonClick: 'submit',

        clsComponent: "",
        clsInput: "",
        clsPrepend: "",
        clsAppend: "",
        clsClearButton: "",
        clsRevealButton: "",
        clsCustomButton: "",
        clsSearchButton: "",
        clsLabel: "",

        onAutocompleteSelect: Metro.noop,
        onHistoryChange: Metro.noop,
        onHistoryUp: Metro.noop,
        onHistoryDown: Metro.noop,
        onClearClick: Metro.noop,
        onRevealClick: Metro.noop,
        onSearchButtonClick: Metro.noop,
        onEnterClick: Metro.noop,
        onInputCreate: Metro.noop
    };

    Metro.inputSetup = function (options) {
        InputDefaultConfig = $.extend({}, InputDefaultConfig, options);
    };

    if (typeof window["metroInputSetup"] !== undefined) {
        Metro.inputSetup(window["metroInputSetup"]);
    }

    Metro.Component('input', {
        init: function( options, elem ) {
            this._super(elem, options, InputDefaultConfig, {
                history: [],
                historyIndex: -1,
                autocomplete: []
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("input-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container = $("<div>").addClass("input " + element[0].className);
            var buttons = $("<div>").addClass("button-group");
            var clearButton, revealButton, searchButton;

            if (Utils.isValue(o.historyPreset)) {
                $.each(o.historyPreset.toArray(o.historyDivider), function(){
                    that.history.push(this);
                });
                that.historyIndex = that.history.length - 1;
            }

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);

            if (!Utils.isValue(element.val().trim())) {
                element.val(o.defaultValue);
            }

            if (o.clearButton === true && !element[0].readOnly) {
                clearButton = $("<button>").addClass("button input-clear-button").addClass(o.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            }
            if (element.attr('type') === 'password' && o.revealButton === true) {
                revealButton = $("<button>").addClass("button input-reveal-button").addClass(o.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o.revealButtonIcon);
                revealButton.appendTo(buttons);
            }
            if (o.searchButton === true) {
                searchButton = $("<button>").addClass("button input-search-button").addClass(o.clsSearchButton).attr("tabindex", -1).attr("type", o.searchButtonClick === 'submit' ? "submit" : "button").html(o.searchButtonIcon);
                searchButton.appendTo(buttons);
            }

            if (Utils.isValue(o.prepend)) {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (Utils.isValue(o.append)) {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
            }

            if (typeof o.customButtons === "string") {
                o.customButtons = Utils.isObject(o.customButtons);
            }

            if (typeof o.customButtons === "object" && Utils.objectLength(o.customButtons) > 0) {
                $.each(o.customButtons, function(){
                    var item = this;
                    var customButton = $("<button>");

                    customButton
                        .addClass("button input-custom-button")
                        .addClass(o.clsCustomButton)
                        .addClass(item.cls)
                        .attr("tabindex", -1)
                        .attr("type", "button")
                        .html(item.html);

                    if (item.attr && typeof item.attr === 'object') {
                        $.each(item.attr, function(k, v){
                            customButton.attr(Cake.dashedName(k), v);
                        });
                    }

                    customButton.data("action", item.onclick);

                    customButton.appendTo(buttons);
                });
            }

            if (Utils.isValue(element.attr('data-exclaim'))) {
                container.attr('data-exclaim', element.attr('data-exclaim'));
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsInput);

            if (o.size !== "default") {
                container.css({
                    width: o.size
                });
            }

            if (!Utils.isNull(o.autocomplete) || !Utils.isNull(o.autocompleteUrl)) {
                $("<div>").addClass("autocomplete-list").css({
                    maxHeight: o.autocompleteListHeight,
                    display: "none"
                }).appendTo(container);
            }

            if (Utils.isValue(o.autocomplete)) {
                var autocomplete_obj = Utils.isObject(o.autocomplete);

                if (autocomplete_obj !== false) {
                    this.autocomplete = autocomplete_obj;
                } else {
                    this.autocomplete = o.autocomplete.toArray(o.autocompleteDivider);
                }
            }

            if (Utils.isValue(o.autocompleteUrl)) {
                fetch(o.autocompleteUrl, {
                    method: o.autocompleteUrlMethod
                }).then(function(response){
                    return response.text()
                }).then(function(data){
                    var newData = [];

                    try {
                        newData = JSON.parse(data);
                        if (o.autocompleteUrlKey) {
                            newData = newData[o.autocompleteUrlKey];
                        }
                    } catch (e) {
                        newData = data.split("\n");
                    }

                    that.autocomplete = that.autocomplete.concat(newData);
                });
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".input");
            var autocompleteList = container.find(".autocomplete-list");

            container.on(Metro.events.click, ".input-clear-button", function(){
                var curr = element.val();
                element.val(Utils.isValue(o.defaultValue) ? o.defaultValue : "").fire('clear').fire('change').fire('keyup').focus();
                if (autocompleteList.length > 0) {
                    autocompleteList.css({
                        display: "none"
                    })
                }

                that._fireEvent("clear-click", {
                    prev: curr,
                    val: element.val()
                });

            });

            container.on(Metro.events.click, ".input-reveal-button", function(){
                if (element.attr('type') === 'password') {
                    element.attr('type', 'text');
                } else {
                    element.attr('type', 'password');
                }

                that._fireEvent("reveal-click", {
                    val: element.val()
                });

            });

            container.on(Metro.events.click, ".input-search-button", function(){
                if (o.searchButtonClick !== 'submit') {

                    that._fireEvent("search-button-click", {
                        val: element.val(),
                        button: this
                    });

                } else {
                    this.form.submit();
                }
            });

            // container.on(Metro.events.stop, ".input-reveal-button", function(){
            //     element.attr('type', 'password').focus();
            // });

            container.on(Metro.events.click, ".input-custom-button", function(){
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [element.val(), button], this);
            });

            element.on(Metro.events.keyup, function(e){
                var val = element.val().trim();

                if (o.history && e.keyCode === Metro.keyCode.ENTER && val !== "") {
                    element.val("");
                    that.history.push(val);
                    that.historyIndex = that.history.length - 1;

                    that._fireEvent("history-change", {
                        val: val,
                        history: that.history,
                        historyIndex: that.historyIndex
                    })

                    if (o.preventSubmit === true) {
                        e.preventDefault();
                    }
                }

                if (o.history && e.keyCode === Metro.keyCode.UP_ARROW) {
                    that.historyIndex--;
                    if (that.historyIndex >= 0) {
                        element.val("");
                        element.val(that.history[that.historyIndex]);

                        that._fireEvent("history-down", {
                            val: element.val(),
                            history: that.history,
                            historyIndex: that.historyIndex
                        })
                    } else {
                        that.historyIndex = 0;
                    }
                    e.preventDefault();
                }

                if (o.history && e.keyCode === Metro.keyCode.DOWN_ARROW) {
                    that.historyIndex++;
                    if (that.historyIndex < that.history.length) {
                        element.val("");
                        element.val(that.history[that.historyIndex]);

                        that._fireEvent("history-up", {
                            val: element.val(),
                            history: that.history,
                            historyIndex: that.historyIndex
                        })
                    } else {
                        that.historyIndex = that.history.length - 1;
                    }
                    e.preventDefault();
                }
            });

            element.on(Metro.events.keydown, function(e){
                if (e.keyCode === Metro.keyCode.ENTER) {
                    that._fireEvent("enter-click", {
                        val: element.val()
                    });
                }
            });

            element.on(Metro.events.blur, function(){
                container.removeClass("focused");
            });

            element.on(Metro.events.focus, function(){
                container.addClass("focused");
            });

            element.on(Metro.events.input, function(){
                var val = this.value.toLowerCase();
                that._drawAutocompleteList(val);
            });

            container.on(Metro.events.click, ".autocomplete-list .item", function(){
                var val = $(this).attr("data-autocomplete-value");
                element.val(val);
                autocompleteList.css({
                    display: "none"
                });
                element.trigger("change");
                that._fireEvent("autocomplete-select", {
                    value: val
                });
            });
        },

        _drawAutocompleteList: function(val){
            var that = this, element = this.element;
            var container = element.closest(".input");
            var autocompleteList = container.find(".autocomplete-list");
            var items;

            if (autocompleteList.length === 0) {
                return;
            }

            autocompleteList.html("");

            items = this.autocomplete.filter(function(item){
                return item.toLowerCase().indexOf(val) > -1;
            });

            autocompleteList.css({
                display: items.length > 0 ? "block" : "none"
            });

            $.each(items, function(){
                var v = this;
                var index = v.toLowerCase().indexOf(val), content;
                var item = $("<div>").addClass("item").attr("data-autocomplete-value", v);

                if (index === 0) {
                    content = "<strong>"+v.substr(0, val.length)+"</strong>"+v.substr(val.length);
                } else {
                    content = v.substr(0, index) + "<strong>"+v.substr(index, val.length)+"</strong>"+v.substr(index + val.length);
                }

                item.html(content).appendTo(autocompleteList);

                that._fireEvent("draw-autocomplete-item", {
                    item: item
                })
            });
        },

        getHistory: function(){
            return this.history;
        },

        getHistoryIndex: function(){
            return this.historyIndex;
        },

        setHistoryIndex: function(val){
            this.historyIndex = val >= this.history.length ? this.history.length - 1 : val;
        },

        setHistory: function(history, append) {
            var that = this, o = this.options;
            if (Utils.isNull(history)) return;
            if (!Array.isArray(history) && typeof history === 'string') {
                history = history.toArray(o.historyDivider);
            }
            if (append === true) {
                $.each(history, function () {
                    that.history.push(this);
                })
            } else{
                this.history = history;
            }
            this.historyIndex = this.history.length - 1;
        },

        clear: function(){
            this.element.val('');
        },

        toDefault: function(){
            this.element.val(Utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        setAutocompleteList: function(l){
            var autocomplete_list = Utils.isObject(l);
            if (autocomplete_list !== false) {
                this.autocomplete = autocomplete_list;
            } else if (typeof l === "string") {
                this.autocomplete = l.toArray(this.options.autocompleteDivider);
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var parent = element.parent();
            var clearBtn = parent.find(".input-clear-button");
            var revealBtn = parent.find(".input-reveal-button");
            var customBtn = parent.find(".input-custom-button");

            if (clearBtn.length > 0) {
                clearBtn.off(Metro.events.click);
            }
            if (revealBtn.length > 0) {
                revealBtn.off(Metro.events.start);
                revealBtn.off(Metro.events.stop);
            }
            if (customBtn.length > 0) {
                clearBtn.off(Metro.events.click);
            }

            element.off(Metro.events.blur);
            element.off(Metro.events.focus);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.input .autocomplete-list').hide();
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var KeylockDefaultConfig = {
        keylockDeferred: 0,

        stateOnIcon: "<span>&times;</span>",
        stateOffIcon: "<span>&checkmark;</span>",

        transition: true,

        onCaption: "",
        offCaption: "",
        captionPosition: "right",

        clsKeylock: "",
        clsStateOn: "",
        clsStateOff: "",
        clsCaption: "",
        clsIcon: "",
        clsOnCaption: "",
        clsOffCaption: "",

        onKeylockCreate: Metro.noop
    };

    Metro.keylockSetup = function (options) {
        KeylockDefaultConfig = $.extend({}, KeylockDefaultConfig, options);
    };

    if (typeof window["metroKeylockSetup"] !== undefined) {
        Metro.keylockSetup(window["metroKeylockSetup"]);
    }

    Metro.Component('keylock', {
        init: function( options, elem ) {
            this._super(elem, options, KeylockDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var container;
            var icon = $("<span>").addClass("icon").addClass(o.clsIcon);
            var caption = $("<span>").addClass("caption").addClass(o.clsCaption);
            var stateOnIcon = $(o.stateOnIcon).addClass("state-on").addClass(o.clsStateOn);
            var stateOffIcon = $(o.stateOffIcon).addClass("state-off").addClass(o.clsStateOff);
            var onCaption = $("<span>").addClass("state-on").addClass(o.clsOnCaption).html(o.onCaption);
            var offCaption = $("<span>").addClass("state-off").addClass(o.clsOffCaption).html(o.offCaption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            container = element.wrap(
                $("<label>").addClass("keylock").addClass(o.clsKeylock)
            );

            icon.appendTo(container);
            caption.appendTo(container);

            stateOnIcon.appendTo(icon);
            stateOffIcon.appendTo(icon);

            onCaption.appendTo(caption);
            offCaption.appendTo(caption);

            if (o.transition === true) {
                container.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                container.addClass("caption-left");
            }

            element[0].className = '';

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            this._fireEvent("keylock-create");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                element.prop("checked", v === 1);
            }

            return this;
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    //var Utils = Metro.utils;
    var KeypadDefaultConfig = {
        keypadDeferred: 0,
        label: "",
        keySize: 48,
        keys: "1, 2, 3, 4, 5, 6, 7, 8, 9, 0",
        exceptKeys: "",
        keySeparator: "",
        trimSeparator: false,
        keyDelimiter: ",",
        copyInlineStyles: false,
        target: null,
        keyLength: 0,
        shuffle: false,
        shuffleCount: 3,
        position: Metro.position.BOTTOM_LEFT, //top-left, top, top-right, right, bottom-right, bottom, bottom-left, left
        dynamicPosition: false,
        serviceButtons: true,
        showValue: true,
        open: false,
        sizeAsKeys: false,

        clsKeypad: "",
        clsInput: "",
        clsKeys: "",
        clsKey: "",
        clsServiceKey: "",
        clsBackspace: "",
        clsClear: "",
        clsLabel: "",

        onChange: Metro.noop,
        onClear: Metro.noop,
        onBackspace: Metro.noop,
        onShuffle: Metro.noop,
        onKey: Metro.noop,
        onKeypadCreate: Metro.noop
    };

    Metro.keypadSetup = function (options) {
        KeypadDefaultConfig = $.extend({}, KeypadDefaultConfig, options);
    };

    if (typeof window["metroKeypadSetup"] !== undefined) {
        Metro.keypadSetup(window["metroKeypadSetup"]);
    }

    Metro.Component('keypad', {
        init: function( options, elem ) {
            this._super(elem, options, KeypadDefaultConfig, {
                value: elem.tagName === 'INPUT' ? elem.value : elem.innerText,
                positions: ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"],
                keypad: null,
                keys: [],
                keys_to_work: [],
                exceptKeys: []
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.keys = o.keys.toArray(o.keyDelimiter);
            this.keys_to_work = this.keys;
            this.exceptKeys = o.exceptKeys.toArray(o.keyDelimiter);

            this._createKeypad();
            if (o.shuffle === true) {
                this.shuffle();
            }
            this._createKeys();
            this._createEvents();

            this._fireEvent("keypad-create", {
                element: element
            });
        },

        _createKeypad: function(){
            var element = this.element, o = this.options;
            var parent = element.parent();
            var keypad, keys;

            if (parent.hasClass("input")) {
                keypad = parent;
            } else {
                keypad = $("<div>").addClass("input").addClass(element[0].className);
            }

            keypad.addClass("keypad");
            if (keypad.css("position") === "static" || keypad.css("position") === "") {
                keypad.css({
                    position: "relative"
                });
            }

            if (element.attr("type") === undefined) {
                element.attr("type", "text");
            }

            keypad.insertBefore(element);

            element.attr("readonly", true);
            element.appendTo(keypad);

            keys = $("<div>").addClass("keys").addClass(o.clsKeys);
            keys.appendTo(keypad);
            this._setKeysPosition();

            if (o.open === true) {
                keys.addClass("open keep-open");
            }


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    keypad.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            element.addClass(o.clsInput);
            keypad.addClass(o.clsKeypad);

            element.on(Metro.events.blur, function(){keypad.removeClass("focused");});
            element.on(Metro.events.focus, function(){keypad.addClass("focused");});

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(keypad);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (o.disabled === true || element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.keypad = keypad;
        },

        _setKeysPosition: function(){
            var element = this.element, o = this.options;
            var keypad = element.parent();
            var keys = keypad.find(".keys");
            keys.removeClass(this.positions.join(" ")).addClass(o.position)
        },

        _createKeys: function(){
            var element = this.element, o = this.options;
            var keypad = element.parent();
            var key, keys = keypad.find(".keys");
            var factor = Math.round(Math.sqrt(this.keys.length + 2));
            var key_size = o.keySize;
            var width;

            keys.html("");

            $.each(this.keys_to_work, function(){
                key = $("<span>").addClass("key").addClass(o.clsKey).html(this);
                key.data("key", this);
                key.css({
                    width: o.keySize,
                    height: o.keySize,
                    lineHeight: o.keySize - 4
                }).appendTo(keys);
            });

            if (o.serviceButtons === true) {

                var service_keys = ['&larr;', '&times;'];

                $.each(service_keys, function () {
                    key = $("<span>").addClass("key service-key").addClass(o.clsKey).addClass(o.clsServiceKey).html(this);
                    if (this === '&larr;') {
                        key.addClass(o.clsBackspace);
                    }
                    if (this === '&times;') {
                        key.addClass(o.clsClear);
                    }
                    key.data("key", this);
                    key.css({
                        width: o.keySize,
                        height: o.keySize,
                        lineHeight: o.keySize - 4
                    }).appendTo(keys);
                });
            }

            width = factor * (key_size + 2) - 6;
            keys.outerWidth(width);

            if (o.sizeAsKeys === true && ['top-left', 'top', 'top-right', 'bottom-left', 'bottom', 'bottom-right'].indexOf(o.position) !== -1) {
                keypad.outerWidth(keys.outerWidth());
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var keypad = element.parent();
            var keys = keypad.find(".keys");

            keys.on(Metro.events.click, ".key", function(e){
                var key = $(this);
                var keyValue = key.data("key");
                var crop;

                if (key.data('key') !== '&larr;' && key.data('key') !== '&times;') {

                    if (o.keyLength > 0 && (""+that.value).length === o.keyLength) {
                        return false;
                    }

                    if (that.exceptKeys.indexOf(keyValue) === -1)
                        that.value = that.value + (that.value !== "" ? o.keySeparator : "") + keyValue;

                    if (o.shuffle === true) {
                        that.shuffle();
                        that._createKeys();
                    }

                    if (o.dynamicPosition === true) {
                        o.position = that.positions[$.random(0, that.positions.length - 1)];
                        that._setKeysPosition();
                    }

                    that._fireEvent("key", {
                        key: key.data("key"),
                        val: that.value
                    });

                } else {
                    if (key.data('key') === '&times;') {
                        that.value = "";
                        that._fireEvent("clear");
                    }
                    if (key.data('key') === '&larr;') {
                        crop = o.keySeparator && that.value[that.value.length - 1] !== o.keySeparator ? 2 : 1;
                        that.value = (that.value.substring(0, that.value.length - crop));
                        that._fireEvent("backspace", {
                            val: that.value
                        });
                    }
                }

                if (o.showValue === true) {
                    if (element[0].tagName === "INPUT") {
                        element.val(that.value);
                    } else {
                        element.text(that.value);
                    }
                }

                that._fireEvent('change', {
                    val: that.val
                })
                // element.trigger('change');
                // Utils.exec(o.onChange, [that.value], element[0]);

                e.preventDefault();
                e.stopPropagation();
            });

            keypad.on(Metro.events.click, function(e){
                if (o.open === true) {
                    return ;
                }

                if (keys.hasClass("open") === true) {
                    keys.removeClass("open");
                } else {
                    keys.addClass("open");
                }

                e.preventDefault();
                e.stopPropagation();
            });

            if (o.target !== null) {
                element.on(Metro.events.change, function(){
                    var t = $(o.target);
                    if (t.length === 0) {
                        return ;
                    }
                    if (t[0].tagName === "INPUT") {
                        t.val(that.value);
                    } else {
                        t.text(that.value);
                    }
                });
            }
        },

        shuffle: function(){
            var o = this.options;
            for (var i = 0; i < o.shuffleCount; i++) {
                this.keys_to_work = this.keys_to_work.shuffle();
            }

            this._fireEvent("shuffle", {
                keysToWork: this.keys_to_work,
                keys: this.keys
            });
        },

        shuffleKeys: function(count){
            if (count === undefined) {
                count = this.options.shuffleCount;
            }
            for (var i = 0; i < count; i++) {
                this.keys_to_work = this.keys_to_work.shuffle();
            }
            this._createKeys();
        },

        val: function(v){
            var element = this.element, o = this.options;

            if (typeof v === "undefined") {
                return o.trimSeparator ? this.value.replace(new RegExp(o.keySeparator, "g")) : this.value;
            }

            this.value = ""+v;

            if (element[0].tagName === "INPUT") {
                element.val(v);
                // set cursor to end position
            } else {
                element.text(v)
            }

            return this;
        },

        open: function(){
            var element = this.element;
            var keypad = element.parent();
            var keys = keypad.find(".keys");

            keys.addClass("open");
        },

        close: function(){
            var element = this.element;
            var keypad = element.parent();
            var keys = keypad.find(".keys");

            keys.removeClass("open");
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        setPosition: function(pos){
            var new_position = pos !== undefined ? pos : this.element.attr("data-position");
            if (this.positions.indexOf(new_position) === -1) {
                return ;
            }
            this.options.position = new_position;
            this._setKeysPosition();
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-position': this.setPosition(); break;
            }
        },

        destroy: function(){
            var element = this.element, keypad = this.keypad, keys = keypad.find(".keys");

            keypad.off(Metro.events.click);
            keys.off(Metro.events.click, ".key");
            element.off(Metro.events.change);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        var keypads = $(".keypad .keys");
        $.each(keypads, function(){
            if (!$(this).hasClass("keep-open")) {
                $(this).removeClass("open");
            }
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var LightboxDefaultConfig = {
        loop: true,
        source: "img",

        iconClose: "<span class='default-icon-cross'>",
        iconPrev: "<span class='default-icon-chevron-left'>",
        iconNext: "<span class='default-icon-chevron-right'>",

        clsNext: "",
        clsPrev: "",
        clsClose: "",
        clsImage: "",
        clsImageContainer: "",
        clsImageWrapper: "",
        clsLightbox: "",

        onDrawImage: Metro.noop,
        onLightboxCreate: Metro.noop
    };

    Metro.lightboxSetup = function (options) {
        LightboxDefaultConfig = $.extend({}, LightboxDefaultConfig, options);
    };

    if (typeof window["metroLightboxSetup"] !== undefined) {
        Metro.lightboxSetup(window["metroLightboxSetup"]);
    }

    Metro.Component('lightbox', {
        init: function( options, elem ) {
            this._super(elem, options, LightboxDefaultConfig, {
                // define instance vars here
                overlay: null,
                lightbox: null,
                current: null,
                items: []
            });
            return this;
        },

        _create: function(){
            var o = this.options;

            if (!o.source) {
                o.source = "img";
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent('lightbox-create');
        },

        _createStructure: function(){
            var o = this.options;
            var lightbox, overlay;

            overlay = $(".lightbox-overlay");

            if (overlay.length === 0) {
                overlay = $("<div>").addClass("lightbox-overlay").appendTo("body").hide();
            }

            lightbox = $("<div>").addClass("lightbox").addClass(o.clsLightbox).appendTo("body").hide();

            $("<span>").addClass("lightbox__prev").addClass(o.clsPrev).html(o.iconPrev).appendTo(lightbox);
            $("<span>").addClass("lightbox__next").addClass(o.clsNext).html(o.iconNext).appendTo(lightbox);
            $("<span>").addClass("lightbox__closer").addClass(o.clsClose).html(o.iconClose).appendTo(lightbox);
            $("<div>").addClass("lightbox__image").addClass(o.clsImageContainer).appendTo(lightbox);

            this.component = lightbox[0];
            this.lightbox = lightbox;
            this.overlay = overlay;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var lightbox = $(this.component);

            element.on(Metro.events.click, o.source, function(){
                that.open(this);
            });

            lightbox.on(Metro.events.click, ".lightbox__closer", function(){
                that.close();
            });

            lightbox.on(Metro.events.click, ".lightbox__prev", function(){
                that.prev();
            });

            lightbox.on(Metro.events.click, ".lightbox__next", function(){
                that.next();
            });
        },

        _setupItems: function(){
            var element = this.element, o = this.options;
            var items = element.find(o.source);

            if (items.length === 0) {
                return ;
            }

            this.items = items;
        },

        _goto: function(el){
            var that = this, o = this.options;
            var $el = $(el);
            var img = $("<img>"), src;
            var imageContainer, imageWrapper, activity;

            imageContainer = this.lightbox.find(".lightbox__image");

            imageContainer.find(".lightbox__image-wrapper").remove();
            imageWrapper = $("<div>")
                .addClass("lightbox__image-wrapper")
                .addClass(o.clsImageWrapper)
                .attr("data-title", ($el.attr("alt") || $el.attr("data-title") || ""))
                .appendTo(imageContainer);

            activity = $("<div>").appendTo(imageWrapper);

            Metro.makePlugin(activity, "activity", {
                type: "cycle",
                style: "color"
            });

            this.current = el;

            if (el.tagName === "IMG" || el.tagName === "DIV") {
                src = $el.attr("data-original") || $el.attr("src");
                img.attr("src", src);
                img[0].onload = function(){
                    var port = this.height > this.width;
                    img.addClass(port ? "lightbox__image-portrait" : "lightbox__image-landscape").addClass(o.clsImage);
                    img.attr("alt", $el.attr("alt"));
                    img.appendTo(imageWrapper);
                    activity.remove();
                    that._fireEvent("draw-image", {
                        image: img[0],
                        item: imageWrapper[0]
                    });
                }
            }
        },

        _index: function(el){
            var index = -1;

            this.items.each(function(i){
                if (this === el) {
                    index = i;
                }
            });

            return index;
        },

        next: function(){
            var index, current = this.current;

            index = this._index(current);

            if (index + 1 >= this.items.length) {
                if (this.options.loop) {
                    index = -1;
                } else {
                    return;
                }
            }

            this._goto(this.items[index + 1]);
        },

        prev: function(){
            var index, current = this.current;

            index = this._index(current);

            if (index - 1 < 0) {
                if (this.options.loop) {
                    index = this.items.length;
                } else {
                    return;
                }
            }

            this._goto(this.items[index - 1]);
        },

        open: function(el){
            this._setupItems();

            this._goto(el);

            this.overlay.show();
            this.lightbox.show();

            return this;
        },

        close: function(){
            this.overlay.hide();
            this.lightbox.hide();
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ListDefaultConfig = {
        locale: METRO_LOCALE,
        listDeferred: 0,
        templateBeginToken: "<%",
        templateEndToken: "%>",
        paginationDistance: 5,
        paginationShortMode: true,
        thousandSeparator: ",",
        decimalSeparator: ",",
        itemTag: "li",
        defaultTemplateTag: "div",
        sortClass: null,
        sortDir: "asc",
        sortInitial: true,
        filterClass: null,
        filter: null,
        filterString: "",
        filters: null,
        source: null,
        showItemsSteps: false,
        showSearch: false,
        showListInfo: false,
        showPagination: false,
        showActivity: true,
        muteList: true,
        items: -1,
        itemsSteps: "all, 10,25,50,100",
        itemsAllTitle: "Show all",
        listItemsCountTitle: "Show entries:",
        listSearchTitle: "Search:",
        listInfoTitle: "Showing $1 to $2 of $3 entries",
        paginationPrevTitle: "Prev",
        paginationNextTitle: "Next",
        activityType: "cycle",
        activityStyle: "color",
        activityTimeout: 100,
        searchWrapper: null,
        rowsWrapper: null,
        infoWrapper: null,
        paginationWrapper: null,
        clsComponent: "",
        clsList: "",
        clsListItem: "",
        clsListTop: "",
        clsItemsCount: "",
        clsSearch: "",
        clsListBottom: "",
        clsListInfo: "",
        clsListPagination: "",
        clsPagination: "",
        clsTemplateTag: "",
        onDraw: Metro.noop,
        onDrawItem: Metro.noop,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSearch: Metro.noop,
        onRowsCountChange: Metro.noop,
        onDataLoad: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataLoadError: Metro.noop,
        onFilterItemAccepted: Metro.noop,
        onFilterItemDeclined: Metro.noop,
        onListCreate: Metro.noop
    };

    Metro.listSetup = function (options) {
        ListDefaultConfig = $.extend({}, ListDefaultConfig, options);
    };

    if (typeof window["metroListSetup"] !== undefined) {
        Metro.listSetup(window["metroListSetup"]);
    }

    Metro.Component('list', {
        init: function( options, elem ) {
            this._super(elem, options, ListDefaultConfig, {
                currentPage: 1,
                pagesCount: 1,
                filterString: "",
                data: null,
                activity: null,
                busy: false,
                filters: [],
                wrapperInfo: null,
                wrapperSearch: null,
                wrapperRows: null,
                wrapperPagination: null,
                filterIndex: null,
                filtersIndexes: [],
                itemTemplate: null,

                sort: {
                    dir: "asc",
                    colIndex: 0
                },

                header: null,
                items: []
            });

            return this;
        },

        _create: function(){
            var that = this, o = this.options;

            if (o.source) {
                that._fireEvent("data-load", {
                    source: o.source
                });

                fetch(o.source)
                    .then(Metro.fetch.status)
                    .then(Metro.fetch.json)
                    .then(function(data){
                        that._fireEvent("data-loaded", {
                            source: o.source,
                            data: data
                        });
                        that._build(data);
                    })
                    .catch(function(error){
                        that._fireEvent("data-load-error", {
                            source: o.source,
                            error: error
                        });
                    });

            } else {
                that._build();
            }
        },

        _build: function(data){
            if (Utils.isValue(data)) {
                this._createItemsFromJSON(data);
            } else {
                this._createItemsFromHTML()
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("list-create");
        },

        _createItemsFromHTML: function(){
            var that = this, element = this.element, o = this.options;
            var clsTemplateTag = (""+o.clsTemplateTag).toArray(",")

            this.items = [];

            $.each(element.children(o.itemTag), function(){
                var tagChildren = $(this).children("*");

                if (clsTemplateTag.length) {
                    if (clsTemplateTag.length === 1) {
                        tagChildren.addClass(clsTemplateTag[0]);
                    } else {
                        tagChildren.each(function (i, child) {
                            $(child).addClass(clsTemplateTag[i] ? clsTemplateTag[i] : clsTemplateTag[clsTemplateTag.length - 1]);
                        })
                    }
                }
                that.items.push(this);
            });
        },

        _createItemsFromJSON: function(source){
            var that = this, o = this.options;
            var clsTemplateTag = (""+o.clsTemplateTag).toArray(",")

            this.items = [];

            if (Utils.isValue(source.template)) {
                this.itemTemplate = source.template;
            }

            if (Utils.isValue(source.header)) {
                this.header = source.header;
            }

            if (Utils.isValue(source.data)) {
                $.each(source.data, function(){
                    var item = '', row = this;
                    var li = document.createElement(o.itemTag);
                    var tpl = that.itemTemplate;
                    var tagChildren;

                    if (!Utils.isValue(tpl)) {
                        for (var i in row) {
                            item += "<"+o.defaultTemplateTag+">"+row[i]+"</"+o.defaultTemplateTag+">";
                        }
                    } else {
                        item = Metro.template(tpl, row, {
                            beginToken: o.templateBeginToken,
                            endToken: o.templateEndToken
                        });
                    }

                    li.innerHTML = item;
                    tagChildren = $(li).children("*");

                    if (clsTemplateTag.length) {
                        if (clsTemplateTag.length === 1) {
                            tagChildren.addClass(clsTemplateTag[0]);
                        } else {
                            tagChildren.each(function (i, child) {
                                $(child).addClass(clsTemplateTag[i] ? clsTemplateTag[i] : clsTemplateTag[clsTemplateTag.length - 1]);
                            })
                        }
                    }

                    that.items.push(li);
                });
            }
        },

        _createTopBlock: function (){
            var that = this, element = this.element, o = this.options;
            var top_block = $("<div>").addClass("list-top").addClass(o.clsListTop).insertBefore(element);
            var search_block, search_input, rows_block, rows_select;

            search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $("<div>").addClass("list-search-block").addClass(o.clsSearch).appendTo(top_block);

            search_input = $("<input>").attr("type", "text").appendTo(search_block);
            search_input.input({
                prepend: o.listSearchTitle
            });

            if (o.showSearch !== true) {
                search_block.hide();
            }

            rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $("<div>").addClass("list-rows-block").addClass(o.clsItemsCount).appendTo(top_block);

            rows_select = $("<select>").appendTo(rows_block);
            $.each(o.itemsSteps.toArray(), function () {
                var option = $("<option>").attr("value", this === "all" ? -1 : this).text(this === "all" ? o.itemsAllTitle : this).appendTo(rows_select);
                if (+this === +o.items) option.attr("selected", "selected");
            });
            rows_select.select({
                filter: false,
                prepend: o.listItemsCountTitle,
                onChange: function (val) {
                    if (+val === +o.items) return;
                    o.items = parseInt(val);
                    that.currentPage = 1;
                    that._draw();

                    that._fireEvent("rows-count-change", {
                        val: val
                    });
                }
            });

            if (o.showItemsSteps !== true) {
                rows_block.hide();
            }

            return top_block;
        },

        _createBottomBlock: function (){
            var element = this.element, o = this.options;
            var bottom_block = $("<div>").addClass("list-bottom").addClass(o.clsListBottom).insertAfter(element);
            var info, pagination;

            info = $("<div>").addClass("list-info").addClass(o.clsListInfo).appendTo(bottom_block);
            if (o.showListInfo !== true) {
                info.hide();
            }

            pagination = $("<div>").addClass("list-pagination").addClass(o.clsListPagination).appendTo(bottom_block);
            if (o.showPagination !== true) {
                pagination.hide();
            }

            return bottom_block;
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var list_component;
            var w_search = $(o.searchWrapper),
                w_info = $(o.infoWrapper),
                w_rows = $(o.rowsWrapper),
                w_paging = $(o.paginationWrapper);

            if (w_search.length > 0) {this.wrapperSearch = w_search;}
            if (w_info.length > 0) {this.wrapperInfo = w_info;}
            if (w_rows.length > 0) {this.wrapperRows = w_rows;}
            if (w_paging.length > 0) {this.wrapperPagination = w_paging;}

            if (!element.parent().hasClass("list-component")) {
                list_component = $("<div>").addClass("list-component").insertBefore(element);
                element.appendTo(list_component);
            } else {
                list_component = element.parent();
            }

            list_component.addClass(o.clsComponent);

            this.activity =  $("<div>").addClass("list-progress").appendTo(list_component);
            $("<div>").activity({
                type: o.activityType,
                style: o.activityStyle
            }).appendTo(this.activity);

            if (o.showActivity !== true) {
                this.activity.css({
                    visibility: "hidden"
                })
            }

            // element.html("").addClass(o.clsList);
            element.addClass(o.clsList);

            this._createTopBlock();
            this._createBottomBlock();

            if (Utils.isValue(o.filterString)) {
                this.filterString = o.filterString;
            }

            var filter_func;

            if (Utils.isValue(o.filter)) {
                filter_func = Utils.isFunc(o.filter);
                if (filter_func === false) {
                    filter_func = Utils.func(o.filter);
                }
                that.filterIndex = that.addFilter(filter_func);
            }

            if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                $.each(o.filters.toArray(), function(){
                    filter_func = Utils.isFunc(this);
                    if (filter_func !== false) {
                        that.filtersIndexes.push(that.addFilter(filter_func));
                    }
                });
            }

            this.currentPage = 1;

            if (o.sortInitial !== false)
                this.sorting(o.sortClass, o.sortDir, true);
            else
                this.draw();
        },

        _createEvents: function(){
            var that = this, element = this.element;
            var component = element.parent();
            var search = component.find(".list-search-block input");
            var customSearch;

            search.on(Metro.events.inputchange, function(){
                that.filterString = this.value.trim().toLowerCase();
                if (that.filterString[that.filterString.length - 1] === ":") {
                    return ;
                }
                that.currentPage = 1;
                that._draw();
            });

            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.on(Metro.events.inputchange, function(){
                        that.filterString = this.value.trim().toLowerCase();
                        if (that.filterString[that.filterString.length - 1] === ":") {
                            return ;
                        }
                        that.currentPage = 1;
                        that._draw();
                    });
                }
            }

            function pageLinkClick(l){
                var link = $(l);
                var item = link.parent();

                if (item.hasClass("active")) {
                    return ;
                }

                if (item.hasClass("service")) {
                    if (link.data("page") === "prev") {
                        that.currentPage--;
                        if (that.currentPage === 0) {
                            that.currentPage = 1;
                        }
                    } else {
                        that.currentPage++;
                        if (that.currentPage > that.pagesCount) {
                            that.currentPage = that.pagesCount;
                        }
                    }
                } else {
                    that.currentPage = link.data("page");
                }

                that._draw();
            }

            component.on(Metro.events.click, ".pagination .page-link", function(){
                pageLinkClick(this)
            });

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.on(Metro.events.click, ".pagination .page-link", function(){
                    pageLinkClick(this)
                });
            }
        },

        _info: function(start, stop, length){
            var element = this.element, o = this.options;
            var component = element.parent();
            var info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".list-info");
            var text;

            if (info.length === 0) {
                return ;
            }

            if (stop > length) {
                stop = length;
            }

            if (this.items.length === 0) {
                start = stop = length = 0;
            }

            text = o.listInfoTitle;
            text = text.replace("$1", start);
            text = text.replace("$2", stop);
            text = text.replace("$3", length);
            info.html(text);
        },

        _paging: function(length){
            var element = this.element, o = this.options;
            var component = element.parent();
            this.pagesCount = Math.ceil(length / o.items); // Костыль
            Metro.pagination({
                length: length,
                rows: o.items,
                current: this.currentPage,
                target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".list-pagination"),
                claPagination: o.clsPagination,
                prevTitle: o.paginationPrevTitle,
                nextTitle: o.paginationNextTitle,
                distance: o.paginationShortMode === true ? o.paginationDistance : 0
            });
        },

        _filter: function(){
            var that = this,
                o = this.options,
                items, i, data, inset, c1, result;

            if (Utils.isValue(this.filterString) || this.filters.length > 0) {
                items = this.items.filter(function(item){
                    data = "";

                    if (Utils.isValue(o.filterClass)) {
                        inset = item.getElementsByClassName(o.filterClass);

                        if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                            data += inset[i].textContent;
                        }
                    } else {
                        data = item.textContent;
                    }

                    c1 = data.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim().toLowerCase();
                    result = Utils.isValue(that.filterString) ? c1.indexOf(that.filterString) > -1 : true;

                    if (result === true && that.filters.length > 0) {
                        for (i = 0; i < that.filters.length; i++) {
                            if (Utils.exec(that.filters[i], [item]) !== true) {
                                result = false;
                                break;
                            }
                        }
                    }

                    if (result) {

                        that._fireEvent("filter-item-accepted", {
                            item: item
                        });

                    } else {

                        that._fireEvent("filter-item-declined", {
                            item: item
                        });

                    }

                    return result;
                });

                that._fireEvent("search", {
                    search: that.filterString,
                    items: items
                });

            } else {
                items = this.items;
            }

            return items;
        },

        _draw: function(cb){
            var element = this.element, o = this.options;
            var i;
            var start = o.items === -1 ? 0 : o.items * (this.currentPage - 1),
                stop = o.items === -1 ? this.items.length - 1 : start + o.items - 1;
            var items;

            items = this._filter();

            element.children(o.itemTag).remove();

            for (i = start; i <= stop; i++) {
                if (Utils.isValue(items[i])) {
                    $(items[i]).addClass(o.clsListItem).appendTo(element);
                }

                this._fireEvent("draw-item", {
                    item: items[i]
                });

            }

            this._info(start + 1, stop + 1, items.length);
            this._paging(items.length);

            this.activity.hide();

            this._fireEvent("draw");

            if (cb !== undefined) {
                Utils.exec(cb, [element], element[0])
            }
        },

        _getItemContent: function(item){
            var o = this.options, $item = $(item);
            var i, inset, data;
            var format, formatMask = Utils.isValue($item.data("formatMask")) ? $item.data("formatMask") : null;

            if (Utils.isValue(o.sortClass)) {
                data = "";
                inset = $(item).find("."+o.sortClass);

                if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                    data += inset[i].textContent;
                }
                format = inset.length > 0 ? inset[0].getAttribute("data-format") : "";
            } else {
                data = item.textContent;
                format = item.getAttribute("data-format");
            }

            data = (""+data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(format)) {

                if (['number', 'int', 'integer', 'float', 'money'].indexOf(format) !== -1 && (o.thousandSeparator !== "," || o.decimalSeparator !== "." )) {
                    data = Utils.parseNumber(data, o.thousandSeparator, o.decimalSeparator);
                }

                switch (format) {
                    case "date": data = formatMask ? Datetime.from(data, formatMask, o.locale) : datetime(data); break;
                    case "number": data = Number(data); break;
                    case "int":
                    case "integer": data = parseInt(data); break;
                    case "float": data = parseFloat(data); break;
                    case "money": data = Utils.parseMoney(data); break;
                    case "card": data = Utils.parseCard(data); break;
                    case "phone": data = Utils.parsePhone(data); break;
                }
            }

            return data;
        },

        deleteItem: function(value){
            var i, deleteIndexes = [], item;
            var is_func = Utils.isFunc(value);

            for (i = 0; i < this.items.length; i++) {
                item = this.items[i];

                if (is_func) {
                    if (Utils.exec(value, [item])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (item.textContent.includes(value)) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        draw: function(){
            return this._draw();
        },

        sorting: function(source, dir, redraw){
            var that = this, o = this.options;

            if (Utils.isValue(source)) {
                o.sortClass = source;
            }
            if (Utils.isValue(dir) && ["asc", "desc"].indexOf(dir) > -1) {
                o.sortDir= dir;
            }

            this._fireEvent("sort-start", {
                items: this.items
            });

            this.items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2) {
                    result = o.sortDir === "asc" ? -1 : 1;
                }
                if (c1 > c2) {
                    result = o.sortDir === "asc" ? 1 : -1;
                }

                if (result !== 0) {

                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            this._fireEvent("sort-stop", {
                items: this.items
            })

            if (redraw === true) {
                this._draw();
            }

            return this;
        },

        filter: function(val){
            this.filterString = val.trim().toLowerCase();
            this.currentPage = 1;
            this._draw();
        },

        loadData: function(source){
            var that = this, element = this.element, o = this.options;

            if (Utils.isValue(source) !== true) {
                return ;
            }

            o.source = source;

            this._fireEvent("data-load", {
                source: o.source
            });

            fetch(o.source)
                .then(Metro.fetch.status)
                .then(Metro.fetch.json)
                .then(function(data){
                    that._fireEvent("data-loaded", {
                        source: o.source,
                        data: data
                    });

                    that._createItemsFromJSON(data);

                    element.html("");

                    if (Utils.isValue(o.filterString)) {
                        that.filterString = o.filterString;
                    }

                    var filter_func;

                    if (Utils.isValue(o.filter)) {
                        filter_func = Utils.isFunc(o.filter);
                        if (filter_func === false) {
                            filter_func = Utils.func(o.filter);
                        }
                        that.filterIndex = that.addFilter(filter_func);
                    }

                    if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                        $.each(o.filters.toArray(), function(){
                            filter_func = Utils.isFunc(this);
                            if (filter_func !== false) {
                                that.filtersIndexes.push(that.addFilter(filter_func));
                            }
                        });
                    }

                    that.currentPage = 1;

                    that.sorting(o.sortClass, o.sortDir, true);
                })
                .catch(function(error){
                    that._fireEvent("data-load-error", {
                        source: o.source,
                        error: error
                    });
                });

        },

        next: function(){
            if (this.items.length === 0) return ;
            this.currentPage++;
            if (this.currentPage > this.pagesCount) {
                this.currentPage = this.pagesCount;
                return ;
            }
            this._draw();
        },

        prev: function(){
            if (this.items.length === 0) return ;
            this.currentPage--;
            if (this.currentPage === 0) {
                this.currentPage = 1;
                return ;
            }
            this._draw();
        },

        first: function(){
            if (this.items.length === 0) return ;
            this.currentPage = 1;
            this._draw();
        },

        last: function(){
            if (this.items.length === 0) return ;
            this.currentPage = this.pagesCount;
            this._draw();
        },

        page: function(num){
            if (num <= 0) {
                num = 1;
            }

            if (num > this.pagesCount) {
                num = this.pagesCount;
            }

            this.currentPage = num;
            this._draw();
        },

        addFilter: function(f, redraw){
            var func = Utils.isFunc(f);
            if (func === false) {
                return ;
            }
            this.filters.push(func);

            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }

            return this.filters.length - 1;
        },

        removeFilter: function(key, redraw){
            Utils.arrayDeleteByKey(this.filters, key);
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        removeFilters: function(redraw){
            this.filters = [];
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
        },

        getFilters: function(){
            return this.filters;
        },

        getFilterIndex: function(){
            return this.filterIndex;
        },

        getFiltersIndexes: function(){
            return this.filtersIndexes;
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeSortDir = function(){
                var dir = element.attr("data-sort-dir");
                if (!Utils.isValue(dir)) {
                    return ;
                }
                o.sortDir = dir;
                that.sorting(o.sortClass, o.sortDir, true);
            };

            var changeSortClass = function(){
                var target = element.attr("data-sort-source");
                if (!Utils.isValue(target)) {
                    return ;
                }
                o.sortClass = target;
                that.sorting(o.sortClass, o.sortDir, true);
            };

            var changeFilterString = function(){
                var filter = element.attr("data-filter-string");
                if (!Utils.isValue(filter)) {
                    return ;
                }
                o.filterString = filter;
                that.filter(o.filterString);
            };

            switch (attributeName) {
                case "data-sort-dir": changeSortDir(); break;
                case "data-sort-source": changeSortClass(); break;
                case "data-filter-string": changeFilterString(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var component = element.parent();
            var search = component.find(".list-search-block input");
            var customSearch;

            search.off(Metro.events.inputchange);
            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.off(Metro.events.inputchange);
                }
            }

            component.off(Metro.events.click, ".pagination .page-link");

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.off(Metro.events.click, ".pagination .page-link");
            }

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ListViewDefaultConfig = {
        listviewDeferred: 0,
        selectable: false,
        checkStyle: 1,
        duration: 100,
        view: Metro.listView.LIST,
        selectCurrent: true,
        structure: {},
        onNodeInsert: Metro.noop,
        onNodeDelete: Metro.noop,
        onNodeClean: Metro.noop,
        onCollapseNode: Metro.noop,
        onExpandNode: Metro.noop,
        onGroupNodeClick: Metro.noop,
        onNodeClick: Metro.noop,
        onNodeDblclick: Metro.noop,
        onListViewCreate: Metro.noop
    };

    Metro.listViewSetup = function (options) {
        ListViewDefaultConfig = $.extend({}, ListViewDefaultConfig, options);
    };

    if (typeof window["metroListViewSetup"] !== undefined) {
        Metro.listViewSetup(window["metroListViewSetup"]);
    }

    Metro.Component('listview', {
        init: function( options, elem ) {
            this._super(elem, options, ListViewDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createView();
            this._createEvents();

            this._fireEvent("listview-create", {
                element: element
            });
        },

        _createIcon: function(data){
            var icon, src;

            src = Utils.isTag(data) ? $(data) : $("<img>").attr("src", data);
            icon = $("<span>").addClass("icon");
            icon.html(src.outerHTML());

            return icon;
        },

        _createCaption: function(data){
            return $("<div>").addClass("caption").html(data);
        },

        _createContent: function(data){
            return $("<div>").addClass("content").html(data);
        },

        _createToggle: function(){
            return $("<span>").addClass("node-toggle");
        },

        _createNode: function(data){
            var that = this, o = this.options;
            var node;

            node = $("<li>");

            if (data.caption !== undefined || data.content !== undefined ) {
                var d = $("<div>").addClass("data");
                node.prepend(d);
                if (data.caption !== undefined) d.append(that._createCaption(data.caption));
                if (data.content !== undefined) d.append(that._createContent(data.content));
            }

            if (data.icon !== undefined) {
                node.prepend(this._createIcon(data.icon));
            }

            if (Utils.objectLength(o.structure) > 0) $.each(o.structure, function(key, val){
                if (data[key] !== undefined) {
                    $("<div>").addClass("node-data item-data-"+key).addClass(data[val]).html(data[key]).appendTo(node);
                }
            });

            return node;
        },

        _createView: function(){
            var that = this, element = this.element, o = this.options;
            var nodes = element.find("li");
            var struct_length = Utils.objectLength(o.structure);

            element.addClass("listview");
            element.find("ul").addClass("listview");

            $.each(nodes, function(){
                var node = $(this);

                if (node.data("caption") !== undefined || node.data("content") !== undefined) {
                    var data = $("<div>").addClass("data");
                    node.prepend(data);
                    if (node.data("caption") !== undefined) data.append(that._createCaption(node.data("caption")));
                    if (node.data("content") !== undefined) data.append(that._createContent(node.data("content")));
                }

                if (node.data('icon') !== undefined) {
                    node.prepend(that._createIcon(node.data('icon')));
                }

                if (node.children("ul").length > 0) {
                    node.addClass("node-group");
                    node.append(that._createToggle());
                    if (node.data("collapsed") !== true) node.addClass("expanded");
                } else {
                    node.addClass("node");
                }

                if (node.hasClass("node")) {
                    var cb = $("<input type='checkbox' data-role='checkbox' data-style='"+o.checkStyle+"'>");
                    cb.data("node", node);
                    node.prepend(cb);
                }

                if (struct_length > 0) $.each(o.structure, function(key){
                    if (node.data(key) !== undefined) {
                        $("<div>").addClass("node-data item-data-"+key).addClass(node.data(key)).html(node.data(key)).appendTo(node);
                    }
                });
            });

            this.toggleSelectable();

            this.view(o.view);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.dblclick, ".node", function(){
                var node = $(this);
                that._fireEvent("node-dblclick", {
                    node: node
                });
            });

            element.on(Metro.events.click, ".node", function(){
                var node = $(this);
                element.find(".node").removeClass("current");
                node.toggleClass("current");
                if (o.selectCurrent === true) {
                    element.find(".node").removeClass("current-select");
                    node.toggleClass("current-select");
                }
                that._fireEvent("node-click", {
                    node: node
                });
            });

            element.on(Metro.events.click, ".node-toggle", function(){
                var node = $(this).closest("li");
                that.toggleNode(node);
            });

            element.on(Metro.events.click, ".node-group > .data > .caption", function(){
                var node = $(this).closest("li");
                element.find(".node-group").removeClass("current-group");
                node.addClass("current-group");

                that._fireEvent("group-node-click", {
                    node: node
                });

            });

            element.on(Metro.events.dblclick, ".node-group > .data > .caption", function(){
                var node = $(this).closest("li");
                that.toggleNode(node);

                that._fireEvent("node-dbl-click", {
                    node: node
                });
            });
        },

        view: function(v){
            var element = this.element, o = this.options;

            if (v === undefined) {
                return o.view;
            }

            o.view = v;

            $.each(Metro.listView, function(i, v){
                element.removeClass("view-"+v);
                element.find("ul").removeClass("view-"+v);
            });

            element.addClass("view-" + o.view);
            element.find("ul").addClass("view-" + o.view);
        },

        toggleNode: function(node){
            var o = this.options;
            var func;

            node=$(node);

            if (!node.hasClass("node-group")) {
                return ;
            }

            node.toggleClass("expanded");

            func = node.hasClass("expanded") !== true ? "slideUp" : "slideDown";

            this._fireEvent("collapse-node", {
                node: node
            });

            node.children("ul")[func](o.duration);
        },

        toggleSelectable: function(){
            var element = this.element, o = this.options;
            var func = o.selectable === true ? "addClass" : "removeClass";
            element[func]("selectable");
            element.find("ul")[func]("selectable");
        },

        add: function(node, data){
            var element = this.element, o = this.options;
            var target;
            var new_node;
            var toggle;

            if (node === null) {
                target = element;
            } else {

                node=$(node);

                if (!node.hasClass("node-group")) {
                    return ;
                }

                target = node.children("ul");
                if (target.length === 0) {
                    target = $("<ul>").addClass("listview").addClass("view-"+o.view).appendTo(node);
                    toggle = this._createToggle();
                    toggle.appendTo(node);
                    node.addClass("expanded");
                }
            }

            new_node = this._createNode(data);

            new_node.addClass("node").appendTo(target);

            var cb = $("<input type='checkbox'>");
            cb.data("node", new_node);
            new_node.prepend(cb);
            Metro.makePlugin(cb, "checkbox", {});

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: node,
                list: target
            });

            return new_node;
        },

        addGroup: function(data){
            var element = this.element, o = this.options;
            var node;

            delete data['icon'];

            node = this._createNode(data);
            node.addClass("node-group").appendTo(element);
            node.append(this._createToggle());
            node.addClass("expanded");
            node.append($("<ul>").addClass("listview").addClass("view-"+o.view));

            this._fireEvent("node-insert", {
                newNode: node,
                parentNode: null,
                list: element
            })

            return node;
        },

        insertBefore: function(node, data){
            var new_node, parent_node, list;

            node=$(node);

            if (!node.length) {return;}

            new_node = this._createNode(data);
            new_node.addClass("node").insertBefore(node);
            parent_node = new_node.closest(".node");
            list = new_node.closest("ul");

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: parent_node,
                list: list
            });

            return new_node;
        },

        insertAfter: function(node, data){
            var new_node, parent_node, list;

            node=$(node);

            if (!node.length) {return;}

            new_node = this._createNode(data);
            new_node.addClass("node").insertAfter(node);
            parent_node = new_node.closest(".node");
            list = new_node.closest("ul");

            this._fireEvent("node-insert", {
                newNode: new_node,
                parentNode: parent_node,
                list: list
            });

            return new_node;
        },

        del: function(node){
            var element = this.element;

            node=$(node);

            if (!node.length) {return;}

            var parent_list = node.closest("ul");
            var parent_node = parent_list.closest("li");
            node.remove();
            if (parent_list.children().length === 0 && !parent_list.is(element)) {
                parent_list.remove();
                parent_node.removeClass("expanded");
                parent_node.children(".node-toggle").remove();
            }

            this._fireEvent("node-delete", {
                node: node
            });
        },

        clean: function(node){
            node=$(node);

            if (!node.length) {return;}

            node.children("ul").remove();
            node.removeClass("expanded");
            node.children(".node-toggle").remove();

            this._fireEvent("node-clean", {
                node: node
            });
        },

        getSelected: function(){
            var element = this.element;
            var nodes = [];

            $.each(element.find(":checked"), function(){
                var check = $(this);
                nodes.push(check.closest(".node")[0])
            });

            return nodes;
        },

        clearSelected: function(){
            this.element.find(":checked").prop("checked", false);
            this.element.trigger('change');
        },

        selectAll: function(mode){
            this.element.find(".node > .checkbox input").prop("checked", mode !== false);
            this.element.trigger('change');
        },

        selectByAttribute: function(attributeName, attributeValue, select) {
            if (select !== false) {
                select = true;
            }
            this.element.find('li[' + attributeName + '="' + attributeValue + '"]' + ' > .checkbox input').prop("checked", select);
            this.element.trigger('change');
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeView = function(){
                var new_view = "view-"+element.attr("data-view");
                that.view(new_view);
            };

            var changeSelectable = function(){
                o.selectable = JSON.parse(element.attr("data-selectable")) === true;
                that.toggleSelectable();
            };

            switch (attributeName) {
                case "data-view": changeView(); break;
                case "data-selectable": changeSelectable(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".node");
            element.off(Metro.events.click, ".node-toggle");
            element.off(Metro.events.click, ".node-group > .data > .caption");
            element.off(Metro.events.dblclick, ".node-group > .data > .caption");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var MarqueeDefaultConfig = {
        items: null,
        backgroundColor: "#fff",
        color: "#000",
        borderSize: 0,
        borderColor: "transparent",
        loop: true,
        height: "auto",
        width: "auto",
        duration: 10000,
        direction: "left",
        ease: "linear",
        mode: "default", // default || accent
        accentPause: 2000,
        firstPause: 1000,
        stopOnHover: false,

        clsMarquee: "",
        clsMarqueeItem: "",

        onMarqueeItem: Metro.noop,
        onMarqueeItemComplete: Metro.noop,
        onMarqueeComplete: Metro.noop,
        onMarqueeCreate: Metro.noop
    };

    Metro.marqueeSetup = function (options) {
        MarqueeDefaultConfig = $.extend({}, MarqueeDefaultConfig, options);
    };

    if (typeof window["metroMarqueeSetup"] !== undefined) {
        Metro.marqueeSetup(window["metroMarqueeSetup"]);
    }

    Metro.Component('marquee', {
        init: function( options, elem ) {
            this._super(elem, options, MarqueeDefaultConfig, {
                // define instance vars here
                items: [],
                running: false,
                current: -1
            });
            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent('marquee-create');
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.addClass("marquee").addClass(o.clsMarquee);

            element.css({
                height: o.height,
                width: o.width,
                backgroundColor: Metro.colors.isColor(o.backgroundColor) ? o.backgroundColor : MarqueeDefaultConfig.backgroundColor,
                color: Metro.colors.isColor(o.color) ? o.color : MarqueeDefaultConfig.color,
                borderStyle: "solid",
                borderWidth: o.borderSize,
                borderColor: Metro.colors.isColor(o.borderColor) ? o.borderColor : MarqueeDefaultConfig.borderColor
            });

            this.setItems(o.items);

            if (this.items.length) {
                this.current = 0;
            }

            if (this.items.length) this.start();
        },

        setItems: function(items, replace){
            var element = this.element, o = this.options;
            var dir = o.direction.toLowerCase(), h;

            items = Metro.utils.isObject(items);

            if (items && replace) {
                element.clear();
            }

            if (items !== false) {
                $.each(items, function(){
                    var el = $(this);

                    if (el.length)
                        el.appendTo(element);
                    else
                        element.append( $("<div>").html(this) );
                })
            }

            this.items = element.children("*").addClass("marquee__item").addClass(o.clsMarqueeItem).items();

            if (dir === "left" || dir === "right") {
                $(this.items).addClass("moveLeftRight");
            } else {
                $(this.items).addClass("moveUpDown");
            }

            if (o.height === "auto") {
                h = 0;
                $(this.items).each(function(){
                    if ( +$(this).outerHeight(true) > h) {
                        h = +$(this).outerHeight(true);
                    }
                });
                element.height(h);
            }
            return this
        },


        setItem: function(index, value){
            var target = $(this.items[index]), h, o = this.options, element = this.element;

            if (!target.length) {
                return;
            }

            target.html(value)

            if (o.height === "auto") {
                h = 0;
                $(this.items).each(function(){
                    if ( +$(this).outerHeight(true) > h) {
                        h = +$(this).outerHeight(true);
                    }
                });
                element.height(h);
            }
            return this
        },

        addItem: function(item, index){
            var element = this.element;
            var ins, $item = $(item), trg;

            ins = $item.length ? $item : $("<div>").html(item);

            if (Metro.utils.isNull(index)) {
                element.append(ins);
            } else {
                trg = this.items[index]
                if (trg) {
                    ins.insertBefore(trg);
                } else {
                    element.append(ins);
                }
            }
            return this
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.enter, function(){
                if (o.stopOnHover)
                    $.pauseAll(that.items);
            })

            element.on(Metro.events.leave, function(){
                if (o.stopOnHover)
                    $.resumeAll(that.items);
            })
        },

        start: function(){
            var element = this.element, o = this.options;
            var chain = [], dir = o.direction.toLowerCase(), mode = o.mode.toLowerCase();
            var magic = 20;
            var ease = o.ease.toArray(",");
            var dur = +o.duration;

            if (mode === "default") {
                $.each(this.items, function (i) {
                    var el = $(this);
                    var draw;

                    if (el.attr("data-direction")) {
                        dir = el.attr("data-direction").toLowerCase();
                    }

                    if (el.attr("data-duration")) {
                        dur = +el.attr("data-duration");
                    }

                    if (["left", "right"].indexOf(dir) > -1) {
                        draw = {
                            left: dir === "left" ? [element.width(), -$(this).width() - magic] : [-$(this).width() - magic, element.width()]
                        }
                    } else {
                        draw = {
                            top: dir === "up" ? [element.height(), -$(this).height() - magic] : [-$(this).height() - magic, element.height()]
                        }
                    }

                    chain.push({
                        el: this,
                        draw: draw,
                        dur: dur,
                        ease: "linear",
                        defer: i === 0 ? +o.firstPause : 0
                    });
                });
            } else {
                $.each(this.items, function(i){
                    var el = $(this);
                    var half, draw1, draw2;
                    dur = o.duration / 2;

                    if (el.attr("data-direction")) {
                        dir = el.attr("data-direction").toLowerCase();
                    }

                    if (el.attr("data-duration")) {
                        dur = +el.attr("data-duration") / 2;
                    }

                    if (el.attr("data-ease")) {
                        ease = el.attr("data-ease").toArray(",");
                    }

                    if (["left", "right"].indexOf(dir) > -1) {
                        half = element.width() / 2 - $(this).width() / 2;
                        draw1 = {
                            left: dir === "left" ? [element.width(), half] : [-$(this).width() - magic, half]
                        }
                        draw2 = {
                            left: dir === "left" ? [half, -$(this).width() - magic] : [half, element.width() + magic]
                        }
                    } else {
                        half = element.height() / 2 - $(this).height() / 2;
                        draw1 = {
                            top: dir === "up" ? [element.height(), half] : [-$(this).height() - magic, half]
                        }
                        draw2 = {
                            top: dir === "up" ? [half, -$(this).height() - magic] : [half, element.height() + magic]
                        }
                    }

                    chain.push({
                        el: this,
                        draw: draw1,
                        dur: dur,
                        ease: ease[0] || "linear",
                        defer: i === 0 ? +o.firstPause : 0
                    });
                    chain.push({
                        el: this,
                        draw: draw2,
                        dur: dur,
                        ease: ease[1] ? ease[1] : ease[0] ? ease[0] : "linear",
                        defer: +o.accentPause
                    });
                });
            }

            this.running = true;

            $.chain(chain, {
                loop: o.loop,
                onChainItem: Metro.utils.isFunc(o.onMarqueeItem),
                onChainItemComplete: Metro.utils.isFunc(o.onMarqueeItemComplete),
                onChainComplete: Metro.utils.isFunc(o.onMarqueeComplete)
            });
            return this
        },

        stop: function(){
            this.running = false;
            $.stopAll(this.items);
            return this
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));


(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var MasterDefaultConfig = {
        masterDeferred: 0,
        effect: "slide", // slide, fade, switch, slowdown, custom
        effectFunc: "linear",
        duration: METRO_ANIMATION_DURATION,

        controlPrev: "<span class='default-icon-left-arrow'></span>",
        controlNext: "<span class='default-icon-right-arrow'></span>",
        controlTitle: "Master, page $1 of $2",
        backgroundImage: "",

        clsMaster: "",
        clsControls: "",
        clsControlPrev: "",
        clsControlNext: "",
        clsControlTitle: "",
        clsPages: "",
        clsPage: "",

        onBeforePage: Metro.noop_true,
        onBeforeNext: Metro.noop_true,
        onBeforePrev: Metro.noop_true,
        onNextPage: Metro.noop,
        onPrevPage: Metro.noop,
        onMasterCreate: Metro.noop
    };

    Metro.masterSetup = function (options) {
        MasterDefaultConfig = $.extend({}, MasterDefaultConfig, options);
    };

    if (typeof window["metroMasterSetup"] !== undefined) {
        Metro.masterSetup(window["metroMasterSetup"]);
    }

    Metro.Component('master', {
        init: function( options, elem ) {
            this._super(elem, options, MasterDefaultConfig, {
                pages: [],
                currentIndex: 0,
                isAnimate: false,
                id: Utils.elementId("master")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            element.addClass("master").addClass(o.clsMaster);
            element.css({
                backgroundImage: "url("+o.backgroundImage+")"
            });

            this._createControls();
            this._createPages();
            this._createEvents();

            this._fireEvent("master-create", {
                element: element
            });
        },

        _createControls: function(){
            var element = this.element, o = this.options;
            var controls_position = ['top', 'bottom'];
            var controls, title, pages = element.find(".page");

            title = String(o.controlTitle).replace("$1", "1");
            title = String(title).replace("$2", pages.length);

            $.each(controls_position, function(){
                controls = $("<div>").addClass("controls controls-"+this).addClass(o.clsControls).appendTo(element);
                $("<span>").addClass("prev").addClass(o.clsControlPrev).html(o.controlPrev).appendTo(controls);
                $("<span>").addClass("next").addClass(o.clsControlNext).html(o.controlNext).appendTo(controls);
                $("<span>").addClass("title").addClass(o.clsControlTitle).html(title).appendTo(controls);
            });

            this._enableControl("prev", false);
        },

        _enableControl: function(type, state){
            var control = this.element.find(".controls ." + type);
            if (state === true) {
                control.removeClass("disabled");
            } else {
                control.addClass("disabled");
            }
        },

        _setTitle: function(){
            var title = this.element.find(".controls .title");

            var title_str = this.options.controlTitle.replace("$1", this.currentIndex + 1);
            title_str = title_str.replace("$2", String(this.pages.length));

            title.html(title_str);
        },

        _createPages: function(){
            var that = this, element = this.element, o = this.options;
            var pages = element.find(".pages");
            var page = element.find(".page");

            if (pages.length === 0) {
                pages = $("<div>").addClass("pages").appendTo(element);
            }

            pages.addClass(o.clsPages);

            $.each(page, function(){
                var p = $(this);
                if (p.data("cover") !== undefined) {
                    element.css({
                        backgroundImage: "url("+p.data('cover')+")"
                    });
                } else {
                    element.css({
                        backgroundImage: "url("+o.backgroundImage+")"
                    });
                }

                p.css({
                    left: "100%"
                });

                p.addClass(o.clsPage).hide(0);

                that.pages.push(p);
            });

            page.appendTo(pages);

            this.currentIndex = 0;
            if (this.pages[this.currentIndex] !== undefined) {
                if (this.pages[this.currentIndex].data("cover") !== undefined ) {
                    element.css({
                        backgroundImage: "url("+this.pages[this.currentIndex].data('cover')+")"
                    });
                }
                this.pages[this.currentIndex].css("left", "0").show(0);
                setTimeout(function(){
                    pages.css({
                        height: that.pages[0].outerHeight(true) + 2
                    });
                }, 0);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".controls .prev", function(){
                if (that.isAnimate === true) {
                    return ;
                }
                if (
                    Utils.exec(o.onBeforePrev, [that.currentIndex, that.pages[that.currentIndex], element]) === true &&
                    Utils.exec(o.onBeforePage, ["prev", that.currentIndex, that.pages[that.currentIndex], element]) === true
                ) {
                    that.prev();
                }
            });

            element.on(Metro.events.click, ".controls .next", function(){
                if (that.isAnimate === true) {
                    return ;
                }
                if (
                    Utils.exec(o.onBeforeNext, [that.currentIndex, that.pages[that.currentIndex], element]) === true &&
                    Utils.exec(o.onBeforePage, ["next", that.currentIndex, that.pages[that.currentIndex], element]) === true
                ) {
                    that.next();
                }
            });

            $(window).on(Metro.events.resize, function(){
                element.find(".pages").height(that.pages[that.currentIndex].outerHeight(true) + 2);
            }, {ns: this.id});
        },

        _slideToPage: function(index){
            var current, next, to;

            if (this.pages[index] === undefined) {
                return ;
            }

            if (this.currentIndex === index) {
                return ;
            }

            to = index > this.currentIndex ? "next" : "prev";
            current = this.pages[this.currentIndex];
            next = this.pages[index];

            this.currentIndex = index;

            this._effect(current, next, to);
        },

        _slideTo: function(to){
            var current, next, forward = to.toLowerCase() === 'next';

            current = this.pages[this.currentIndex];

            if (forward ) {
                if (this.currentIndex + 1 >= this.pages.length) {
                    return ;
                }
                this.currentIndex++;
            } else {
                if (this.currentIndex - 1 < 0) {
                    return ;
                }
                this.currentIndex--;
            }

            next = this.pages[this.currentIndex];

            this._fireEvent(forward ? "next-page" : "prev-page", {
                current: current,
                next: next,
                forward: forward
            });

            this._effect(current, next, to);
        },

        _effect: function(current, next, to){
            var that = this, element = this.element, o = this.options;
            var out = element.width();
            var pages = element.find(".pages");

            this._setTitle();

            if (this.currentIndex === this.pages.length - 1) {
                this._enableControl("next", false);
            } else {
                this._enableControl("next", true);
            }

            if (this.currentIndex === 0) {
                this._enableControl("prev", false);
            } else {
                this._enableControl("prev", true);
            }

            setTimeout(function(){
                that.isAnimate = true;
                pages.animate({
                    draw: {
                        height: next.outerHeight(true) + 2
                    }
                });
            },0);

            pages.css("overflow", "hidden");

            function finish(){
                if (next.data("cover") !== undefined) {
                    element.css({
                        backgroundImage: "url("+next.data('cover')+")"
                    });
                } else {
                    element.css({
                        backgroundImage: "url("+o.backgroundImage+")"
                    });
                }
                pages.css("overflow", "initial");
                that.isAnimate = false;
            }

            function _slide(){
                current
                    .stop(true)
                    .animate({
                        draw: {
                            left: to === "next" ? -out : out
                        },
                        dur: o.duration,
                        ease: o.effectFunc,
                        onDone: function(){
                            current.hide(0);
                        }
                    });

                next
                    .stop(true)
                    .css({
                        left: to === "next" ? out : -out
                    })
                    .show(0)
                    .animate({
                        draw: {
                            left: 0
                        },
                        dur: o.duration,
                        ease: o.effectFunc,
                        onDone: function(){
                            finish();
                        }
                    });
            }

            function _switch(){
                current.hide();

                next.css({
                    top: 0,
                    left: 0,
                    opacity: 0
                }).show(function(){
                    finish();
                });
            }

            function _fade(){
                current.fadeOut(o.duration);

                next.css({
                    top: 0,
                    left: 0,
                    opacity: 0
                }).fadeIn(o.duration, "linear", function(){
                    finish();
                });
            }

            switch (o.effect) {
                case "fade": _fade(); break;
                case "switch": _switch(); break;
                default: _slide();
            }
        },

        toPage: function(index){
            this._slideToPage(index);
        },

        next: function(){
            this._slideTo("next");
        },

        prev: function(){
            this._slideTo("prev");
        },

        changeEffect: function(){
            this.options.effect = this.element.attr("data-effect");
        },

        changeEffectFunc: function(){
            this.options.effectFunc = this.element.attr("data-effect-func");
        },

        changeEffectDuration: function(){
            this.options.duration = this.element.attr("data-duration");
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-effect": this.changeEffect(); break;
                case "data-effect-func": this.changeEffectFunc(); break;
                case "data-duration": this.changeEffectDuration(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".controls .prev");
            element.off(Metro.events.click, ".controls .next");
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro) {
    'use strict';
    Metro.md5 = function (string) {
        function RotateLeft(lValue, iShiftBits) {
            return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
        }

        function AddUnsigned(lX,lY) {
            var lX4,lY4,lX8,lY8,lResult;
            lX8 = (lX & 0x80000000);
            lY8 = (lY & 0x80000000);
            lX4 = (lX & 0x40000000);
            lY4 = (lY & 0x40000000);
            lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
            if (lX4 & lY4) {
                return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
            }
            if (lX4 | lY4) {
                if (lResult & 0x40000000) {
                    return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                } else {
                    return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                }
            } else {
                return (lResult ^ lX8 ^ lY8);
            }
        }

        function F(x,y,z) { return (x & y) | ((~x) & z); }
        function G(x,y,z) { return (x & z) | (y & (~z)); }
        function H(x,y,z) { return (x ^ y ^ z); }
        function I(x,y,z) { return (y ^ (x | (~z))); }

        function FF(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function GG(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function HH(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function II(a,b,c,d,x,s,ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function ConvertToWordArray(string) {
            var lWordCount;
            var lMessageLength = string.length;
            var lNumberOfWords_temp1=lMessageLength + 8;
            var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
            var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
            var lWordArray=Array(lNumberOfWords-1);
            var lBytePosition = 0;
            var lByteCount = 0;
            while ( lByteCount < lMessageLength ) {
                lWordCount = (lByteCount-(lByteCount % 4))/4;
                lBytePosition = (lByteCount % 4)*8;
                lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
                lByteCount++;
            }
            lWordCount = (lByteCount-(lByteCount % 4))/4;
            lBytePosition = (lByteCount % 4)*8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
            lWordArray[lNumberOfWords-2] = lMessageLength<<3;
            lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
            return lWordArray;
        }

        function WordToHex(lValue) {
            var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
            for (lCount = 0;lCount<=3;lCount++) {
                lByte = (lValue>>>(lCount*8)) & 255;
                WordToHexValue_temp = "0" + lByte.toString(16);
                WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
            }
            return WordToHexValue;
        }

        function Utf8Encode(string) {
            string = string.replace(/\r\n/g,"\n");
            var utftext = "";

            for (var n = 0; n < string.length; n++) {

                var c = string.charCodeAt(n);

                if (c < 128) {
                    utftext += String.fromCharCode(c);
                }
                else if((c > 127) && (c < 2048)) {
                    utftext += String.fromCharCode((c >> 6) | 192);
                    utftext += String.fromCharCode((c & 63) | 128);
                }
                else {
                    utftext += String.fromCharCode((c >> 12) | 224);
                    utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                    utftext += String.fromCharCode((c & 63) | 128);
                }

            }

            return utftext;
        }

        var x=[];
        var k,AA,BB,CC,DD,a,b,c,d;
        var S11=7, S12=12, S13=17, S14=22;
        var S21=5, S22=9 , S23=14, S24=20;
        var S31=4, S32=11, S33=16, S34=23;
        var S41=6, S42=10, S43=15, S44=21;

        string = Utf8Encode(string);

        x = ConvertToWordArray(string);

        a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

        for (k=0;k<x.length;k+=16) {
            AA=a; BB=b; CC=c; DD=d;
            a=FF(a,b,c,d,x[k], S11,0xD76AA478);
            d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
            c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
            b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
            a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
            d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
            c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
            b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
            a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
            d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
            c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
            b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
            a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
            d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
            c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
            b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
            a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
            d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
            c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
            b=GG(b,c,d,a,x[k], S24,0xE9B6C7AA);
            a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
            d=GG(d,a,b,c,x[k+10],S22,0x2441453);
            c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
            b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
            a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
            d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
            c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
            b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
            a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
            d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
            c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
            b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
            a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
            d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
            c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
            b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
            a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
            d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
            c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
            b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
            a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
            d=HH(d,a,b,c,x[k], S32,0xEAA127FA);
            c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
            b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
            a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
            d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
            c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
            b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
            a=II(a,b,c,d,x[k], S41,0xF4292244);
            d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
            c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
            b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
            a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
            d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
            c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
            b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
            a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
            d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
            c=II(c,d,a,b,x[k+6], S43,0xA3014314);
            b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
            a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
            d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
            c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
            b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
            a=AddUnsigned(a,AA);
            b=AddUnsigned(b,BB);
            c=AddUnsigned(c,CC);
            d=AddUnsigned(d,DD);
        }

        var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);

        return temp.toLowerCase();
    };

    if (window.METRO_GLOBAL_COMMON === true) {
        window.md5 = Metro.md5;
    }
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var NavigationViewDefaultConfig = {
        navviewDeferred: 0,
        compact: "md",
        expand: "lg",
        toggle: null,
        activeState: false,
        onMenuItemClick: Metro.noop,
        onNavviewCreate: Metro.noop
    };

    Metro.navViewSetup = function (options) {
        NavigationViewDefaultConfig = $.extend({}, NavigationViewDefaultConfig, options);
    };

    if (typeof window["metroNavViewSetup"] !== undefined) {
        Metro.navViewSetup(window["metroNavViewSetup"]);
    }

    Metro.Component('nav-view', {
        init: function( options, elem ) {
            this._super(elem, options, NavigationViewDefaultConfig, {
                pane: null,
                content: null,
                paneToggle: null,
                id: Utils.elementId("navview"),
                menuScrollDistance: 0,
                menuScrollStep: 0
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("navview-create");
        },

        _calcMenuHeight: function(){
            var element = this.element, pane, menu_container;
            var elements_height = 0;

            pane = element.children(".navview-pane");
            if (pane.length === 0) {
                return;
            }

            menu_container = pane.children(".navview-menu-container");

            if (menu_container.length === 0) {
                return ;
            }

            $.each(menu_container.prevAll(), function(){
                elements_height += $(this).outerHeight(true);
            });

            $.each(menu_container.nextAll(), function(){
                elements_height += $(this).outerHeight(true);
            });

            menu_container.css({
                height: "calc(100% - "+(elements_height)+"px)"
            });

            this.menuScrollStep = 48;
            this.menuScrollDistance = Utils.nearest(menu_container[0].scrollHeight - menu_container.height(), 48);
        },

        _recalc: function(){
            var that = this, element = this.element;
            setTimeout(function(){
                if (that.pane.width() === 48) {
                    element.addClass("js-compact");
                } else {
                    element.removeClass("js-compact");
                }
                that._calcMenuHeight();
            }, 200);
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var pane, content, toggle, menu/*, menu_container, menu_h, menu_container_h*/;

            element
                .addClass("navview")
                .addClass(o.compact !== false ? "navview-compact-"+o.compact : "")
                .addClass(o.expand !== false ? "navview-expand-"+o.expand : "");

            pane = element.children(".navview-pane");
            content = element.children(".navview-content");
            toggle = $(o.toggle);
            menu = pane.children(".navview-menu");

            if (menu.length) {
                menu.prevAll().reverse().wrapAll($("<div>").addClass("navview-container"));
                menu.wrap($("<div>").addClass("navview-menu-container"));
            }

            this.pane = pane.length > 0 ? pane : null;
            this.content = content.length > 0 ? content : null;
            this.paneToggle = toggle.length > 0 ? toggle : null;

            this._recalc();
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var menu_container = element.find(".navview-menu-container");
            var menu = menu_container.children(".navview-menu");

            menu_container.on("mousewheel", function(e){
                var pane_width = element.find(".navview-pane").width();
                var dir = e.deltaY > 0 ? -1 : 1;
                var step = that.menuScrollStep;
                var distance = that.menuScrollDistance;
                var top = parseInt(menu.css('top'));

                if (pane_width > 48 /*|| !element.hasClass("compacted") */) {
                    return false;
                }

                if(dir === -1 && Math.abs(top) <= distance) {
                    menu.css('top', parseInt(menu.css('top')) + step * dir);
                }

                if(dir === 1 && top <= -step) {
                    menu.css('top', parseInt(menu.css('top')) + step * dir);
                }
            });

            element.on(Metro.events.click, ".pull-button, .holder", function(){
                that.pullClick(this);
            });

            element.on(Metro.events.click, ".navview-menu li", function(){
                if (o.activeState === true) {
                    element.find(".navview-menu li").removeClass("active");
                    $(this).toggleClass("active");
                }
            });

            element.on(Metro.events.click, ".navview-menu li > a", function(){

                that._fireEvent("menu-item-click", {
                    item: this
                });

            });

            if (this.paneToggle !== null) {
                this.paneToggle.on(Metro.events.click, function(){
                    that.pane.toggleClass("open");
                })
            }

            $(window).on(Metro.events.resize, function(){
                var menu_h, menu_container_h,
                    menu_container = element.children(".navview-menu-container"),
                    menu;

                if (that.pane.hasClass("open")) {
                    that._recalc();
                    return ;
                }

                element.removeClass("expanded");
                that.pane.removeClass("open");

                if ($(this).width() <= Metro.media_sizes[(""+o.compact).toUpperCase()]) {
                    element.removeClass("compacted");
                }

                if (menu_container.length) {
                    menu = menu_container.children(".navview-menu");
                    setTimeout(function () {
                        menu_h = menu.height();
                        menu_container_h = menu_container.height();
                        that.menuScrollStep = menu.children(":not(.item-separator), :not(.item-header)")[0].clientHeight;
                        that.menuScrollDistance = menu_h > menu_container_h ? Utils.nearest(menu_h - menu_container_h, that.menuScrollStep) : 0;
                    }, 0);
                }

                that._recalc();

            }, {ns: this.id})
        },

        _togglePaneMode: function(){
            var element = this.element;
            var pane = this.pane;
            var pane_compact = pane.width() < 280;

            if ((pane_compact || element.hasClass("expanded")) && !element.hasClass("compacted")) {
                element.toggleClass("expanded");
            } else

            if (element.hasClass("compacted") || !pane_compact) {
                element.toggleClass("compacted");
            }

        },

        pullClick: function(el){
            var that = this;
            var input;

            var target = $(el);

            if (target && target.hasClass("holder")) {
                input = target.parent().find("input");
                setTimeout(function(){
                    input.focus();
                }, 200);
            }

            if (that.pane.hasClass("open")) {
                that.close();
            } else {
                this._togglePaneMode();
            }

            this._recalc();

            return true;
        },

        open: function(){
            this.pane.addClass("open");
        },

        close: function(){
            this.pane.removeClass("open");
        },

        toggle: function(){
            var pane = this.pane;
            pane.hasClass("open") ? pane.removeClass("open") : pane.addClass("open");
        },

        toggleMode: function(){
            this._togglePaneMode();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".pull-button, .holder");
            element.off(Metro.events.click, ".navview-menu li");
            element.off(Metro.events.click, ".navview-menu li > a");

            if (this.paneToggle !== null) {
                this.paneToggle.off(Metro.events.click);
            }

            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var NotifyDefaultConfig = {
        container: null,
        width: 220,
        timeout: METRO_TIMEOUT,
        duration: METRO_ANIMATION_DURATION,
        distance: "max",
        animation: "linear",
        onClick: Metro.noop,
        onClose: Metro.noop,
        onShow: Metro.noop,
        onAppend: Metro.noop,
        onNotifyCreate: Metro.noop

    };

    Metro.notifySetup = function(options){
        NotifyDefaultConfig = $.extend({}, NotifyDefaultConfig, options);
    };

    if (typeof window["metroNotifySetup"] !== undefined) {
        Metro.notifySetup(window["metroNotifySetup"]);
    }

    var Notify = {

        container: null,

        options: {
        },

        notifies: [],

        setup: function(options){
            this.options = $.extend({}, NotifyDefaultConfig, options);

            return this;
        },

        reset: function(){
            var reset_options = {
                width: 220,
                timeout: METRO_TIMEOUT,
                duration: METRO_ANIMATION_DURATION,
                distance: "max",
                animation: "linear"
            };
            this.options = $.extend({}, NotifyDefaultConfig, reset_options);
        },

        _createContainer: function(){

            var container = $("<div>").addClass("notify-container");
            $("body").prepend(container);

            return container;
        },

        create: function(message, title, options){
            var notify, that = this, o = this.options;
            var m, t, id = Utils.elementId("notify");

            if (Utils.isNull(options)) {
                options = {};
            }

            if (!Utils.isValue(message)) {
                return false;
            }

            notify = $("<div>").addClass("notify").attr("id", id);
            notify.css({
                width: o.width
            });

            if (title) {
                t = $("<div>").addClass("notify-title").html(title);
                notify.prepend(t);
            }
            m = $("<div>").addClass("notify-message").html(message);
            m.appendTo(notify);

            // Set options
            /*
            * keepOpen, cls, width, callback
            * */
            if (options !== undefined) {
                if (options.cls !== undefined) {
                    notify.addClass(options.cls);
                }
                if (options.width !== undefined) {
                    notify.css({
                        width: options.width
                    });
                }
            }

            notify.on(Metro.events.click, function(){
                Utils.exec(Utils.isValue(options.onClick) ? options.onClick : o.onClick, null, this);
                that.kill($(this).closest(".notify"), Utils.isValue(options.onClose) ? options.onClose : o.onClose);
            });

            // Show
            if (Notify.container === null) {
                Notify.container = Notify._createContainer();
            }
            notify.appendTo(Notify.container);

            notify.hide(function(){

                Utils.exec(Utils.isValue(options.onAppend) ? options.onAppend : o.onAppend, null, notify[0]);

                var duration = Utils.isValue(options.duration) ? options.duration : o.duration;
                var animation = Utils.isValue(options.animation) ? options.animation : o.animation;
                var distance = Utils.isValue(options.distance) ? options.distance : o.distance;

                if (distance === "max" || isNaN(distance)) {
                    distance = $(window).height();
                }

                notify
                    .show()
                    .animate({
                        draw: {
                            marginTop: [distance, 4],
                            opacity: [0, 1]
                        },
                        dur: duration,
                        ease: animation,
                        onDone: function(){
                            Utils.exec(o.onNotifyCreate, null, this);

                            if (options !== undefined && options.keepOpen === true) {
                                /* eslint-disable-next-line */

                            } else {
                                setTimeout(function(){
                                    that.kill(notify, Utils.isValue(options.onClose) ? options.onClose : o.onClose);
                                }, o.timeout);
                            }

                            Utils.exec(Utils.isValue(options.onShow) ? options.onShow : o.onShow, null, notify[0]);
                        }
                    });

            });
        },

        kill: function(notify, callback){
            var that = this, o = this.options;
            notify.off(Metro.events.click);
            notify.fadeOut(o.duration, 'linear', function(){
                Utils.exec(Utils.isValue(callback) ? callback : that.options.onClose, null, notify[0]);
                notify.remove();
            });
        },

        killAll: function(){
            var that = this;
            var notifies = $(".notify");
            $.each(notifies, function(){
                that.kill($(this));
            });
        }
    };

    Metro['notify'] = Notify.setup();
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    Metro.pagination = function(c){
        var defConf = {
            length: 0,
            rows: 0,
            current: 0,
            target: "body",
            clsPagination: "",
            prevTitle: "Prev",
            nextTitle: "Next",
            distance: 5
        }, conf;
        var pagination;
        var pagination_wrapper;
        var i, prev, next;
        var shortDistance;

        conf = $.extend( {}, defConf, c);

        shortDistance = parseInt(conf.distance);
        pagination_wrapper = $(conf.target);
        pagination_wrapper.html("");
        pagination = $("<ul>").addClass("pagination").addClass(conf.clsPagination).appendTo(pagination_wrapper);

        if (conf.length === 0) {
            return ;
        }

        if (conf.rows === -1) {
            return ;
        }

        conf.pages = Math.ceil(conf.length / conf.rows);

        var add_item = function(item_title, item_type, data){
            var li, a;

            li = $("<li>").addClass("page-item").addClass(item_type);
            a  = $("<a>").addClass("page-link").html(item_title);
            a.data("page", data);
            a.appendTo(li);

            return li;
        };

        prev = add_item(conf.prevTitle, "service prev-page", "prev");
        pagination.append(prev);

        pagination.append(add_item(1, conf.current === 1 ? "active" : "", 1));

        if (shortDistance === 0 || conf.pages <= 7) {
            for (i = 2; i < conf.pages; i++) {
                pagination.append(add_item(i, i === conf.current ? "active" : "", i));
            }
        } else {
            if (conf.current < shortDistance) {
                for (i = 2; i <= shortDistance; i++) {
                    pagination.append(add_item(i, i === conf.current ? "active" : "", i));
                }

                if (conf.pages > shortDistance) {
                    pagination.append(add_item("...", "no-link", null));
                }
            } else if (conf.current <= conf.pages && conf.current > conf.pages - shortDistance + 1) {
                if (conf.pages > shortDistance) {
                    pagination.append(add_item("...", "no-link", null));
                }

                for (i = conf.pages - shortDistance + 1; i < conf.pages; i++) {
                    pagination.append(add_item(i, i === conf.current ? "active" : "", i));
                }
            } else {
                pagination.append(add_item("...", "no-link", null));

                pagination.append(add_item(conf.current - 1, "", conf.current - 1));
                pagination.append(add_item(conf.current, "active", conf.current));
                pagination.append(add_item(conf.current + 1, "", conf.current + 1));

                pagination.append(add_item("...", "no-link", null));
            }
        }

        if (conf.pages > 1 || conf.current < conf.pages) pagination.append(add_item(conf.pages, conf.current === conf.pages ? "active" : "", conf.pages));

        next = add_item(conf.nextTitle, "service next-page", "next");
        pagination.append(next);

        if (conf.current === 1) {
            prev.addClass("disabled");
        }

        if (conf.current === conf.pages) {
            next.addClass("disabled");
        }

        if (conf.length === 0) {
            pagination.addClass("disabled");
            pagination.children().addClass("disabled");
        }

        return pagination;
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var PanelDefaultConfig = {
        panelDeferred: 0,
        id: null,
        titleCaption: "",
        titleIcon: "",
        collapsible: false,
        collapsed: false,
        collapseDuration: METRO_ANIMATION_DURATION,
        width: "auto",
        height: "auto",
        draggable: false,

        customButtons: null,
        clsCustomButton: "",

        clsPanel: "",
        clsTitle: "",
        clsTitleCaption: "",
        clsTitleIcon: "",
        clsContent: "",
        clsCollapseToggle: "",

        onCollapse: Metro.noop,
        onExpand: Metro.noop,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onPanelCreate: Metro.noop
    };

    Metro.panelSetup = function (options) {
        PanelDefaultConfig = $.extend({}, PanelDefaultConfig, options);
    };

    if (typeof window["metroPanelSetup"] !== undefined) {
        Metro.panelSetup(window["metroPanelSetup"]);
    }

    Metro.Component('panel', {
        init: function( options, elem ) {
            this._super(elem, options, PanelDefaultConfig);

            return this;
        },

        _addCustomButtons: function(buttons){
            var element = this.element, o = this.options;
            var title = element.closest(".panel").find(".panel-title");
            var buttonsContainer, customButtons = [];

            if (typeof buttons === "string" && buttons.indexOf("{") > -1) {
                customButtons = JSON.parse(buttons);
            } else if (typeof buttons === "string" && Utils.isObject(buttons)) {
                customButtons = Utils.isObject(buttons);
            } else if (typeof buttons === "object" && Utils.objectLength(buttons) > 0) {
                customButtons = buttons;
            } else {
                console.warn("Unknown format for custom buttons", buttons);
                return ;
            }

            if (title.length === 0) {
                console.warn("No place for custom buttons");
                return ;
            }

            buttonsContainer = title.find(".custom-buttons");

            if (buttonsContainer.length === 0) {
                buttonsContainer = $("<div>").addClass("custom-buttons").appendTo(title);
            } else {
                buttonsContainer.find(".btn-custom").off(Metro.events.click);
                buttonsContainer.html("");
            }

            $.each(customButtons, function(){
                var item = this;
                var customButton = $("<span>");

                customButton
                    .addClass("button btn-custom")
                    .addClass(o.clsCustomButton)
                    .addClass(item.cls)
                    .attr("tabindex", -1)
                    .html(item.html);

                if (item.attr && typeof item.attr === 'object') {
                    $.each(item.attr, function(k, v){
                        customButton.attr(Cake.dashedName(k), v);
                    });
                }

                customButton.data("action", item.onclick);

                buttonsContainer.prepend(customButton);
            });

            title.on(Metro.events.click, ".btn-custom", function(e){
                if (Utils.isRightMouse(e)) return;
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [button], this);
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var panel = $("<div>").addClass("panel").addClass(o.clsPanel);
            var id = o.id ? o.id : Utils.elementId("panel");
            var original_classes = element[0].className;
            var title;

            panel.attr("id", id).addClass(original_classes);
            panel.insertBefore(element);
            element.appendTo(panel);

            element[0].className = '';
            element.addClass("panel-content").addClass(o.clsContent).appendTo(panel);

            if (o.titleCaption !== "" || o.titleIcon !== "" || o.collapsible === true) {
                title = $("<div>").addClass("panel-title").addClass(o.clsTitle);

                if (o.titleCaption !== "") {
                    $("<span>").addClass("caption").addClass(o.clsTitleCaption).html(o.titleCaption).appendTo(title)
                }

                if (o.titleIcon !== "") {
                    $(o.titleIcon).addClass("icon").addClass(o.clsTitleIcon).appendTo(title)
                }

                if (o.collapsible === true) {
                    var collapseToggle = $("<span>").addClass("dropdown-toggle marker-center active-toggle").addClass(o.clsCollapseToggle).appendTo(title);
                    Metro.makePlugin(element, "collapse", {
                        toggleElement: collapseToggle,
                        duration: o.collapseDuration,
                        onCollapse: o.onCollapse,
                        onExpand: o.onExpand
                    });

                    if (o.collapsed === true) {
                        this.collapse();
                    }
                }

                title.appendTo(panel);
            }

            if (title && Utils.isValue(o.customButtons)) {
                this._addCustomButtons(o.customButtons);
            }

            if (o.draggable === true) {
                var dragElement;

                if (title) {
                    dragElement = title.find(".caption, .icon");
                } else {
                    dragElement = panel;
                }

                Metro.makePlugin(panel, "draggable", {
                    dragContext: panel[0],
                    dragElement: dragElement,
                    onDragStart: o.onDragStart,
                    onDragStop: o.onDragStop,
                    onDragMove: o.onDragMove
                });
            }

            if (o.width !== "auto" && parseInt(o.width) >= 0) {
                panel.outerWidth(parseInt(o.width));
            }

            if (o.height !== "auto" && parseInt(o.height) >= 0) {
                panel.outerHeight(parseInt(o.height));
                element.css({overflow: "auto"});
            }

            this.panel = panel;

            this._fireEvent("panel-create", {
                element: element,
                panel: panel
            });
        },

        customButtons: function(buttons){
            return this._addCustomButtons(buttons);
        },

        collapse: function(){
            var element = this.element;
            if (Utils.isMetroObject(element, 'collapse') === false) {
                return ;
            }
            Metro.getPlugin(element, 'collapse').collapse();
        },

        open: function(){
            this.expand();
        },

        close: function(){
            this.collapse();
        },

        expand: function(){
            var element = this.element;
            if (Utils.isMetroObject(element, 'collapse') === false) {
                return ;
            }
            Metro.getPlugin(element, 'collapse').expand();
        },

        /* eslint-disable-next-line */
        changeAttribute: function(attributeName){
        },

        destroy: function(){
            var element = this.element, o = this.options;

            if (o.collapsible === true) {
                Metro.getPlugin(element, "collapse").destroy();
            }

            if (o.draggable === true) {
                Metro.getPlugin(element, "draggable").destroy();
            }

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var PopoverDefaultConfig = {
        popoverDeferred: 0,
        popoverText: "",
        popoverHide: 3000,
        popoverTimeout: 10,
        popoverOffset: 10,
        popoverTrigger: Metro.popoverEvents.HOVER,
        popoverPosition: Metro.position.TOP,
        hideOnLeave: false,
        closeButton: true,
        clsPopover: "",
        clsPopoverContent: "",
        onPopoverShow: Metro.noop,
        onPopoverHide: Metro.noop,
        onPopoverCreate: Metro.noop
    };

    Metro.popoverSetup = function (options) {
        PopoverDefaultConfig = $.extend({}, PopoverDefaultConfig, options);
    };

    if (typeof window["metroPopoverSetup"] !== undefined) {
        Metro.popoverSetup(window["metroPopoverSetup"]);
    }

    Metro.Component('popover', {
        init: function( options, elem ) {
            this._super(elem, options, PopoverDefaultConfig, {
                popover: null,
                popovered: false,
                size: {
                    width: 0,
                    height: 0
                },
                id: Utils.elementId("popover")
            });

            return this;
        },

        _create: function(){
            this._createEvents();
            this._fireEvent("popover-create", {
                element: this.element
            })
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var event;

            switch (o.popoverTrigger) {
                case Metro.popoverEvents.CLICK: event = Metro.events.click; break;
                case Metro.popoverEvents.FOCUS: event = Metro.events.focus; break;
                default: event = Metro.events.enter;
            }

            element.on(event, function(){
                if (that.popover !== null || that.popovered === true) {
                    return ;
                }
                setTimeout(function(){
                    that.createPopover();

                    that._fireEvent("popover-show", {
                        popover: that.popover
                    });

                    if (o.popoverHide > 0) {
                        setTimeout(function(){
                            that.removePopover();
                        }, o.popoverHide);
                    }
                }, o.popoverTimeout);
            });

            if (o.hideOnLeave === true) {
                element.on(Metro.events.leave, function(){
                    that.removePopover();
                });
            }

            $(window).on(Metro.events.scroll, function(){
                if (that.popover !== null) that.setPosition();
            }, {ns: this.id});
        },

        setPosition: function(){
            var popover = this.popover, size = this.size, o = this.options, element = this.element;

            if (o.popoverPosition === Metro.position.BOTTOM) {
                popover.addClass('bottom');
                popover.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + o.popoverOffset,
                    left: element.offset().left + element.outerWidth()/2 - size.width/2  - $(window).scrollLeft()
                });
            } else if (o.popoverPosition === Metro.position.RIGHT) {
                popover.addClass('right');
                popover.css({
                    top: element.offset().top + element.outerHeight()/2 - size.height/2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + o.popoverOffset
                });
            } else if (o.popoverPosition === Metro.position.LEFT) {
                popover.addClass('left');
                popover.css({
                    top: element.offset().top + element.outerHeight()/2 - size.height/2 - $(window).scrollTop(),
                    left: element.offset().left - size.width - $(window).scrollLeft() - o.popoverOffset
                });
            } else {
                popover.addClass('top');
                popover.css({
                    top: element.offset().top - $(window).scrollTop() - size.height - o.popoverOffset,
                    left: element.offset().left + element.outerWidth()/2 - size.width/2  - $(window).scrollLeft()
                });
            }
        },

        createPopover: function(){
            var that = this, elem = this.elem, element = this.element, o = this.options;
            var popover;
            var neb_pos;
            var id = Utils.elementId("popover");
            var closeButton;

            if (this.popovered) {
                return ;
            }

            popover = $("<div>").addClass("popover neb").addClass(o.clsPopover);
            popover.attr("id", id);

            $("<div>").addClass("popover-content").addClass(o.clsPopoverContent).html(o.popoverText).appendTo(popover);

            if (o.popoverHide === 0 && o.closeButton === true) {
                closeButton = $("<button>").addClass("button square small popover-close-button bg-white").html("&times;").appendTo(popover);
                closeButton.on(Metro.events.click, function(){
                    that.removePopover();
                });
            }

            switch (o.popoverPosition) {
                case Metro.position.TOP: neb_pos = "neb-s"; break;
                case Metro.position.BOTTOM: neb_pos = "neb-n"; break;
                case Metro.position.RIGHT: neb_pos = "neb-w"; break;
                case Metro.position.LEFT: neb_pos = "neb-e"; break;
            }

            popover.addClass(neb_pos);

            if (o.closeButton !== true) {
                popover.on(Metro.events.click, function(){
                    that.removePopover();
                });
            }

            this.popover = popover;
            this.size = Utils.hiddenElementSize(popover);

            if (elem.tagName === 'TD' || elem.tagName === 'TH') {
                var wrp = $("<div/>").css("display", "inline-block").html(element.html());
                element.html(wrp);
                element = wrp;
            }

            this.setPosition();

            popover.appendTo($('body'));

            this.popovered = true;

            this._fireEvent("popover-create", {
                popover: popover
            });
        },

        removePopover: function(){
            var that = this;
            var timeout = this.options.onPopoverHide === Metro.noop ? 0 : 300;
            var popover = this.popover;

            if (!this.popovered) {
                return ;
            }

            this._fireEvent("popover-hide", {
                popover: popover
            });

            setTimeout(function(){
                popover.hide(0, function(){
                    popover.remove();
                    that.popover = null;
                    that.popovered = false;
                });
            }, timeout);
        },

        show: function(){
            var that = this, o = this.options;

            if (this.popovered === true) {
                return ;
            }

            setTimeout(function(){
                that.createPopover();

                that._fireEvent("popover-show", {
                    popover: that.popover
                });

                if (o.popoverHide > 0) {
                    setTimeout(function(){
                        that.removePopover();
                    }, o.popoverHide);
                }
            }, o.popoverTimeout);
        },

        hide: function(){
            this.removePopover();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeText = function(){
                o.popoverText = element.attr("data-popover-text");
                if (that.popover) {
                    that.popover.find(".popover-content").html(o.popoverText);
                    that.setPosition();
                }
            };

            var changePosition = function(){
                o.popoverPosition = element.attr("data-popover-position");
                that.setPosition();
            };

            switch (attributeName) {
                case "data-popover-text": changeText(); break;
                case "data-popover-position": changePosition(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var event;

            switch (o.popoverTrigger) {
                case Metro.popoverEvents.CLICK: event = Metro.events.click; break;
                case Metro.popoverEvents.FOCUS: event = Metro.events.focus; break;
                default: event = Metro.events.enter;
            }

            element.off(event);

            if (o.hideOnLeave === true) {
                element.off(Metro.events.leave);
            }

            $(window).off(Metro.events.scroll,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var ProgressDefaultConfig = {
        progressDeferred: 0,
        showValue: false,
        valuePosition: "free", // center, free
        showLabel: false,
        labelPosition: "before", // before, after
        labelTemplate: "",
        value: 0,
        buffer: 0,
        type: "bar",
        small: false,
        clsBack: "",
        clsBar: "",
        clsBuffer: "",
        clsValue: "",
        clsLabel: "",
        onValueChange: Metro.noop,
        onBufferChange: Metro.noop,
        onComplete: Metro.noop,
        onBuffered: Metro.noop,
        onProgressCreate: Metro.noop
    };

    Metro.progressSetup = function (options) {
        ProgressDefaultConfig = $.extend({}, ProgressDefaultConfig, options);
    };

    if (typeof window["metroProgressSetup"] !== undefined) {
        Metro.progressSetup(window["metroProgressSetup"]);
    }

    Metro.Component('progress', {
        init: function( options, elem ) {
            this._super(elem, options, ProgressDefaultConfig, {
                value: 0,
                buffer: 0
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var value;

            if (typeof o.type === "string") o.type = o.type.toLowerCase();

            element
                .html("")
                .addClass("progress");

            function _progress(){
                $("<div>").addClass("bar").appendTo(element);
            }

            function _buffer(){
                $("<div>").addClass("bar").appendTo(element);
                $("<div>").addClass("buffer").appendTo(element);
            }

            function _load(){
                element.addClass("with-load");
                $("<div>").addClass("bar").appendTo(element);
                $("<div>").addClass("buffer").appendTo(element);
                $("<div>").addClass("load").appendTo(element);
            }

            function _line(){
                element.addClass("line");
            }

            switch (o.type) {
                case "buffer": _buffer(); break;
                case "load": _load(); break;
                case "line": _line(); break;
                default: _progress();
            }

            if (o.type !== 'line') {
                value = $("<span>").addClass("value").addClass(o.clsValue).appendTo(element);
                if (o.valuePosition === "center") value.addClass("centered");
                if (o.showValue === false) value.hide();
            }

            if (o.small === true) element.addClass("small");

            element.addClass(o.clsBack);
            element.find(".bar").addClass(o.clsBar);
            element.find(".buffer").addClass(o.clsBuffer);

            if (o.showLabel === true) {
                var label = $("<span>").addClass("progress-label").addClass(o.clsLabel).html(o.labelTemplate === "" ? o.value+"%" : o.labelTemplate.replace("%VAL%", o.value));
                if (o.labelPosition === 'before') {
                    label.insertBefore(element);
                } else {
                    label.insertAfter(element);
                }
            }

            this.val(o.value);
            this.buff(o.buffer);

            this._fireEvent("progress-create", {
                element: element
            });
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var value = element.find(".value");

            if (v === undefined) {
                return that.value;
            }

            var bar  = element.find(".bar");

            if (bar.length === 0) {
                return false;
            }

            this.value = parseInt(v, 10);

            bar.css("width", this.value + "%");
            value.html(this.value+"%");

            var diff = element.width() - bar.width();
            var valuePosition = value.width() > diff ? {left: "auto", right: diff + 'px'} : {left: v + '%'};

            if (o.valuePosition === "free") value.css(valuePosition);

            if (o.showLabel === true) {
                var label = element[o.labelPosition === "before" ? "prev" : "next"](".progress-label");
                if (label.length) {
                    label.html(o.labelTemplate === "" ? o.value+"%" : o.labelTemplate.replace("%VAL%", o.value));
                }
            }

            this._fireEvent("value-change", {
                val: this.value
            });

            if (this.value === 100) {

                this._fireEvent("complete", {
                    val: this.value
                });

            }
        },

        buff: function(v){
            var that = this, element = this.element;

            if (v === undefined) {
                return that.buffer;
            }

            var bar  = element.find(".buffer");

            if (bar.length === 0) {
                return false;
            }

            this.buffer = parseInt(v, 10);

            bar.css("width", this.buffer + "%");

            this._fireEvent("buffer-change", {
                val: this.buffer
            });

            if (this.buffer === 100) {
                this._fireEvent("buffered", {
                    val: this.buffer
                });
            }
        },

        changeValue: function(){
            this.val(this.element.attr('data-value'));
        },

        changeBuffer: function(){
            this.buff(this.element.attr('data-buffer'));
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-value': this.changeValue(); break;
                case 'data-buffer': this.changeBuffer(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RadioDefaultConfig = {
        radioDeferred: 0,
        transition: true,
        style: 1,
        caption: "",
        captionPosition: "right",
        clsRadio: "",
        clsCheck: "",
        clsCaption: "",
        onRadioCreate: Metro.noop
    };

    Metro.radioSetup = function (options) {
        RadioDefaultConfig = $.extend({}, RadioDefaultConfig, options);
    };

    if (typeof window["metroRadioSetup"] !== undefined) {
        Metro.radioSetup(window["metroRadioSetup"]);
    }

    Metro.Component('radio', {
        init: function( options, elem ) {
            this._super(elem, options, RadioDefaultConfig, {
                origin: {
                    className: ""
                }
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("radio-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var radio = $("<label>").addClass("radio " + element[0].className).addClass(o.style === 2 ? "style2" : "");
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "radio");

            radio.insertBefore(element);
            element.appendTo(radio);
            check.appendTo(radio);
            caption.appendTo(radio);

            if (o.transition === true) {
                radio.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                radio.addClass("caption-left");
            }

            this.origin.className = element[0].className;
            element[0].className = '';

            radio.addClass(o.clsRadio);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var element = this.element, check = element.siblings(".check");

            element.on("focus", function(){
                check.addClass("focused");
            });

            element.on("blur", function(){
                check.removeClass("focused");
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;
            var parent = element.parent();

            var changeStyle = function(){
                var new_style = parseInt(element.attr("data-style"));

                if (!Utils.isInt(new_style)) return;

                o.style = new_style;
                parent.removeClass("style1 style2").addClass("style"+new_style);
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'data-style': changeStyle(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RatingDefaultConfig = {
        ratingDeferred: 0,
        label: "",
        static: false,
        title: null,
        value: 0,
        values: null,
        message: "",
        stars: 5,
        starColor: null,
        staredColor: null,
        roundFunc: "round", // ceil, floor, round
        half: true,
        clsRating: "",
        clsTitle: "",
        clsStars: "",
        clsResult: "",
        clsLabel: "",
        onStarClick: Metro.noop,
        onRatingCreate: Metro.noop
    };

    Metro.ratingSetup = function (options) {
        RatingDefaultConfig = $.extend({}, RatingDefaultConfig, options);
    };

    if (typeof window["metroRatingSetup"] !== undefined) {
        Metro.ratingSetup(window["metroRatingSetup"]);
    }

    Metro.Component('rating', {
        init: function( options, elem ) {
            this._super(elem, options, RatingDefaultConfig, {
                value: 0,
                originValue: 0,
                values: [],
                rate: 0,
                rating: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i;

            if (isNaN(o.value)) {
                o.value = 0;
            } else {
                o.value = parseFloat(o.value).toFixed(1);
            }

            if (o.values !== null) {
                if (Array.isArray(o.values)) {
                    this.values = o.values;
                } else if (typeof o.values === "string") {
                    this.values = o.values.toArray()
                }
            } else {
                for(i = 1; i <= o.stars; i++) {
                    this.values.push(i);
                }
            }

            this.originValue = o.value;
            this.value = o.value > 0 ? Math[o.roundFunc](o.value) : 0;

            this._createRating();
            this._createEvents();

            this._fireEvent("rating-create", {
                element: element
            });
        },

        _createRating: function(){
            var element = this.element, o = this.options;

            var id = Utils.elementId("rating");
            var rating = $("<div>").addClass("rating " + String(element[0].className).replace("d-block", "d-flex")).addClass(o.clsRating);
            var i, stars, result, li;
            var sheet = Metro.sheet;
            var value = o.static ? Math.floor(this.originValue) : this.value;

            element.val(this.value);

            rating.attr("id", id);

            rating.insertBefore(element);
            element.appendTo(rating);

            stars = $("<ul>").addClass("stars").addClass(o.clsStars).appendTo(rating);

            for(i = 1; i <= o.stars; i++) {
                li = $("<li>").data("value", this.values[i-1]).appendTo(stars);
                if (i <= value) {
                    li.addClass("on");
                }
            }

            result = $("<span>").addClass("result").addClass(o.clsResult).appendTo(rating);

            result.html(o.message);

            if (o.starColor !== null && Metro.colors.isColor(o.starColor)) {
                Utils.addCssRule(sheet, "#" + id + " .stars:hover li", "color: " + o.starColor + ";");
            }
            if (o.staredColor !== null && Metro.colors.isColor(o.staredColor)) {
                Utils.addCssRule(sheet, "#"+id+" .stars li.on", "color: "+o.staredColor+";");
                Utils.addCssRule(sheet, "#"+id+" .stars li.half::after", "color: "+o.staredColor+";");
            }

            if (o.title !== null) {
                var title = $("<span>").addClass("title").addClass(o.clsTitle).html(o.title);
                rating.prepend(title);
            }

            if (o.static === true) {
                rating.addClass("static");
                if (o.half === true){
                    var dec = Math.round((this.originValue % 1) * 10);
                    if (dec > 0 && dec <= 9) {
                        rating.find('.stars li.on').last().next("li").addClass("half half-" + ( dec * 10));
                    }
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    rating.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(rating);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.rating = rating;
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var rating = this.rating;

            rating.on(Metro.events.click, ".stars li", function(){

                if (o.static === true) {
                    return ;
                }

                var star = $(this);
                var value = star.data("value");
                star.addClass("scale");
                setTimeout(function(){
                    star.removeClass("scale");
                }, 300);
                element.val(value).trigger("change");
                star.addClass("on");
                star.prevAll().addClass("on");
                star.nextAll().removeClass("on");

                that._fireEvent("star-click", {
                    value: value,
                    star: star[0]
                });

            });
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var rating = this.rating;

            if (v === undefined) {
                return this.value;
            }

            this.value = v > 0 ? Math[o.roundFunc](v) : 0;
            element.val(this.value).trigger("change");

            var stars = rating.find(".stars li").removeClass("on");
            $.each(stars, function(){
                var star = $(this);
                if (star.data("value") <= that.value) {
                    star.addClass("on");
                }
            });

            return this;
        },

        msg: function(m){
            var rating = this.rating;
            if (m ===  undefined) {
                return ;
            }
            rating.find(".result").html(m);
            return this;
        },

        static: function (mode) {
            var o = this.options;
            var rating = this.rating;

            o.static = mode;

            if (mode === true) {
                rating.addClass("static");
            } else {
                rating.removeClass("static");
            }
        },

        changeAttributeValue: function(a){
            var element = this.element;
            var value = a === "value" ? element.val() : element.attr("data-value");
            this.val(value);
        },

        changeAttributeMessage: function(){
            var element = this.element;
            var message = element.attr("data-message");
            this.msg(message);
        },

        changeAttributeStatic: function(){
            var element = this.element;
            var isStatic = JSON.parse(element.attr("data-static")) === true;

            this.static(isStatic);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "value":
                case "data-value": this.changeAttributeValue(attributeName); break;
                case "disabled": this.toggleState(); break;
                case "data-message": this.changeAttributeMessage(); break;
                case "data-static": this.changeAttributeStatic(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var rating = this.rating;

            rating.off(Metro.events.click, ".stars li");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ResizableDefaultConfig = {
        resizableDeferred: 0,
        canResize: true,
        resizeElement: ".resize-element",
        minWidth: 0,
        minHeight: 0,
        maxWidth: 0,
        maxHeight: 0,
        preserveRatio: false,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResize: Metro.noop,
        onResizableCreate: Metro.noop
    };

    Metro.resizableSetup = function (options) {
        ResizableDefaultConfig = $.extend({}, ResizableDefaultConfig, options);
    };

    if (typeof window["metroResizableSetup"] !== undefined) {
        Metro.resizableSetup(window["metroResizableSetup"]);
    }

    Metro.Component('resizable', {
        init: function( options, elem ) {
            this._super(elem, options, ResizableDefaultConfig, {
                resizer: null,
                id: Utils.elementId("resizable")
            });

            return this;
        },

        _create: function(){
            this._createStructure();
            this._createEvents();

            this._fireEvent("resizable-create");
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            element.data("canResize", true);
            element.addClass("resizable-element");

            if (Utils.isValue(o.resizeElement) && element.find(o.resizeElement).length > 0) {
                this.resizer = element.find(o.resizeElement);
            } else {
                this.resizer = $("<span>").addClass("resize-element").appendTo(element);
            }

            element.data("canResize", o.canResize);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            this.resizer.on(Metro.events.start, function(e){

                if (element.data('canResize') === false) {
                    return ;
                }

                var startXY = Utils.pageXY(e);
                var startWidth = parseInt(element.outerWidth());
                var startHeight = parseInt(element.outerHeight());
                var size = {width: startWidth, height: startHeight};

                element.addClass("stop-pointer");

                that._fireEvent("resize-start", {
                    size: size
                });

                $(document).on(Metro.events.move, function(e){
                    var moveXY = Utils.pageXY(e);
                    var size = {
                        width: startWidth + moveXY.x - startXY.x,
                        height: startHeight + moveXY.y - startXY.y
                    };

                    if (o.maxWidth > 0 && size.width > o.maxWidth) {return true;}
                    if (o.minWidth > 0 && size.width < o.minWidth) {return true;}

                    if (o.maxHeight > 0 && size.height > o.maxHeight) {return true;}
                    if (o.minHeight > 0 && size.height < o.minHeight) {return true;}

                    element.css(size);

                    that._fireEvent("resize", {
                        size: size
                    })

                }, {ns: that.id});

                $(document).on(Metro.events.stop, function(){
                    element.removeClass("stop-pointer");

                    $(document).off(Metro.events.move, {ns: that.id});
                    $(document).off(Metro.events.stop, {ns: that.id});

                    var size = {
                        width: parseInt(element.outerWidth()),
                        height: parseInt(element.outerHeight())
                    };

                    that._fireEvent("resize-stop", {
                        size: size
                    });

                }, {ns: that.id});

                e.preventDefault();
                e.stopPropagation();
            });

        },

        off: function(){
            this.element.data("canResize", false);
        },

        on: function(){
            this.element.data("canResize", true);
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;

            var canResize = function(){
                o.canResize = JSON.parse(element.attr('data-can-resize')) === true;
            };

            switch (attributeName) {
                case "data-can-resize": canResize(); break;
            }
        },

        destroy: function(){
            this.resizer.off(Metro.events.start);
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ResizerDefaultConfig = {
        resizerDeferred: 0,
        onMediaPoint: Metro.noop,
        onMediaPointEnter: Metro.noop,
        onMediaPointLeave: Metro.noop,
        onWindowResize: Metro.noop,
        onElementResize: Metro.noop,
        onResizerCreate: Metro.noop
    };

    Metro.resizerSetup = function (options) {
        ResizerDefaultConfig = $.extend({}, ResizerDefaultConfig, options);
    };

    if (typeof window["metroResizerSetup"] !== undefined) {
        Metro.resizerSetup(window["metroResizerSetup"]);
    }

    Metro.Component('resizer', {
        init: function( options, elem ) {
            this._super(elem, options, ResizerDefaultConfig, {
                size: {width: 0, height: 0},
                media: window.METRO_MEDIA,
                id: Utils.elementId("resizer")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this.size = {
                width: element.width(),
                height: element.height()
            };

            this._createStructure();
            this._createEvents();

            this._fireEvent("resizer-create", {
                element: element
            });
        },

        _createStructure: function(){
        },

        _createEvents: function(){
            var that = this, element = this.element;
            var win = $.window();

            win.on("resize", function(){
                var windowWidth = win.width(), windowHeight = win.height();
                var elementWidth = element.width(), elementHeight = element.height();
                var oldSize = that.size;
                var point;

                that._fireEvent("window-resize", {
                    width: windowWidth,
                    height: windowHeight,
                    media: window.METRO_MEDIA
                });

                if (that.size.width !== elementWidth || that.size.height !== elementHeight) {
                    that.size = {
                        width: elementWidth,
                        height: elementHeight
                    };

                    that._fireEvent("element-resize", {
                        width: elementWidth,
                        height: elementHeight,
                        oldSize: oldSize,
                        media: window.METRO_MEDIA
                    });

                }

                if (that.media.length !== window.METRO_MEDIA.length) {
                    if (that.media.length > window.METRO_MEDIA.length) {
                        point = that.media.filter(function(x){
                            return !window.METRO_MEDIA.includes(x);
                        });

                        that._fireEvent("media-point-leave", {
                            point: point,
                            media: window.METRO_MEDIA
                        });

                    } else {
                        point = window.METRO_MEDIA.filter(function(x){
                            return !that.media.includes(x);
                        });

                        that._fireEvent("media-point-enter", {
                            point: point,
                            media: window.METRO_MEDIA
                        });
                    }

                    that.media = window.METRO_MEDIA;

                    that._fireEvent("media-point", {
                        point: point,
                        media: window.METRO_MEDIA
                    });
                }
            }, {ns: this.id});
        },

        changeAttribute: function(){
        },

        destroy: function(){
            $(window).off("resize", {ns: this.id});
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RibbonMenuDefaultConfig = {
        ribbonmenuDeferred: 0,
        onStatic: Metro.noop,
        onBeforeTab: Metro.noop_true,
        onTab: Metro.noop,
        onRibbonMenuCreate: Metro.noop
    };

    Metro.ribbonMenuSetup = function (options) {
        RibbonMenuDefaultConfig = $.extend({}, RibbonMenuDefaultConfig, options);
    };

    if (typeof window["metroRibbonMenuSetup"] !== undefined) {
        Metro.ribbonMenuSetup(window["metroRibbonMenuSetup"]);
    }

    Metro.Component('ribbon-menu', {
        init: function( options, elem ) {
            this._super(elem, options, RibbonMenuDefaultConfig);

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("ribbon-menu-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element;

            element.addClass("ribbon-menu");

            var tabs = element.find(".tabs-holder li:not(.static)");
            var active_tab = element.find(".tabs-holder li.active");
            if (active_tab.length > 0) {
                this.open($(active_tab[0]));
            } else {
                if (tabs.length > 0) {
                    this.open($(tabs[0]));
                }
            }

            var fluentGroups = element.find(".ribbon-toggle-group");
            $.each(fluentGroups, function(){
                var g = $(this);
                g.buttongroup({
                    clsActive: "active"
                });

                var gw = 0;
                var btns = g.find(".ribbon-icon-button");
                $.each(btns, function(){
                    var b = $(this);
                    var w = b.outerWidth(true);
                    if (w > gw) gw = w;
                });

                g.css("width", gw * Math.ceil(btns.length / 3) + 4);
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".tabs-holder li a", function(e){
                var link = $(this);
                var tab = $(this).parent("li");

                if (tab.hasClass("static")) {
                    if (o.onStatic === Metro.noop && link.attr("href") !== undefined) {
                        document.location.href = link.attr("href");
                    } else {
                        that._fireEvent("static", {
                            tab: tab[0]
                        });
                    }
                } else {
                    if (Utils.exec(o.onBeforeTab, [tab[0]], element[0]) === true) {
                        that.open(tab[0]);
                    }
                }
                e.preventDefault();
            })
        },

        open: function(tab){
            var element = this.element;
            var $tab = $(tab);
            var tabs = element.find(".tabs-holder li");
            var sections = element.find(".content-holder .section");
            var target = $tab.children("a").attr("href");
            var target_section = target !== "#" ? element.find(target) : null;

            tabs.removeClass("active");
            $tab.addClass("active");

            sections.removeClass("active");
            if (target_section) target_section.addClass("active");

            this._fireEvent("tab", {
                tab: $tab[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".tabs-holder li a");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var RippleDefaultConfig = {
        rippleDeferred: 0,
        rippleColor: "#fff",
        rippleAlpha: .4,
        rippleTarget: "default",
        onRippleCreate: Metro.noop
    };

    Metro.rippleSetup = function (options) {
        RippleDefaultConfig = $.extend({}, RippleDefaultConfig, options);
    };

    if (typeof window["metroRippleSetup"] !== undefined) {
        Metro.rippleSetup(window["metroRippleSetup"]);
    }

    var getRipple = function(target, color, alpha, event){
        var el = $(target);
        var rect = Utils.rect(el[0]);
        var x, y;
        var Colors = Metro.colors;

        if (el.length === 0) {
            return ;
        }

        if (!Utils.isValue(color)) {
            color = "#fff";
        }

        if (!Utils.isValue(alpha)) {
            alpha = .4;
        }

        if (el.css('position') === 'static') {
            el.css('position', 'relative');
        }

        el.css({
            overflow: 'hidden'
        });

        $(".ripple").remove();

        var size = Math.max(el.outerWidth(), el.outerHeight());

        // Add the element
        var ripple = $("<span class='ripple'></span>").css({
            width: size,
            height: size
        });

        el.prepend(ripple);

        if (event) {
            // Get touch point x, y
            x = event.pageX - el.offset().left - ripple.width()/2;
            y = event.pageY - el.offset().top - ripple.height()/2;
        } else {
            // Get the center of the element
            x = rect.width / 2 - ripple.width()/2;
            y = rect.height / 2 - ripple.height()/2;
        }

        ripple.css({
            background: Colors.toRGBA(color, alpha),
            width: size,
            height: size,
            top: y + 'px',
            left: x + 'px'
        }).addClass("rippleEffect");

        setTimeout(function(){
            ripple.remove();
        }, 400);
    };

    Metro.Component('ripple', {
        init: function( options, elem ) {
            this._super(elem, options, RippleDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var target = o.rippleTarget === 'default' ? null : o.rippleTarget;

            element.on(Metro.events.click, target, function(e){
                getRipple(this, o.rippleColor, o.rippleAlpha, e);
            });

            this._fireEvent("riopple-create", {
                element: element
            });
        },

        changeAttribute: function(attributeName){
            var element = this.element, o = this.options;

            function changeColor(){
                var color = element.attr("data-ripple-color");
                if (!Metro.colors.isColor(color)) {
                    return;
                }
                o.rippleColor = color;
            }

            function changeAlpha(){
                var alpha = +element.attr("data-ripple-alpha");
                if (isNaN(alpha)) {
                    return;
                }
                o.rippleColor = alpha;
            }

            switch (attributeName) {
                case "data-ripple-color": changeColor(); break;
                case "data-ripple-alpha": changeAlpha(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var target = o.rippleTarget === 'default' ? null : o.rippleTarget;
            element.off(Metro.events.click, target);
        }
    });

    Metro.ripple = getRipple;
}(Metro, m4q));

/* eslint-disable */
(function(Metro, $) {
    'use strict';

    var SearcherDefaultConfig = {
        onSearcherCreate: Metro.noop
    };

    Metro.searcherSetup = function (options) {
        SearcherDefaultConfig = $.extend({}, SearcherDefaultConfig, options);
    };

    if (typeof window["metroSearcherSetup"] !== undefined) {
        Metro.searcherSetup(window["metroSearcherSetup"]);
    }

    Metro.Component('searcher', {
        init: function( options, elem ) {
            this._super(elem, options, SearcherDefaultConfig, {
                // define instance vars here
            });
            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;

            this._createStructure();
            this._createEvents();

            this._fireEvent('searcher-create');
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

        },

        changeAttribute: function(attr, newValue){
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));
/* eslint-enable */

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SelectDefaultConfig = {
        label: "",
        size: "normal",
        selectDeferred: 0,
        clearButton: false,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        usePlaceholder: false,
        placeholder: "",
        addEmptyValue: false,
        emptyValue: "",
        duration: 0,
        prepend: "",
        append: "",
        filterPlaceholder: "Search...",
        filter: true,
        copyInlineStyles: false,
        dropHeight: 200,
        dropWidth: null,
        dropFullSize: false,
        checkDropUp: true,
        dropUp: false,
        showGroupName: false,
        shortTag: true,

        clsSelect: "",
        clsSelectInput: "",
        clsPrepend: "",
        clsAppend: "",
        clsOption: "",
        clsOptionActive: "",
        clsOptionGroup: "",
        clsDropList: "",
        clsDropContainer: "",
        clsSelectedItem: "",
        clsSelectedItemRemover: "",
        clsLabel: "",
        clsGroupName: "",

        onClear: Metro.noop,
        onChange: Metro.noop,
        onUp: Metro.noop,
        onDrop: Metro.noop,
        onItemSelect: Metro.noop,
        onItemDeselect: Metro.noop,
        onSelectCreate: Metro.noop
    };

    Metro.selectSetup = function (options) {
        SelectDefaultConfig = $.extend({}, SelectDefaultConfig, options);
    };

    if (typeof window["metroSelectSetup"] !== undefined) {
        Metro.selectSetup(window["metroSelectSetup"]);
    }

    Metro.Component('select', {
        init: function( options, elem ) {
            this._super(elem, options, SelectDefaultConfig, {
                list: null,
                placeholder: null
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createSelect();
            this._createEvents();

            this._fireEvent("select-create", {
                element: element
            });
        },

        _setPlaceholder: function(){
            var element = this.element, o = this.options;
            var input = element.siblings(".select-input");
            if (o.usePlaceholder === true && (!Utils.isValue(element.val()) || element.val() == o.emptyValue)) {
                input.html(this.placeholder);
            }
        },

        _addTag: function(val, data){
            var element = this.element, o = this.options;
            var tag, tagSize, container = element.closest(".select");
            tag = $("<div>").addClass("tag").addClass(o.shortTag ? "short-tag" : "").addClass(o.clsSelectedItem).html("<span class='title'>"+val+"</span>").data("option", data);
            $("<span>").addClass("remover").addClass(o.clsSelectedItemRemover).html("&times;").appendTo(tag);

            if (container.hasClass("input-large")) {
                tagSize = "large";
            } else if (container.hasClass("input-small")) {
                tagSize = "small"
            }

            tag.addClass(tagSize);

            return tag;
        },

        _addOption: function(item, parent, input, multiple, group){
            var option = $(item);
            var l, a;
            var element = this.element, o = this.options;
            var html = Utils.isValue(option.attr('data-template')) ? option.attr('data-template').replace("$1", item.text):item.text;
            var displayValue = option.attr("data-display");

            l = $("<li>").addClass(o.clsOption).data("option", item).attr("data-text", item.text).attr('data-value', item.value ? item.value : "");
            a = $("<a>").html(html);

            if (displayValue) {
                l.attr("data-display", displayValue);
                html = displayValue;
            }

            l.addClass(item.className);

            l.data("group", group);

            if (option.is(":disabled")) {
                l.addClass("disabled");
            }

            if (option.is(":selected")) {

                if (o.showGroupName && group) {
                    html += "&nbsp;<span class='selected-item__group-name "+o.clsGroupName+"'>" + group + "</span>";
                }

                if (multiple) {
                    l.addClass("d-none");
                    input.append(this._addTag(html, l));
                } else {
                    element.val(item.value);
                    input.html(html);
                    element.fire("change", {
                        val: item.value
                    });
                    l.addClass("active");
                }
            }

            l.append(a).appendTo(parent);
        },

        _addOptionGroup: function(item, parent, input, multiple){
            var that = this, o = this.options;
            var group = $(item);

            $("<li>").html(item.label).addClass("group-title").addClass(o.clsOptionGroup).appendTo(parent);

            $.each(group.children(), function(){
                that._addOption(this, parent, input, multiple, item.label);
            })
        },

        _createOptions: function(){
            var that = this, element = this.element, o = this.options, select = element.parent();
            var list = select.find("ul").empty();
            var selected = element.find("option[selected]").length > 0;
            var multiple = element[0].multiple;
            var input = element.siblings(".select-input");

            element.siblings(".select-input").empty();

            if (o.addEmptyValue === true) {
                element.prepend($("<option "+(!selected ? 'selected' : '')+" value='"+o.emptyValue+"' class='d-none'></option>"));
            }

            $.each(element.children(), function(){
                if (this.tagName === "OPTION") {
                    that._addOption(this, list, input, multiple, null);
                } else if (this.tagName === "OPTGROUP") {
                    that._addOptionGroup(this, list, input, multiple);
                }
            });
        },

        _createSelect: function(){
            var that = this, element = this.element, o = this.options;

            var container = $("<label>").addClass("select " + element[0].className).addClass(o.clsSelect);
            var multiple = element[0].multiple;
            var select_id = Utils.elementId("select");
            var buttons = $("<div>").addClass("button-group");
            var input, drop_container, drop_container_input, list, filter_input, dropdown_toggle;
            var checkboxID = Utils.elementId("select-focus-trigger");
            var checkbox = $("<input type='checkbox'>").addClass("select-focus-trigger").attr("id", checkboxID);

            this.placeholder = $("<span>").addClass("placeholder").html(o.placeholder);

            container.attr("id", select_id).attr("for", checkboxID);
            container.addClass("input-" + o.size);

            dropdown_toggle = $("<span>").addClass("dropdown-toggle");
            dropdown_toggle.appendTo(container);

            if (multiple) {
                container.addClass("multiple");
            }

            container.insertBefore(element);
            element.appendTo(container);
            buttons.appendTo(container);
            checkbox.appendTo(container);

            input = $("<div>").addClass("select-input").addClass(o.clsSelectInput).attr("name", "__" + select_id + "__");
            drop_container = $("<div>").addClass("drop-container").addClass(o.clsDropContainer);

            if (o.dropFullSize === false) {
                if (o.dropWidth) {
                    drop_container.css({
                        width: +o.dropWidth
                    })
                }
            } else {
                container.addClass("drop-full-size")
            }

            drop_container_input = $("<div>").appendTo(drop_container);
            list = $("<ul>").addClass("option-list").addClass(o.clsDropList).css({
                "max-height": o.dropHeight
            });
            filter_input = $("<input type='text' data-role='input'>").attr("placeholder", o.filterPlaceholder).appendTo(drop_container_input);

            container.append(input);
            container.append(drop_container);

            drop_container.append(drop_container_input);

            if (o.filter !== true) {
                drop_container_input.hide();
            }

            drop_container.append(list);

            this._createOptions();

            this._setPlaceholder();

            Metro.makePlugin(drop_container, "dropdown", {
                dropFilter: ".select",
                duration: o.duration,
                toggleElement: [container],
                checkDropUp: o.checkDropUp,
                dropUp: o.dropUp,
                onDrop: function(){
                    var dropped, target;
                    dropdown_toggle.addClass("active-toggle");
                    dropped = $(".select .drop-container");
                    $.each(dropped, function(){
                        var drop = $(this);
                        if (drop.is(drop_container)) {
                            return ;
                        }
                        var dataDrop = Metro.getPlugin(drop, 'dropdown');
                        if (dataDrop && dataDrop.close) {
                            dataDrop.close();
                        }
                    });

                    filter_input.val("").trigger(Metro.events.keyup);//.focus();

                    target = list.find("li.active").length > 0 ? $(list.find("li.active")[0]) : undefined;
                    if (target !== undefined) {
                        list[0].scrollTop = target.position().top - ( (list.height() - target.height() )/ 2);
                    }

                    that._fireEvent("drop", {
                        list: list[0]
                    });
                },
                onUp: function(){
                    dropdown_toggle.removeClass("active-toggle");

                    that._fireEvent("up", {
                        list: list[0]
                    });
                }
            });

            this.list = list;

            if (o.clearButton === true && !element[0].readOnly) {
                var clearButton = $("<button>").addClass("button input-clear-button").addClass(o.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(buttons);
            } else {
                buttons.addClass("d-none");
            }

            if (o.prepend !== "" && !multiple) {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (o.append !== "" && !multiple) {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
            }

            if (o.copyInlineStyles === true) {
                for (var i = 0, l = element[0].style.length; i < l; i++) {
                    container.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".select");
            var drop_container = container.find(".drop-container");
            var input = element.siblings(".select-input");
            var filter_input = drop_container.find("input");
            var list = drop_container.find("ul");
            var clearButton = container.find(".input-clear-button");
            var checkbox = container.find(".select-focus-trigger");

            checkbox.on("focus", function(){
                container.addClass("focused");
            });

            checkbox.on("blur", function(){
                container.removeClass("focused");
            });

            clearButton.on(Metro.events.click, function(e){
                element.val(o.emptyValue);
                if (element[0].multiple) {
                    list.find("li").removeClass("d-none");
                }

                input.clear();
                that._setPlaceholder();

                e.preventDefault();
                e.stopPropagation();

                that._fireEvent("clear");
                that._fireEvent("change", {
                    selected: that.getSelected()
                });
            });

            element.on(Metro.events.change, function(){
                that._setPlaceholder();
            });

            container.on(Metro.events.click, function(){
                $(".focused").removeClass("focused");
                container.addClass("focused");
            });

            input.on(Metro.events.click, function(){
                $(".focused").removeClass("focused");
                container.addClass("focused");
            });

            list.on(Metro.events.click, "li", function(e){
                if ($(this).hasClass("group-title")) {
                    e.preventDefault();
                    e.stopPropagation();
                    return ;
                }
                var leaf = $(this);
                var displayValue = leaf.attr("data-display");
                var val = leaf.data('value');
                var group = leaf.data('group');
                var html = displayValue ? displayValue : leaf.children('a').html();
                var selected;
                var option = leaf.data("option");
                var options = element.find("option");

                if (o.showGroupName && group) {
                    html += "&nbsp;<span class='selected-item__group-name "+o.clsGroupName+"'>" + group + "</span>";
                }

                if (element[0].multiple) {
                    leaf.addClass("d-none");
                    input.append(that._addTag(html, leaf));
                } else {
                    list.find("li.active").removeClass("active").removeClass(o.clsOptionActive);
                    leaf.addClass("active").addClass(o.clsOptionActive);
                    input.html(html);
                    Metro.getPlugin(drop_container, "dropdown").close();
                }

                $.each(options, function(){
                    if (this === option) {
                        this.selected = true;
                    }
                });

                that._fireEvent("item-select", {
                    val: val,
                    option: option,
                    leaf: leaf[0]
                });

                selected = that.getSelected();

                that._fireEvent("change", {
                    selected: selected
                });
            });

            input.on("click", ".tag .remover", function(e){
                var item = $(this).closest(".tag");
                var leaf = item.data("option");
                var option = leaf.data('option');
                var selected;

                leaf.removeClass("d-none");
                $.each(element.find("option"), function(){
                    if (this === option) {
                        this.selected = false;
                    }
                });
                item.remove();

                that._fireEvent("item-deselect", {
                    option: option
                });

                selected = that.getSelected();

                that._fireEvent("change", {
                    selected: selected
                });

                e.preventDefault();
                e.stopPropagation();
            });

            filter_input.on(Metro.events.keyup, function(){
                var filter = this.value.toUpperCase();
                var li = list.find("li");
                var i, a;
                for (i = 0; i < li.length; i++) {
                    if ($(li[i]).hasClass("group-title")) continue;
                    a = li[i].getElementsByTagName("a")[0];
                    if (a.innerHTML.toUpperCase().indexOf(filter) > -1) {
                        li[i].style.display = "";
                    } else {
                        li[i].style.display = "none";
                    }
                }
            });

            filter_input.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            });

            drop_container.on(Metro.events.click, function(e){
                e.preventDefault();
                e.stopPropagation();
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.closest(".select").addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.closest(".select").removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        reset: function(to_default){
            var element = this.element;
            var options = element.find("option");
            var select = element.closest('.select');
            var selected;

            $.each(options, function(){
                this.selected = !Utils.isNull(to_default) ? this.defaultSelected : false;
            });

            this.list.find("li").remove();
            select.find(".select-input").html('');

            this._createOptions();

            selected = this.getSelected();

            this._fireEvent("change", {
                selected: selected
            });
        },

        getSelected: function(){
            var element = this.element;
            var result = [];

            element.find("option").each(function(){
                if (this.selected) result.push(this.value);
            });

            return result;
        },

        val: function(val){
            var that = this, element = this.element, o = this.options;
            var input = element.siblings(".select-input");
            var options = element.find("option");
            var list_items = this.list.find("li");
            var result = [];
            var multiple = element.attr("multiple") !== undefined;
            var option;
            var i, html, list_item, option_value, selected, group;

            if (Utils.isNull(val)) {
                $.each(options, function(){
                    if (this.selected) result.push(this.value);
                });
                return multiple ? result : result[0];
            }

            $.each(options, function(){
                this.selected = false;
            });
            list_items.removeClass("active").removeClass(o.clsOptionActive);
            input.html('');

            if (Array.isArray(val) === false) {
                val  = [val];
            }

            $.each(val, function(){
                for (i = 0; i < options.length; i++) {
                    option = options[i];
                    html = Utils.isValue(option.getAttribute('data-template')) ? option.getAttribute('data-template').replace("$1", option.text) : option.text;
                    if (""+option.value === ""+this) {
                        option.selected = true;
                        break;
                    }
                }

                for(i = 0; i < list_items.length; i++) {
                    list_item = $(list_items[i]);
                    group = list_item.data("group");
                    option_value = list_item.attr("data-value");
                    if (""+option_value === ""+this) {

                        if (o.showGroupName && group) {
                            html += "&nbsp;<span class='selected-item__group-name'>" + group + "</span>";
                        }

                        if (multiple) {
                            list_item.addClass("d-none");
                            input.append(that._addTag(html, list_item));

                            // tag = $("<div>").addClass("tag").addClass(o.clsSelectedItem).html("<span class='title'>"+html+"</span>").appendTo(input);
                            // tag.data("option", list_item);
                            // $("<span>").addClass("remover").addClass(o.clsSelectedItemRemover).html("&times;").appendTo(tag);
                        } else {
                            list_item.addClass("active").addClass(o.clsOptionActive);
                            input.html(html);
                        }
                        break;
                    }
                }
            });

            selected = this.getSelected();

            this._fireEvent("change", {
                selected: selected
            });
        },

        options: function(op, selected, delimiter){
            return this.data(op, selected, delimiter);
        },

        data: function(op, selected, delimiter){
            var element = this.element;
            var option_group, _selected;
            var _delimiter = delimiter || ",";

            if (typeof selected === "string") {
                _selected = selected.toArray(_delimiter).map(function(v){
                    return isNaN(v) ? v : +v;
                });
            } else if (Array.isArray(selected)) {
                _selected = selected.slice().map(function(v){
                    return isNaN(v) ? v : +v;
                });
            } else {
                _selected = [];
            }

            element.empty();

            if (typeof op === 'string') {
                element.html(op);
            } else if (Utils.isObject2(op)) {
                $.each(op, function(key, val){
                    if (Utils.isObject2(val)) {
                        option_group = $("<optgroup label=''>").attr("label", key).appendTo(element);
                        $.each(val, function(key2, val2){
                            var op = $("<option>").attr("value", key2).text(val2).appendTo(option_group);
                            if (_selected.indexOf(+key2) > -1) {
                                op.prop("selected", true);
                            }
                        });
                    } else {
                        var op = $("<option>").attr("value", key).text(val).appendTo(element);
                        if (_selected.indexOf(key) > -1) {
                            op.prop("selected", true);
                        }
                    }
                });
            }

            this._createOptions();

            return this;
        },

        addOption: function(val, title, selected){
            var element = this.element;
            var option = $("<option>").attr("value", val).text(title ? title : val)

            element.append(option)

            if (selected) {
                option.prop("selected", true)
            }

            this._createOptions();

            return this;
        },

        addOptions: function(values){
            var that = this;

            if (!values) {
                return this;
            }

            if (Array.isArray(values)) {
                $.each(values, function(){
                    var o = this;
                    if (Metro.utils.isObject2(o)) {
                        that.addOption(o.val, o.title, o.selected)
                    } else {
                        that.addOption(o)
                    }
                })
            } else if (Metro.utils.isObject2(values)) {
                $.each(values, function(key, val){
                    that.addOption(key, val);
                })
            }

            return this;
        },

        removeOption: function(val){
            var element = this.element;
            var options = element.find("option")

            options.each(function(){
                var $el = $(this)

                if ($el.attr("value") == val) {
                    $el.remove()
                }
            })

            this._createOptions();

            return this;
        },

        removeOptions: function(values){
            var element = this.element;
            var options = element.find("option")

            if (!values || !Array.isArray(values)) {
                return this;
            }

            options.each(function(){
                var $el = $(this);
                var val = $el.attr("value");

                if (values.indexOf(val) > -1) {
                    $el.remove()
                }
            })

            this._createOptions();

            return this;
        },

        changeAttribute: function(attributeName){
            if (attributeName === 'disabled') {
                this.toggleState();
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.closest(".select");
            var drop_container = container.find(".drop-container");
            var input = element.siblings(".select-input");
            var filter_input = drop_container.find("input");
            var list = drop_container.find("ul");
            var clearButton = container.find(".input-clear-button");

            container.off(Metro.events.click);
            container.off(Metro.events.click, ".input-clear-button");
            input.off(Metro.events.click);
            filter_input.off(Metro.events.blur);
            filter_input.off(Metro.events.focus);
            list.off(Metro.events.click, "li");
            filter_input.off(Metro.events.keyup);
            drop_container.off(Metro.events.click);
            clearButton.off(Metro.events.click);

            drop_container.data("dropdown").destroy();

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".select").removeClass("focused");
    }, {ns: "blur-select-elements"});
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SidebarDefaultConfig = {
        menuScrollbar: false,
        sidebarDeferred: 0,
        shadow: true,
        position: "left",
        size: 290,
        shift: null,
        staticShift: null,
        toggle: null,
        duration: METRO_ANIMATION_DURATION,
        static: null,
        menuItemClick: true,
        closeOutside: true,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onToggle: Metro.noop,
        onStaticSet: Metro.noop,
        onStaticLoss: Metro.noop,
        onSidebarCreate: Metro.noop
    };

    Metro.sidebarSetup = function (options) {
        SidebarDefaultConfig = $.extend({}, SidebarDefaultConfig, options);
    };

    if (typeof window["metroSidebarSetup"] !== undefined) {
        Metro.sidebarSetup(window["metroSidebarSetup"]);
    }

    Metro.Component('sidebar', {
        init: function( options, elem ) {
            this._super(elem, options, SidebarDefaultConfig, {
                toggle_element: null,
                id: Utils.elementId('sidebar')
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();
            $(window).resize();
            this._checkStatic();

            this._fireEvent("sidebar-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var header = element.find(".sidebar-header");
            var sheet = Metro.sheet;
            var menu = element.find(".sidebar-menu");

            element.addClass("sidebar").addClass("on-"+o.position);

            if (o.menuScrollbar === false) {
                menu.addClass("hide-scroll");
            }

            if (o.size !== 290) {
                Utils.addCssRule(sheet, ".sidebar", "width: " + o.size + "px;");

                if (o.position === "left") {
                    Utils.addCssRule(sheet, ".sidebar.on-left", "left: " + -o.size + "px;");
                } else {
                    Utils.addCssRule(sheet, ".sidebar.on-right", "right: " + -o.size + "px;");
                }
            }

            if (o.shadow === true) {
                element.addClass("sidebar-shadow");
            }

            if (o.toggle !== null && $(o.toggle).length > 0) {
                this.toggle_element = $(o.toggle);
            }

            if (header.length > 0) {
                if (header.data("image") !== undefined) {
                    header.css({
                        backgroundImage: "url("+header.data("image")+")"
                    });
                }
            }

            if (o.static !== null) {
                if (o.staticShift !== null) {
                    if (o.position === 'left') {
                        Utils.addCssRule(sheet, "@media screen and " + Metro.media_queries[o.static.toUpperCase()], o.staticShift + "{margin-left: " + o.size + "px; width: calc(100% - " + o.size + "px);}");
                    } else {
                        Utils.addCssRule(sheet, "@media screen and " + Metro.media_queries[o.static.toUpperCase()], o.staticShift + "{margin-right: " + o.size + "px; width: calc(100% - " + o.size + "px);}");
                    }
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var toggle = this.toggle_element;

            if (toggle !== null) {
                toggle.on(Metro.events.click, function(e){
                    that.toggle();
                    e.stopPropagation();
                });
            } else if (o.toggle) {
                $.document().on("click", o.toggle, function (e) {
                    that.toggle();
                    e.stopPropagation();
                })
            }

            if (o.static !== null && ["fs", "sm", "md", "lg", "xl", "xxl"].indexOf(o.static) > -1) {
                $(window).on(Metro.events.resize,function(){
                    that._checkStatic();
                }, {ns: this.id});
            }

            if (o.menuItemClick === true) {
                element.on(Metro.events.click, ".sidebar-menu li > a", function(e){
                    that.close();
                    e.stopPropagation();
                });
            }

            element.on(Metro.events.click, ".sidebar-menu .js-sidebar-close", function(e){
                that.close();
                e.stopPropagation();
            });

            element.on(Metro.events.click, function(e){
                e.stopPropagation();
            });

            $(document).on(Metro.events.click, function(){
                if (o.closeOutside === true) {
                    if (that.isOpen()) that.close()
                }
            })
        },

        _checkStatic: function(){
            var element = this.element, o = this.options;
            if (Utils.mediaExist(o.static) && !element.hasClass("static")) {
                element.addClass("static");
                element.data("opened", false).removeClass('open');
                if (o.shift !== null) {
                    $.each(o.shift.split(","), function(){
                        $(this)
                            .animate({
                                draw: {
                                    left: 0
                                },
                                dur: o.duration
                            })
                    });
                }

                this._fireEvent("static-set");
            }
            if (!Utils.mediaExist(o.static)) {
                element.removeClass("static");
                this._fireEvent("static-loss");
            }
        },

        isOpen: function(){
            return this.element.data("opened") === true;
        },

        open: function(){
            var element = this.element, o = this.options;

            if (element.hasClass("static")) {
                return ;
            }

            element.data("opened", true).addClass('open');

            if (o.shift !== null) {
                $(o.shift)
                    .animate({
                        draw: {
                            left: element.outerWidth()
                        },
                        dur: o.duration
                    });
            }

            this._fireEvent("open");
        },

        close: function(){
            var element = this.element, o = this.options;

            if (element.hasClass("static")) {
                return ;
            }

            element.data("opened", false).removeClass('open');

            if (o.shift !== null) {
                $(o.shift)
                    .animate({
                        draw: {
                            left: 0
                        },
                        dur: o.duration
                    });
            }

            this._fireEvent("close");
        },

        toggle: function(){
            if (this.isOpen()) {
                this.close();
            } else {
                this.open();
            }

            this._fireEvent("toggle");
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var toggle = this.toggle_element;

            if (toggle !== null) {
                toggle.off(Metro.events.click);
            }

            if (o.static !== null && ["fs", "sm", "md", "lg", "xl", "xxl"].indexOf(o.static) > -1) {
                $(window).off(Metro.events.resize, {ns: this.id});
            }

            if (o.menuItemClick === true) {
                element.off(Metro.events.click, ".sidebar-menu li > a");
            }

            element.off(Metro.events.click, ".sidebar-menu .js-sidebar-close");

            return element;
        }
    });

    Metro['sidebar'] = {
        isSidebar: function(el){
            return Utils.isMetroObject(el, "sidebar");
        },

        open: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            Metro.getPlugin(el, "sidebar").open();
        },

        close: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            Metro.getPlugin(el, "sidebar").close();
        },

        toggle: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            Metro.getPlugin(el, "sidebar").toggle();
        },

        isOpen: function(el){
            if (!this.isSidebar(el)) {
                return ;
            }
            return Metro.getPlugin(el, "sidebar").isOpen();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SliderDefaultConfig = {
        sliderDeferred: 0,
        roundValue: true,
        min: 0,
        max: 100,
        accuracy: 0,
        showMinMax: false,
        minMaxPosition: Metro.position.TOP,
        value: 0,
        buffer: 0,
        hint: false,
        hintAlways: false,
        hintPosition: Metro.position.TOP,
        hintMask: "$1",
        vertical: false,
        target: null,
        returnType: "value", // value or percent
        size: 0,

        clsSlider: "",
        clsBackside: "",
        clsComplete: "",
        clsBuffer: "",
        clsMarker: "",
        clsHint: "",
        clsMinMax: "",
        clsMin: "",
        clsMax: "",

        onStart: Metro.noop,
        onStop: Metro.noop,
        onMove: Metro.noop,
        onSliderClick: Metro.noop,
        onChange: Metro.noop,
        onChangeValue: Metro.noop,
        onChangeBuffer: Metro.noop,
        onFocus: Metro.noop,
        onBlur: Metro.noop,
        onSliderCreate: Metro.noop
    };

    Metro.sliderSetup = function (options) {
        SliderDefaultConfig = $.extend({}, SliderDefaultConfig, options);
    };

    if (typeof window["metroSliderSetup"] !== undefined) {
        Metro.sliderSetup(window["metroSliderSetup"]);
    }

    Metro.Component('slider', {
        init: function( options, elem ) {
            this._super(elem, options, SliderDefaultConfig, {
                slider: null,
                value: 0,
                percent: 0,
                pixel: 0,
                buffer: 0,
                keyInterval: false,
                id: Utils.elementId('slider')
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this._createSlider();
            this._createEvents();
            this.buff(o.buffer);
            this.val(o.value);

            this._fireEvent("slider-create", {
                element: element
            });
        },

        _createSlider: function(){
            var element = this.element, o = this.options;

            var prev = element.prev();
            var parent = element.parent();
            var slider = $("<div>").addClass("slider " + element[0].className).addClass(o.clsSlider);
            var backside = $("<div>").addClass("backside").addClass(o.clsBackside);
            var complete = $("<div>").addClass("complete").addClass(o.clsComplete);
            var buffer = $("<div>").addClass("buffer").addClass(o.clsBuffer);
            var marker = $("<button>").attr("type", "button").addClass("marker").addClass(o.clsMarker);
            var hint = $("<div>").addClass("hint").addClass(o.hintPosition + "-side").addClass(o.clsHint);
            var i;

            if (o.size > 0) {
                if (o.vertical === true) {
                    slider.outerHeight(o.size);
                } else {
                    slider.outerWidth(o.size);
                }
            }

            if (o.vertical === true) {
                slider.addClass("vertical-slider");
            }

            if (prev.length === 0) {
                parent.prepend(slider);
            } else {
                slider.insertAfter(prev);
            }

            if (o.hintAlways === true) {
                hint.css({
                    display: "block"
                }).addClass("permanent-hint");
            }

            element.appendTo(slider);
            backside.appendTo(slider);
            complete.appendTo(slider);
            buffer.appendTo(slider);
            marker.appendTo(slider);
            hint.appendTo(marker);

            if (o.showMinMax === true) {
                var min_max_wrapper = $("<div>").addClass("slider-min-max").addClass(o.clsMinMax);
                $("<span>").addClass("slider-text-min").addClass(o.clsMin).html(o.min).appendTo(min_max_wrapper);
                $("<span>").addClass("slider-text-max").addClass(o.clsMax).html(o.max).appendTo(min_max_wrapper);
                if (o.minMaxPosition === Metro.position.TOP) {
                    min_max_wrapper.insertBefore(slider);
                } else {
                    min_max_wrapper.insertAfter(slider);
                }
            }

            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    slider.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            this.slider = slider;
        },

        _createEvents: function(){
            var that = this, slider = this.slider, o = this.options;
            var marker = slider.find(".marker");
            var hint = slider.find(".hint");

            marker.on(Metro.events.startAll, function(){
                if (o.hint === true && o.hintAlways !== true) {
                    hint.fadeIn(300);
                }

                $(document).on(Metro.events.moveAll, function(e){
                    if (e.cancelable) e.preventDefault();
                    that._move(e);

                    that._fireEvent("move", {
                        val: that.value,
                        percent: that.percent
                    });

                }, {ns: that.id, passive: false});

                $(document).on(Metro.events.stopAll, function(){
                    $(document).off(Metro.events.moveAll, {ns: that.id});
                    $(document).off(Metro.events.stopAll, {ns: that.id});

                    if (o.hintAlways !== true) {
                        hint.fadeOut(300);
                    }

                    that._fireEvent("stop", {
                        val: that.value,
                        percent: that.percent
                    });
                }, {ns: that.id});

                that._fireEvent("start", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.focus, function(){
                that._fireEvent("focus", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.blur, function(){
                that._fireEvent("blur", {
                    val: that.value,
                    percent: that.percent
                });
            });

            marker.on(Metro.events.keydown, function(e){

                var key = e.keyCode ? e.keyCode : e.which;

                if ([37,38,39,40].indexOf(key) === -1) {
                    return;
                }

                var step = o.accuracy === 0 ? 1 : o.accuracy;

                if (that.keyInterval) {
                    return ;
                }
                that.keyInterval = setInterval(function(){

                    var val = that.value;

                    if (e.keyCode === 37 || e.keyCode === 40) { // left, down
                        if (val - step < o.min) {
                            val = o.min;
                        } else {
                            val -= step;
                        }
                    }

                    if (e.keyCode === 38 || e.keyCode === 39) { // right, up
                        if (val + step > o.max) {
                            val = o.max;
                        } else {
                            val += step;
                        }
                    }

                    that.value = that._correct(val);
                    that.percent = that._convert(that.value, 'val2prc');
                    that.pixel = that._convert(that.percent, 'prc2pix');

                    that._redraw();
                }, 100);

                e.preventDefault();
            });

            marker.on(Metro.events.keyup, function(){
                clearInterval(that.keyInterval);
                that.keyInterval = false;
            });

            slider.on(Metro.events.click, function(e){
                that._move(e);

                that._fireEvent("slider-click", {
                    val: that.value,
                    percent: that.percent
                });

                that._fireEvent("stop", {
                    val: that.value,
                    percent: that.percent
                });
            });

            $(window).on(Metro.events.resize,function(){
                that.val(that.value);
                that.buff(that.buffer);
            }, {ns: that.id});
        },

        _convert: function(v, how){
            var slider = this.slider, o = this.options;
            var length = (o.vertical === true ? slider.outerHeight() : slider.outerWidth()) - slider.find(".marker").outerWidth();
            switch (how) {
                case "pix2prc": return ( v * 100 / length );
                case "pix2val": return ( this._convert(v, 'pix2prc') * ((o.max - o.min) / 100) + o.min );
                case "val2prc": return ( (v - o.min)/( (o.max - o.min) / 100 )  );
                case "prc2pix": return ( v / ( 100 / length ));
                case "val2pix": return ( this._convert(this._convert(v, 'val2prc'), 'prc2pix') );
            }

            return 0;
        },

        _correct: function(value){
            var res = value;
            var accuracy  = this.options.accuracy;
            var min = this.options.min, max = this.options.max;

            if (accuracy === 0 || isNaN(accuracy)) {
                return res;
            }

            res = Math.round(value/accuracy)*accuracy;

            if (res < min) {
                res = min;
            }

            if (res > max) {
                res = max;
            }

            return res.toFixed(Utils.decCount(accuracy));
        },

        _move: function(e){
            var slider = this.slider, o = this.options;
            var offset = slider.offset(),
                marker_size = slider.find(".marker").outerWidth(),
                length = o.vertical === true ? slider.outerHeight() : slider.outerWidth(),
                cPos, cPix, cStart = 0, cStop = length - marker_size;

            cPos = o.vertical === true ? Utils.pageXY(e).y - offset.top : Utils.pageXY(e).x - offset.left;
            cPix = o.vertical === true ? length - cPos - marker_size / 2 : cPos - marker_size / 2;

            if (cPix < cStart || cPix > cStop) {
                return ;
            }

            this.value = this._correct(this._convert(cPix, 'pix2val'));
            this.percent = this._convert(this.value, 'val2prc');
            this.pixel = this._convert(this.percent, 'prc2pix');

            this._redraw();
        },

        _hint: function(){
            var o = this.options, slider = this.slider, hint = slider.find(".hint");
            var value = +this.value || 0;
            var percent = +this.percent || 0;

            if (o.roundValue) {
                value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o.accuracy));
                percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o.accuracy));
            }

            hint.text(o.hintMask.replace("$1", value).replace("$2", percent));
        },

        _value: function(){
            var element = this.element, o = this.options;
            var value = o.returnType === 'value' ? this.value : this.percent;
            var percent = this.percent;
            var buffer = this.buffer;

            if (o.roundValue) {
                value = (Utils.isValue(value) ? +value : 0).toFixed(Utils.decCount(o.accuracy));
                percent = (Utils.isValue(percent) ? +percent : 0).toFixed(Utils.decCount(o.accuracy));
                buffer = (Utils.isValue(buffer) ? +buffer : 0).toFixed(Utils.decCount(o.accuracy));
            }

            if (element[0].tagName === "INPUT") {
                element.val(value);
            }

            if (o.target !== null) {
                var target = $(o.target);
                if (target.length !== 0) {

                    $.each(target, function(){
                        var t = $(this);
                        if (this.tagName === "INPUT") {
                            t.val(value);
                        } else {
                            t.text(value);
                        }
                        t.trigger("change");
                    });
                }
            }

            this._fireEvent("change-value", {
                val: value
            });

            this._fireEvent("change", {
                val: value,
                percent: percent,
                buffer: buffer
            });
        },

        _marker: function(){
            var slider = this.slider, o = this.options;
            var marker = slider.find(".marker"), complete = slider.find(".complete");
            var length = o.vertical === true ? slider.outerHeight() : slider.outerWidth();
            var marker_size = parseInt(Utils.getStyleOne(marker, "width"));
            var slider_visible = Utils.isVisible(slider);

            if (slider_visible) {
                marker.css({
                    'margin-top': 0,
                    'margin-left': 0
                });
            }

            if (o.vertical === true) {
                if (slider_visible) {
                    marker.css('top', length - this.pixel);
                } else {
                    marker.css('top', (100 - this.percent) + "%");
                    marker.css('margin-top', marker_size / 2);
                }
                complete.css('height', this.percent+"%");
            } else {
                if (slider_visible) {
                    marker.css('left', this.pixel);
                } else {
                    marker.css('left', this.percent + "%");
                    marker.css('margin-left', this.percent === 0 ? 0 : -1 * marker_size / 2);
                }
                complete.css('width', this.percent+"%");
            }
        },

        _redraw: function(){
            this._marker();
            this._value();
            this._hint();
        },

        _buffer: function(){
            var element = this.element, o = this.options;
            var buffer = this.slider.find(".buffer");

            if (o.vertical === true) {
                buffer.css("height", this.buffer + "%");
            } else {
                buffer.css("width", this.buffer + "%");
            }

            this._fireEvent("change-buffer", {
                val: this.buffer
            });

            this._fireEvent("change", {
                val: element.val(),
                percent: this.percent,
                buffer: this.buffer
            });
        },

        val: function(v){
            var o = this.options;

            if (v === undefined || isNaN(v)) {
                return this.value;
            }

            if (v < o.min) {
                v = o.min;
            }

            if (v > o.max) {
                v = o.max;
            }

            this.value = this._correct(v);
            this.percent = this._convert(this.value, 'val2prc');
            this.pixel = this._convert(this.percent, 'prc2pix');

            this._redraw();
        },

        buff: function(v){
            var slider = this.slider;
            var buffer = slider.find(".buffer");

            if (v === undefined || isNaN(v)) {
                return this.buffer;
            }

            if (buffer.length === 0) {
                return false;
            }

            v = parseInt(v);

            if (v > 100) {
                v = 100;
            }

            if (v < 0) {
                v = 0;
            }

            this.buffer = v;
            this._buffer();
        },

        changeValue: function(){
            var element = this.element, o = this.options;
            var val = element.attr("data-value");
            if (val < o.min) {
                val = o.min
            }
            if (val > o.max) {
                val = o.max
            }
            this.val(val);
        },

        changeBuffer: function(){
            var element = this.element;
            var val = parseInt(element.attr("data-buffer"));
            if (val < 0) {
                val = 0
            }
            if (val > 100) {
                val = 100
            }
            this.buff(val);
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-value": this.changeValue(); break;
                case "data-buffer": this.changeBuffer(); break;
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, slider = this.slider;
            var marker = slider.find(".marker");

            marker.off(Metro.events.startAll);
            marker.off(Metro.events.focus);
            marker.off(Metro.events.blur);
            marker.off(Metro.events.keydown);
            marker.off(Metro.events.keyup);
            slider.off(Metro.events.click);
            $(window).off(Metro.events.resize, {ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SorterDefaultConfig = {
        sorterDeferred: 0,
        thousandSeparator: ",",
        decimalSeparator: ",",
        sortTarget: null,
        sortSource: null,
        sortDir: "asc",
        sortStart: true,
        saveInitial: true,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSorterCreate: Metro.noop
    };

    Metro.sorterSetup = function (options) {
        SorterDefaultConfig = $.extend({}, SorterDefaultConfig, options);
    };

    if (typeof window["metroSorterSetup"] !== undefined) {
        Metro.sorterSetup(window["metroSorterSetup"]);
    }

    Metro.Component('sorter', {
        init: function( options, elem ) {
            this._super(elem, options, SorterDefaultConfig, {
                initial: []
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();

            this._fireEvent("sorter-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;

            if (o.sortTarget === null) {
                o.sortTarget = element.children()[0].tagName;
            }

            this.initial = element.find(o.sortTarget).get();

            if (o.sortStart === true) {
                this.sort(o.sortDir);
            }
        },

        _getItemContent: function(item){
            var o = this.options;
            var data, inset, i, format;

            if (Utils.isValue(o.sortSource)) {
                data = "";
                inset = item.getElementsByClassName(o.sortSource);

                if (inset.length > 0) for (i = 0; i < inset.length; i++) {
                    data += inset[i].textContent;
                }
                format = inset[0].dataset.format;
            } else {
                data = item.textContent;
                format = item.dataset.format;
            }

            data = (""+data).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(format)) {

                if (['number', 'int', 'float', 'money'].indexOf(format) !== -1 && (o.thousandSeparator !== "," || o.decimalSeparator !== "." )) {
                    data = Utils.parseNumber(data, o.thousandSeparator, o.decimalSeparator);
                }

                switch (format) {
                    case "date": data = Utils.isDate(data) ? new Date(data) : ""; break;
                    case "number": data = Number(data); break;
                    case "int": data = parseInt(data); break;
                    case "float": data = parseFloat(data); break;
                    case "money": data = Utils.parseMoney(data); break;
                    case "card": data = Utils.parseCard(data); break;
                    case "phone": data = Utils.parsePhone(data); break;
                }
            }

            return data;
        },

        sort: function(dir){
            var that = this, element = this.element, o = this.options;
            var items;
            var id = Utils.elementId("temp");
            var prev;

            if (dir !== undefined) {
                o.sortDir = dir;
            }

            items = element.find(o.sortTarget).get();

            if (items.length === 0) {
                return ;
            }

            prev = $("<div>").attr("id", id).insertBefore($(element.find(o.sortTarget)[0]));

            this._fireEvent("sort-start", {
                items: items
            });

            items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2 ) {
                    result = -1;
                }

                if (c1 > c2 ) {
                    result = 1;
                }

                if (result !== 0) {
                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            if (o.sortDir === "desc") {
                items.reverse();
            }

            element.find(o.sortTarget).remove();

            $.each(items, function(){
                var $this = $(this);
                $this.insertAfter(prev);
                prev = $this;
            });

            $("#"+id).remove();

            this._fireEvent("sort-stop", {
                items: items
            });
        },

        reset: function(){
            var element = this.element, o = this.options;
            var items;
            var id = Utils.elementId('sorter');
            var prev;

            items = this.initial;

            if (items.length === 0) {
                return ;
            }

            prev = $("<div>").attr("id", id).insertBefore($(element.find(o.sortTarget)[0]));

            element.find(o.sortTarget).remove();

            $.each(items, function(){
                var $this = $(this);
                $this.insertAfter(prev);
                prev = $this;
            });

            $("#"+id).remove();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeSortDir = function() {
                var dir = element.attr("data-sort-dir").trim();
                if (dir === "") return;
                o.sortDir = dir;
                that.sort();
            };

            var changeSortContent = function(){
                var content = element.attr("data-sort-content").trim();
                if (content === "") return ;
                o.sortContent = content;
                that.sort();
            };

            switch (attributeName) {
                case "data-sort-dir": changeSortDir(); break;
                case "data-sort-content": changeSortContent(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['sorter'] = {
        create: function(el, op){
            return Utils.$()(el).sorter(op);
        },

        isSorter: function(el){
            return Utils.isMetroObject(el, "sorter");
        },

        sort: function(el, dir){
            if (!this.isSorter(el)) {
                return false;
            }
            if (dir === undefined) {
                dir = "asc";
            }
            Metro.getPlugin(el, "sorter").sort(dir);
        },

        reset: function(el){
            if (!this.isSorter(el)) {
                return false;
            }
            Metro.getPlugin(el, "sorter").reset();
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SpinnerDefaultConfig = {
        spinnerDeferred: 0,
        label: "",
        step: 1,
        plusIcon: "<span class='default-icon-plus'></span>",
        minusIcon: "<span class='default-icon-minus'></span>",
        buttonsPosition: "default",
        defaultValue: 0,
        minValue: null,
        maxValue: null,
        fixed: 0,
        repeatThreshold: 1000,
        hideCursor: false,
        clsSpinner: "",
        clsSpinnerInput: "",
        clsSpinnerButton: "",
        clsSpinnerButtonPlus: "",
        clsSpinnerButtonMinus: "",
        clsLabel: "",
        onBeforeChange: Metro.noop_true,
        onChange: Metro.noop,
        onPlusClick: Metro.noop,
        onMinusClick: Metro.noop,
        onArrowUp: Metro.noop,
        onArrowDown: Metro.noop,
        onButtonClick: Metro.noop,
        onArrowClick: Metro.noop,
        onSpinnerCreate: Metro.noop
    };

    Metro.spinnerSetup = function (options) {
        SpinnerDefaultConfig = $.extend({}, SpinnerDefaultConfig, options);
    };

    if (typeof window["metroSpinnerSetup"] !== undefined) {
        Metro.spinnerSetup(window["metroSpinnerSetup"]);
    }

    Metro.Component('spinner', {
        init: function( options, elem ) {
            this._super(elem, options, SpinnerDefaultConfig, {
                repeat_timer: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("spinner-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var spinner = $("<div>").addClass("spinner").addClass("buttons-"+o.buttonsPosition).addClass(element[0].className).addClass(o.clsSpinner);
            var button_plus = $("<button>").attr("type", "button").addClass("button spinner-button spinner-button-plus").addClass(o.clsSpinnerButton + " " + o.clsSpinnerButtonPlus).html(o.plusIcon);
            var button_minus = $("<button>").attr("type", "button").addClass("button spinner-button spinner-button-minus").addClass(o.clsSpinnerButton + " " + o.clsSpinnerButtonMinus).html(o.minusIcon);
            var init_value = element.val().trim();

            if (!Utils.isValue(init_value)) {
                element.val(0);
            }

            element[0].className = '';

            spinner.insertBefore(element);
            element.appendTo(spinner).addClass(o.clsSpinnerInput);

            element.addClass("original-input");

            button_plus.appendTo(spinner);
            button_minus.appendTo(spinner);

            if (o.hideCursor === true) {
                spinner.addClass("hide-cursor");
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(spinner);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (o.disabled === true || element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var spinner = element.closest(".spinner");
            var spinner_buttons = spinner.find(".spinner-button");
            var value;

            var spinnerButtonClick = function(plus, threshold){
                var events = [plus ? "plus-click" : "minus-click", plus ? "arrow-up" : "arrow-down", "button-click", "arrow-click"];
                var curr = +element.val();
                var val = +element.val();
                var step = +o.step;

                if (plus) {
                    val += step;
                } else {
                    val -= step;
                }

                that._setValue(val.toFixed(o.fixed), true);

                that._fireEvents(events, {
                    curr: curr,
                    val: val,
                    elementVal: element.val(),
                    button: plus ? "plus" : "minus"
                });

                setTimeout(function(){
                    if (that.repeat_timer) {
                        spinnerButtonClick(plus, 100);
                    }
                }, threshold);
            };

            spinner.on(Metro.events.click, function(e){
                $(".focused").removeClass("focused");
                spinner.addClass("focused");

                e.preventDefault();
                e.stopPropagation();
            });

            spinner_buttons.on(Metro.events.startAll, function(e){
                var plus = $(this).closest(".spinner-button").hasClass("spinner-button-plus");

                if (that.repeat_timer) return ;

                that.repeat_timer = true;
                spinnerButtonClick(plus, o.repeatThreshold);

                e.preventDefault();
            });

            spinner_buttons.on(Metro.events.stopAll, function(){
                that.repeat_timer = false;
            });

            element.on(Metro.events.keydown, function(e){
                if (e.keyCode === Metro.keyCode.UP_ARROW || e.keyCode === Metro.keyCode.DOWN_ARROW) {

                    if (that.repeat_timer) return ;

                    that.repeat_timer = true;
                    spinnerButtonClick(e.keyCode === Metro.keyCode.UP_ARROW, o.repeatThreshold);

                } else {
                    var key = e.key;
                    if (key === "Backspace" || key === "Delete" || key === "ArrowLeft" || key === "ArrowRight" ) {
                        //
                    } else
                    if (isNaN(key) || parseInt(key) < 0 && parseInt(key) > 9) {
                        e.preventDefault();
                    }

                    value = parseInt(this.value);
                }
            });

            element.on(Metro.events.keyup, function(){
                var val = parseInt(this.value);
                if ((o.minValue && val < o.minValue) || (o.maxValue && val > o.maxValue)) {
                    this.value = value;
                }
            });

            spinner.on(Metro.events.keyup, function(){
                that.repeat_timer = false;
            });
        },

        _setValue: function(val, trigger_change){
            var element = this.element, o = this.options;

            if (Utils.exec(o.onBeforeChange, [val], element[0]) !== true) {
                return ;
            }

            if (Utils.isValue(o.maxValue) && val > Number(o.maxValue)) {
                val =  Number(o.maxValue);
            }

            if (Utils.isValue(o.minValue) && val < Number(o.minValue)) {
                val =  Number(o.minValue);
            }

            element.val(val);

            this._fireEvent("change", {val: val}, false, true);

            if (trigger_change === true) {
                element.fire("change", {
                    val: val
                });
            }
        },

        val: function(val){
            var that = this, element = this.element, o = this.options;
            if (!Utils.isValue(val)) {
                return element.val();
            }

            that._setValue(val.toFixed(o.fixed), true);
        },

        toDefault: function(){
            var o = this.options;
            var val = Utils.isValue(o.defaultValue) ? Number(o.defaultValue) : 0;
            this._setValue(val.toFixed(o.fixed), true);

            this._fireEvent("change", {
                val: val
            });
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;

            var changeValue = function(){
                var val = element.attr('value').trim();
                if (Utils.isValue(val)) {
                    that._setValue(Number(val), false);
                }
            };

            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
                case 'value': changeValue(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var spinner = element.closest(".spinner");
            var spinner_buttons = spinner.find(".spinner-button");

            spinner.off(Metro.events.click);
            spinner_buttons.off(Metro.events.start);
            spinner_buttons.off(Metro.events.stop);
            element.off(Metro.events.keydown);
            spinner.off(Metro.events.keyup);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $(".spinner").removeClass("focused");
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var Storage = Metro.storage;
    var SplitterDefaultConfig = {
        splitterDeferred: 0,
        splitMode: "horizontal", // horizontal or vertical
        splitSizes: null,
        gutterSize: 4,
        minSizes: null,
        children: "*",
        gutterClick: "expand", // TODO expand or collapse
        saveState: false,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResizeSplit: Metro.noop,
        onResizeWindow: Metro.noop,
        onSplitterCreate: Metro.noop
    };

    Metro.splitterSetup = function (options) {
        SplitterDefaultConfig = $.extend({}, SplitterDefaultConfig, options);
    };

    if (typeof window["metroSplitterSetup"] !== undefined) {
        Metro.splitterSetup(window["metroSplitterSetup"]);
    }

    Metro.Component('splitter', {
        init: function( options, elem ) {
            this._super(elem, options, SplitterDefaultConfig, {
                storage: Utils.isValue(Storage) ? Storage : null,
                storageKey: "SPLITTER:",
                id: Utils.elementId("splitter")
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("splitter-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var children = element.children(o.children).addClass("split-block");
            var i, children_sizes = [];
            var resizeProp = o.splitMode === "horizontal" ? "width" : "height";

            element.addClass("splitter");
            if (o.splitMode.toLowerCase() === "vertical") {
                element.addClass("vertical");
            }

            for (i = 0; i < children.length - 1; i++) {
                $("<div>").addClass("gutter").css(resizeProp, o.gutterSize).insertAfter($(children[i]));
            }

            this._setSize();

            if (Utils.isValue(o.minSizes)) {
                if ((""+o.minSizes).includes(",")) {
                    children_sizes = o.minSizes.toArray();
                    for (i = 0; i < children_sizes.length; i++) {
                        $(children[i]).data("min-size", children_sizes[i]);
                        children[i].style.setProperty('min-'+resizeProp, (""+children_sizes[i]).includes("%") ? children_sizes[i] : (""+children_sizes[i]).replace("px", "")+"px", 'important');
                    }
                } else {
                    $.each(children, function(){
                        this.style.setProperty('min-'+resizeProp, (""+o.minSizes).includes("%") ? o.minSizes : (""+o.minSizes).replace("px", "")+"px", 'important');
                    });
                }
            }

            if (o.saveState && this.storage !== null) {
                this._getSize();
            }
        },

        _setSize: function(){
            var element = this.element, o = this.options;
            var gutters, children_sizes, i;
            var children = element.children(".split-block");

            gutters = element.children(".gutter");

            if (!Utils.isValue(o.splitSizes)) {
                children.css({
                    flexBasis: "calc("+(100/children.length)+"% - "+(gutters.length * o.gutterSize)+"px)"
                })
            } else {
                children_sizes = o.splitSizes.toArray();
                for(i = 0; i < children_sizes.length; i++) {
                    $(children[i]).css({
                        flexBasis: "calc("+children_sizes[i]+"% - "+(gutters.length * o.gutterSize)+"px)"
                    });
                }
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var gutters = element.children(".gutter");

            gutters.on(Metro.events.startAll, function(e){
                var w = o.splitMode === "horizontal" ? element.width() : element.height();
                var gutter = $(this);
                var prev_block = gutter.prev(".split-block");
                var next_block = gutter.next(".split-block");
                var prev_block_size = 100 * (o.splitMode === "horizontal" ? prev_block.outerWidth(true) : prev_block.outerHeight(true)) / w;
                var next_block_size = 100 * (o.splitMode === "horizontal" ? next_block.outerWidth(true) : next_block.outerHeight(true)) / w;
                var start_pos = Utils.getCursorPosition(element[0], e);

                gutter.addClass("active");

                prev_block.addClass("stop-pointer");
                next_block.addClass("stop-pointer");

                that._fireEvent("resize-start", {
                    pos: start_pos,
                    gutter: gutter[0],
                    prevBlock: prev_block[0],
                    nextBlock: next_block[0]
                });

                $(window).on(Metro.events.moveAll, function(e){
                    var pos = Utils.getCursorPosition(element[0], e);
                    var new_pos;

                    if (o.splitMode === "horizontal") {
                        new_pos = (pos.x * 100 / w) - (start_pos.x * 100 / w);

                    } else {
                        new_pos = (pos.y * 100 / w) - (start_pos.y * 100 / w);
                    }

                    prev_block.css("flex-basis", "calc(" + (prev_block_size + new_pos) + "% - "+(gutters.length * o.gutterSize)+"px)");
                    next_block.css("flex-basis", "calc(" + (next_block_size - new_pos) + "% - "+(gutters.length * o.gutterSize)+"px)");

                    that._fireEvent("resize-split", {
                        pos: pos,
                        gutter: gutter[0],
                        prevBlock: prev_block[0],
                        nextBlock: next_block[0]
                    });

                }, {ns: that.id});

                $(window).on(Metro.events.stopAll, function(e){
                    var cur_pos;

                    prev_block.removeClass("stop-pointer");
                    next_block.removeClass("stop-pointer");

                    that._saveSize();

                    gutter.removeClass("active");

                    $(window).off(Metro.events.moveAll,{ns: that.id});
                    $(window).off(Metro.events.stopAll,{ns: that.id});

                    cur_pos = Utils.getCursorPosition(element[0], e);

                    that._fireEvent("resize-stop", {
                        pos: cur_pos,
                        gutter: gutter[0],
                        prevBlock: prev_block[0],
                        nextBlock: next_block[0]
                    });

                }, {ns: that.id})
            });

            $(window).on(Metro.events.resize, function(){
                var gutter = element.children(".gutter");
                var prev_block = gutter.prev(".split-block");
                var next_block = gutter.next(".split-block");

                that._fireEvent("resize-window", {
                    prevBlock: prev_block[0],
                    nextBlock: next_block[0]
                });

            }, {ns: that.id});
        },

        _saveSize: function(){
            var element = this.element, o = this.options;
            var storage = this.storage, itemsSize = [];
            var id = element.attr("id") || this.id;

            if (o.saveState === true && storage !== null) {

                $.each(element.children(".split-block"), function(){
                    var item = $(this);
                    itemsSize.push(item.css("flex-basis"));
                });

                if (storage)
                    storage.setItem(this.storageKey + id, itemsSize);
            }

        },

        _getSize: function(){
            var element = this.element, o = this.options;
            var storage = this.storage, itemsSize = [];
            var id = element.attr("id") || this.id;

            if (o.saveState === true && storage !== null) {

                itemsSize = storage.getItem(this.storageKey + id);

                $.each(element.children(".split-block"), function(i, v){
                    var item = $(v);
                    if (Utils.isValue(itemsSize) && Utils.isValue(itemsSize[i])) item.css("flex-basis", itemsSize[i]);
                });
            }
        },

        size: function(size){
            var that = this, o = this.options;
            if (Utils.isValue(size)) {
                o.splitSizes = size;
                that._setSize();
            }
            return this;
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element;

            function changeSize(){
                var size = element.attr("data-split-sizes");
                that.size(size);
            }

            if (attributeName === 'data-split-sizes') {
                changeSize();
            }
        },

        destroy: function(){
            var element = this.element;
            var gutters = element.children(".gutter");
            gutters.off(Metro.events.start);
            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var StepperDefaultConfig = {
        stepperDeferred: 0,
        view: Metro.stepperView.SQUARE, // square, cycle, diamond
        steps: 3,
        step: 1,
        stepClick: false,
        clsStepper: "",
        clsStep: "",
        clsComplete: "",
        clsCurrent: "",
        onStep: Metro.noop,
        onStepClick: Metro.noop,
        onStepperCreate: Metro.noop
    };

    Metro.stepperSetup = function (options) {
        StepperDefaultConfig = $.extend({}, StepperDefaultConfig, options);
    };

    if (typeof window["metroStepperSetup"] !== undefined) {
        Metro.stepperSetup(window["metroStepperSetup"]);
    }

    Metro.Component('stepper', {
        init: function( options, elem ) {
            this._super(elem, options, StepperDefaultConfig, {
                current: 0
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (o.step <= 0) {
                o.step = 1;
            }

            this._createStepper();
            this._createEvents();

            this._fireEvent("stepper-create", {
                element: element
            });
        },

        _createStepper: function(){
            var element = this.element, o = this.options;
            var i;

            element.addClass("stepper").addClass(o.view).addClass(o.clsStepper);

            for(i = 1; i <= o.steps; i++) {
                $("<span>").addClass("step").addClass(o.clsStep).data("step", i).html("<span>"+i+"</span>").appendTo(element);
            }

            this.current = 1;
            this.toStep(o.step);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, ".step", function(){
                var step = $(this).data("step");
                if (o.stepClick === true) {
                    that.toStep(step);

                    that._fireEvent("step-click", {
                        step: step
                    });
                }
            });
        },

        next: function(){
            var element = this.element;
            var steps = element.find(".step");

            if (this.current + 1 > steps.length) {
                return ;
            }

            this.current++;

            this.toStep(this.current);
        },

        prev: function(){
            if (this.current - 1 === 0) {
                return ;
            }

            this.current--;

            this.toStep(this.current);
        },

        last: function(){
            var element = this.element;

            this.toStep(element.find(".step").length);
        },

        first: function(){
            this.toStep(1);
        },

        toStep: function(step){
            var element = this.element, o = this.options;
            var target = $(element.find(".step").get(step - 1));
            var prevStep = this.current;

            if (target.length === 0) {
                return ;
            }

            this.current = step;

            element.find(".step")
                .removeClass("complete current")
                .removeClass(o.clsCurrent)
                .removeClass(o.clsComplete);

            target.addClass("current").addClass(o.clsCurrent);
            target.prevAll().addClass("complete").addClass(o.clsComplete);

            this._fireEvent("step", {
                step: this.current,
                prev: prevStep
            });

        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            element.off(Metro.events.click, ".step");
            return element;
        }
    });
}(Metro, m4q));

(function(Metro) {
    'use strict';
    var Utils = Metro.utils;

    var MetroStorage = function(type){
        return new MetroStorage.init(type);
    };

    MetroStorage.prototype = {
        setKey: function(key){
            this.key = key
        },

        getKey: function(){
            return this.key;
        },

        setItem: function(key, value){
            this.storage.setItem(this.key + ":" + key, JSON.stringify(value));
        },

        getItem: function(key, default_value, reviver){
            var result, value;

            value = this.storage.getItem(this.key + ":" + key);

            try {
                result = JSON.parse(value, reviver);
            } catch (e) {
                result = null;
            }
            return Utils.nvl(result, default_value);
        },

        getItemPart: function(key, sub_key, default_value, reviver){
            var i;
            var val = this.getItem(key, default_value, reviver);

            sub_key = sub_key.split("->");
            for(i = 0; i < sub_key.length; i++) {
                val = val[sub_key[i]];
            }
            return val;
        },

        delItem: function(key){
            this.storage.removeItem(this.key + ":" + key)
        },

        size: function(unit){
            var divider;
            switch (unit) {
                case 'm':
                case 'M': {
                    divider = 1024 * 1024;
                    break;
                }
                case 'k':
                case 'K': {
                    divider = 1024;
                    break;
                }
                default: divider = 1;
            }
            return JSON.stringify(this.storage).length / divider;
        }
    };

    MetroStorage.init = function(type){

        this.key = "";
        this.storage = type ? type : window.localStorage;

        return this;
    };

    MetroStorage.init.prototype = MetroStorage.prototype;

    Metro.storage = MetroStorage(window.localStorage);
    Metro.session = MetroStorage(window.sessionStorage);
}(Metro));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var StreamerDefaultConfig = {
        streamerDeferred: 0,
        wheel: true,
        wheelStep: 20,
        duration: METRO_ANIMATION_DURATION,
        defaultClosedIcon: "",
        defaultOpenIcon: "",
        changeUri: true,
        encodeLink: true,
        closed: false,
        chromeNotice: false,
        startFrom: null,
        slideToStart: true,
        startSlideSleep: 1000,
        source: null,
        data: null,
        eventClick: "select",
        selectGlobal: true,
        streamSelect: false,
        excludeSelectElement: null,
        excludeClickElement: null,
        excludeElement: null,
        excludeSelectClass: "",
        excludeClickClass: "",
        excludeClass: "",

        onDataLoad: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataLoadError: Metro.noop,

        onDrawEvent: Metro.noop,
        onDrawGlobalEvent: Metro.noop,
        onDrawStream: Metro.noop,

        onStreamClick: Metro.noop,
        onStreamSelect: Metro.noop,
        onEventClick: Metro.noop,
        onEventSelect: Metro.noop,
        onEventsScroll: Metro.noop,
        onStreamerCreate: Metro.noop
    };

    Metro.streamerSetup = function (options) {
        StreamerDefaultConfig = $.extend({}, StreamerDefaultConfig, options);
    };

    if (typeof window["metroStreamerSetup"] !== undefined) {
        Metro.streamerSetup(window["metroStreamerSetup"]);
    }

    Metro.Component('streamer', {
        init: function( options, elem ) {
            this._super(elem, options, StreamerDefaultConfig, {
                data: null,
                scroll: 0,
                scrollDir: "left",
                events: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            element.addClass("streamer");

            if (element.attr("id") === undefined) {
                element.attr("id", Utils.elementId("streamer"));
            }

            if (o.source === null && o.data === null) {
                return false;
            }

            $("<div>").addClass("streams").appendTo(element);
            $("<div>").addClass("events-area").appendTo(element);

            if (o.source !== null) {

                this._fireEvent("data-load", {
                    source: o.source
                });

                this._loadSource();
            } else {
                this.data = o.data;
                this.build();
            }

            if (o.chromeNotice === true && Utils.detectChrome() === true && $.touchable === false) {
                $("<p>").addClass("text-small text-muted").html("*) In Chrome browser please press and hold Shift and turn the mouse wheel.").insertAfter(element);
            }
        },

        _loadSource: function(){
            var that = this, o = this.options;

            fetch(o.source)
                .then(Metro.fetch.status)
                .then(Metro.fetch.json)
                .then(function(data){
                    that._fireEvent("data-loaded", {
                        source: o.source,
                        data: data
                    });

                    that.data = data;
                    that.build();
                })
                .catch(function (error) {
                    that._fireEvent("data-load-error", {
                        source: o.source,
                        error: error
                    });
                });
        },

        build: function(){
            var that = this, element = this.element, o = this.options, data = this.data;
            var streams = element.find(".streams").html("");
            var events_area = element.find(".events-area").html("");
            var fake_timeline;
            var timeline = $("<ul>").addClass("streamer-timeline").html("").appendTo(events_area);
            var streamer_events = $("<div>").addClass("streamer-events").appendTo(events_area);
            var event_group_main = $("<div>").addClass("event-group").appendTo(streamer_events);
            var StreamerIDS = Utils.getURIParameter(null, "StreamerIDS");

            if (StreamerIDS !== null && o.encodeLink === true) {
                StreamerIDS = atob(StreamerIDS);
            }

            var StreamerIDS_i = StreamerIDS ? StreamerIDS.split("|")[0] : null;
            var StreamerIDS_a = StreamerIDS ? StreamerIDS.split("|")[1].split(",") : [];

            if (data.actions !== undefined) {
                var actions = $("<div>").addClass("streamer-actions").appendTo(streams);
                $.each(data.actions, function(){
                    var item = this;
                    var button = $("<button>").addClass("streamer-action").addClass(item.cls).html(item.html);
                    if (item.onclick !== undefined) button.on(Metro.events.click, function(){
                        Utils.exec(item.onclick, [element]);
                    });
                    button.appendTo(actions);
                });
            }

            // Create timeline

            timeline.html("");

            if (data.timeline === undefined) {
                data.timeline = {
                    start: "09:00",
                    stop: "18:00",
                    step: 20
                }
            }

            var start = new Date(), stop = new Date();
            var start_time_array = data.timeline.start ? data.timeline.start.split(":") : [9,0];
            var stop_time_array = data.timeline.stop ? data.timeline.stop.split(":") : [18,0];
            var step = data.timeline.step ? parseInt(data.timeline.step) * 60 : 1200;

            start.setHours(start_time_array[0]);
            start.setMinutes(start_time_array[1]);
            start.setSeconds(0);

            stop.setHours(stop_time_array[0]);
            stop.setMinutes(stop_time_array[1]);
            stop.setSeconds(0);

            var i, t, h, v, m, j, fm, li, fli, fli_w;

            for (i = start.getTime()/1000; i <= stop.getTime()/1000; i += step) {
                t = new Date(i * 1000);
                h = t.getHours();
                m = t.getMinutes();
                v = Cake.lpad(h, 2, "0")+":"+Cake.lpad(m, 2, "0");

                li = $("<li>").data("time", v).addClass("js-time-point-" + v.replace(":", "-")).html("<em>"+v+"</em>").appendTo(timeline);

                fli_w = li.width() / parseInt(data.timeline.step);
                fake_timeline = $("<ul>").addClass("streamer-fake-timeline").html("").appendTo(li);
                for(j = 0; j < parseInt(data.timeline.step); j++) {
                    fm = m + j;
                    v = Cake.lpad(h, 2, "0")+":"+Cake.lpad(fm, 2, "0");
                    fli = $("<li>").data("time", v).addClass("js-fake-time-point-" + v.replace(":", "-")).html("|").appendTo(fake_timeline);
                    fli.css({
                        width: fli_w
                    })
                }
            }

            // -- End timeline creator

            if (data.streams !== undefined) {
                $.each(data.streams, function(stream_index){
                    var stream_height = 75, rows = 0;
                    var stream_item = this;
                    var stream = $("<div>").addClass("stream").addClass(this.cls).appendTo(streams);
                    stream
                        .addClass(stream_item.cls)
                        .data("one", false)
                        .data("data", stream_item.data);

                    $("<div>").addClass("stream-title").html(stream_item.title).appendTo(stream);
                    $("<div>").addClass("stream-secondary").html(stream_item.secondary).appendTo(stream);
                    $(stream_item.icon).addClass("stream-icon").appendTo(stream);

                    var bg = Metro.colors.toHEX(Utils.getStyleOne(stream, "background-color"));
                    var fg = Metro.colors.toHEX(Utils.getStyleOne(stream, "color"));

                    var stream_events = $("<div>").addClass("stream-events")
                        .data("background-color", bg)
                        .data("text-color", fg)
                        .appendTo(event_group_main);

                    if (stream_item.events !== undefined) {
                        $.each(stream_item.events, function(event_index){
                            var event_item = this;
                            var row = event_item.row === undefined ? 1 : parseInt(event_item.row);
                            var _icon;
                            var sid = stream_index+":"+event_index;
                            var custom_html = event_item.custom !== undefined ? event_item.custom : "";
                            var custom_html_open = event_item.custom_open !== undefined ? event_item.custom_open : "";
                            var custom_html_close = event_item.custom_close !== undefined ? event_item.custom_close : "";
                            var event;

                            if (event_item.skip !== undefined && Utils.bool(event_item.skip)) {
                                return ;
                            }

                            event = $("<div>")
                                .data("origin", event_item)
                                .data("sid", sid)
                                .data("data", event_item.data)
                                .data("time", event_item.time)
                                .data("target", event_item.target)
                                .addClass("stream-event")
                                .addClass("size-"+event_item.size+(["half", "one-third"].includes(event_item.size) ? "" : "x"))
                                .addClass(event_item.cls)
                                .appendTo(stream_events);


                            var time_point = timeline.find(".js-fake-time-point-"+this.time.replace(":", "-"));
                            var left = time_point.offset().left - stream_events.offset().left;
                            var top = 75 * (row - 1);

                            if (row > rows) {
                                rows = row;
                            }

                            event.css({
                                position: "absolute",
                                left: left,
                                top: top
                            });


                            if (Utils.isNull(event_item.html)) {

                                var slide = $("<div>").addClass("stream-event-slide").appendTo(event);
                                var slide_logo = $("<div>").addClass("slide-logo").appendTo(slide);
                                var slide_data = $("<div>").addClass("slide-data").appendTo(slide);

                                if (event_item.icon !== undefined) {
                                    if (Utils.isTag(event_item.icon)) {
                                        $(event_item.icon).addClass("icon").appendTo(slide_logo);
                                    } else {
                                        $("<img>").addClass("icon").attr("src", event_item.icon).appendTo(slide_logo);
                                    }
                                }

                                $("<span>").addClass("time").css({
                                    backgroundColor: bg,
                                    color: fg
                                }).html(event_item.time).appendTo(slide_logo);

                                $("<div>").addClass("title").html(event_item.title).appendTo(slide_data);
                                $("<div>").addClass("subtitle").html(event_item.subtitle).appendTo(slide_data);
                                $("<div>").addClass("desc").html(event_item.desc).appendTo(slide_data);

                                if (o.closed === false && (element.attr("id") === StreamerIDS_i && StreamerIDS_a.indexOf(sid) !== -1) || event_item.selected === true || parseInt(event_item.selected) === 1) {
                                    event.addClass("selected");
                                }

                                if (o.closed === true || event_item.closed === true || parseInt(event_item.closed) === 1) {
                                    _icon = event_item.closedIcon !== undefined ? Utils.isTag(event_item.closedIcon) ? event_item.closedIcon : "<span>" + event_item.closedIcon + "</span>" : Utils.isTag(o.defaultClosedIcon) ? o.defaultClosedIcon : "<span>" + o.defaultClosedIcon + "</span>";
                                    $(_icon).addClass("state-icon").addClass(event_item.clsClosedIcon).appendTo(slide);
                                    event
                                        .data("closed", true)
                                        .data("target", event_item.target);
                                    event.append(custom_html_open);
                                } else {
                                    _icon = event_item.openIcon !== undefined ? Utils.isTag(event_item.openIcon) ? event_item.openIcon : "<span>" + event_item.openIcon + "</span>" : Utils.isTag(o.defaultOpenIcon) ? o.defaultOpenIcon : "<span>" + o.defaultOpenIcon + "</span>";
                                    $(_icon).addClass("state-icon").addClass(event_item.clsOpenIcon).appendTo(slide);
                                    event
                                        .data("closed", false);
                                    event.append(custom_html_close);
                                }

                                event.append(custom_html);
                            } else {
                                event.html(event_item.html);
                            }

                            that._fireEvent("draw-event", {
                                event: event[0]
                            });

                        });

                        var last_child = stream_events.find(".stream-event").last();
                        if (last_child.length > 0) stream_events.outerWidth(last_child[0].offsetLeft + last_child.outerWidth());
                    }

                    stream_events.css({
                        height: stream_height * rows
                    });

                    element.find(".stream").eq(stream_events.index()).css({
                        height: stream_height * rows
                    });

                    that._fireEvent("draw-stream", {
                        stream: stream[0]
                    });

                });
            }

            if (data.global !== undefined) {
                var streamer_events_left = streamer_events.offset().left;
                $.each(['before', 'after'], function(){
                    var global_item = this;
                    if (data.global[global_item] !== undefined) {
                        $.each(data.global[global_item], function(){
                            var event_item = this;
                            var group = $("<div>").addClass("event-group").addClass("size-"+event_item.size+(["half", "one-third"].includes(event_item.size) ? "" : "x"));
                            var events = $("<div>").addClass("stream-events global-stream").appendTo(group);
                            var event = $("<div>").addClass("stream-event").appendTo(events);
                            event
                                .addClass("global-event")
                                .addClass(event_item.cls)
                                .data("time", event_item.time)
                                .data("origin", event_item)
                                .data("data", event_item.data);

                            $("<div>").addClass("event-title").html(event_item.title).appendTo(event);
                            $("<div>").addClass("event-subtitle").html(event_item.subtitle).appendTo(event);
                            $("<div>").addClass("event-html").html(event_item.html).appendTo(event);

                            var left, t = timeline.find(".js-fake-time-point-"+this.time.replace(":", "-"));

                            if (t.length > 0) {
                                // left = t[0].offsetLeft - streams.find(".stream").outerWidth();
                                left = t.offset().left - streamer_events_left;
                            }
                            group.css({
                                position: "absolute",
                                left: left,
                                height: "100%"
                            }).appendTo(streamer_events);

                            that._fireEvent("draw-global-event", {
                                event: event[0]
                            });

                        });
                    }
                });
            }

            element.data("stream", -1);
            element.find(".events-area").scrollLeft(0);

            this.events = element.find(".stream-event");

            this._createEvents();

            if (o.startFrom !== null && o.slideToStart === true) {
                setTimeout(function(){
                    that.slideTo(o.startFrom);
                }, o.startSlideSleep);
            }

            this._fireEvent("streamer-create");

            this._fireScroll();
        },

        _fireScroll: function(){
            var that = this, element = this.element;
            var scrollable = element.find(".events-area");
            var oldScroll = this.scroll;

            if (scrollable.length === 0) {
                return undefined;
            }

            this.scrollDir = this.scroll < scrollable[0].scrollLeft ? "left" : "right";
            this.scroll = scrollable[0].scrollLeft;

            this._fireEvent("events-scroll", {
                scrollLeft: scrollable[0].scrollLeft,
                oldScroll: oldScroll,
                scrollDir: that.scrollDir,
                events: $.toArray(this.events)
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            function disableScroll() {
                var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                window.onscroll = function() {
                    window.scrollTo(scrollLeft, scrollTop);
                };
            }

            function enableScroll() {
                window.onscroll = function() {};
            }

            element.off(Metro.events.click, ".stream-event").on(Metro.events.click, ".stream-event", function(e){
                var event = $(this);

                if (o.excludeClass !== "" && event.hasClass(o.excludeClass)) {
                    return ;
                }

                if (o.excludeElement !== null && $(e.target).is(o.excludeElement)) {
                    return ;
                }

                if (o.closed === false && event.data("closed") !== true && o.eventClick === 'select') {
                    if (o.excludeSelectClass !== "" && event.hasClass(o.excludeSelectClass)) {
                        /* eslint-disable-next-line */

                    } else {
                        if (o.excludeSelectElement !== null && $(e.target).is(o.excludeSelectElement)) {
                            /* eslint-disable-next-line */

                        } else {
                            if (event.hasClass("global-event")) {
                                if (o.selectGlobal === true) {
                                    event.toggleClass("selected");
                                }
                            } else {
                                event.toggleClass("selected");
                            }
                            if (o.changeUri === true) {
                                that._changeURI();
                            }

                            that._fireEvent("event-select", {
                                event: event[0],
                                selected: event.hasClass("selected")
                            });
                        }
                    }
                } else {
                    if (o.excludeClickClass !== "" && event.hasClass(o.excludeClickClass)) {
                        /* eslint-disable-next-line */

                    } else {

                        if (o.excludeClickElement !== null && $(e.target).is(o.excludeClickElement)) {
                            /* eslint-disable-next-line */

                        } else {

                            that._fireEvent("event-click", {
                                event: event[0]
                            });

                            if (o.closed === true || event.data("closed") === true) {
                                var target = event.data("target");
                                if (target) {
                                    window.location.href = target;
                                }
                            }

                        }
                    }
                }
            });

            element.off(Metro.events.click, ".stream").on(Metro.events.click, ".stream", function(){
                var stream = $(this);
                var index = stream.index();

                if (o.streamSelect === false) {
                    return;
                }

                if (element.data("stream") === index) {
                    element.find(".stream-event").removeClass("disabled");
                    element.data("stream", -1);
                } else {
                    element.data("stream", index);
                    element.find(".stream-event").addClass("disabled");
                    that.enableStream(stream);
                    that._fireEvent("stream-select", {
                        stream: stream
                    });
                }

                that._fireEvent("stream-click", {
                    stream: stream
                });
            });

            if (o.wheel === true) {
                element.find(".events-area")
                    .off(Metro.events.mousewheel)
                    .on(Metro.events.mousewheel, function(e) {

                    if (e.deltaY === undefined) {
                        return ;
                    }

                    var scroll, scrollable = $(this);
                    var dir = e.deltaY > 0 ? -1 : 1;
                    var step = o.wheelStep;


                    scroll = scrollable.scrollLeft() - ( dir * step);
                    scrollable.scrollLeft(scroll);

                });

                element.find(".events-area").off("mouseenter").on("mouseenter", function() {
                    disableScroll();
                });

                element.find(".events-area").off("mouseleave").on("mouseleave", function() {
                    enableScroll();
                });
            }

            element.find(".events-area").last().off("scroll").on("scroll", function(){
                that._fireScroll();
            });

            if ($.touchable === true) {
                element.off(Metro.events.click, ".stream").on(Metro.events.click, ".stream", function(){
                    var stream = $(this);
                    stream.toggleClass("focused");
                    $.each(element.find(".stream"), function () {
                        if ($(this).is(stream)) return ;
                        $(this).removeClass("focused");
                    })
                })
            }
        },

        _changeURI: function(){
            var link = this.getLink();
            history.pushState({}, document.title, link);
        },

        slideTo: function(time){
            var element = this.element, o = this.options;
            var target;
            if (time === undefined) {
                target = $(element.find(".streamer-timeline li")[0]);
            } else {
                target = $(element.find(".streamer-timeline .js-time-point-" + time.replace(":", "-"))[0]);
            }

            element
                .find(".events-area")
                .animate({
                    draw: {
                        scrollLeft: target[0].offsetLeft - element.find(".streams .stream").outerWidth()
                    },
                    dur: o.duration
                });
        },

        enableStream: function(stream){
            var element = this.element;
            var index = stream.index()-1;
            stream.removeClass("disabled").data("streamDisabled", false);
            element.find(".stream-events").eq(index).find(".stream-event").removeClass("disabled");
        },

        disableStream: function(stream){
            var element = this.element;
            var index = stream.index()-1;
            stream.addClass("disabled").data("streamDisabled", true);
            element.find(".stream-events").eq(index).find(".stream-event").addClass("disabled");
        },

        toggleStream: function(stream){
            if (stream.data("streamDisabled") === true) {
                this.enableStream(stream);
            } else {
                this.disableStream(stream);
            }
        },

        getLink: function(){
            var element = this.element, o = this.options;
            var events = element.find(".stream-event");
            var a = [];
            var link;
            var origin = window.location.href;

            $.each(events, function(){
                var event = $(this);
                if (event.data("sid") === undefined || !event.hasClass("selected")) {
                    return;
                }

                a.push(event.data("sid"));
            });

            link = element.attr("id") + "|" + a.join(",");

            if (o.encodeLink === true) {
                link = btoa(link);
            }

            return Utils.updateURIParameter(origin, "StreamerIDS", link);
        },

        getTimes: function(){
            var element = this.element;
            var times = element.find(".streamer-timeline > li");
            var result = [];
            $.each(times, function(){
                result.push($(this).data("time"));
            });
            return result;
        },

        getEvents: function(event_type, include_global){
            var element = this.element;
            var items, events = [];

            switch (event_type) {
                case "selected": items = element.find(".stream-event.selected"); break;
                case "non-selected": items = element.find(".stream-event:not(.selected)"); break;
                default: items = element.find(".stream-event");
            }

            $.each(items, function(){
                var item = $(this);
                var origin;

                if (include_global !== true && item.parent().hasClass("global-stream")) return ;

                origin = item.data("origin");

                events.push(origin);
            });

            return events;
        },

        source: function(s){
            var element = this.element;

            if (s === undefined) {
                return this.options.source;
            }

            element.attr("data-source", s);

            this.options.source = s;
            this.changeSource();
        },

        dataSet: function(s){
            if (s === undefined) {
                return this.options.data;
            }

            this.options.data = s;
            this.changeData(s);
        },

        getStreamerData: function(){
            return this.data;
        },

        toggleEvent: function(event){
            var o = this.options;
            event = $(event);

            if (event.hasClass("global-event") && o.selectGlobal !== true) {
                return ;
            }

            if (event.hasClass("selected")) {
                this.selectEvent(event, false);
            } else {
                this.selectEvent(event, true);
            }
        },

        selectEvent: function(event, state){
            var that = this, o = this.options;
            if (state === undefined) {
                state = true;
            }
            event = $(event);

            if (event.hasClass("global-event") && o.selectGlobal !== true) {
                return ;
            }

            if (state === true) event.addClass("selected"); else event.removeClass("selected");

            if (o.changeUri === true) {
                that._changeURI();
            }

            this._fireEvent("event-select", {
                event: event[0],
                selected: state
            });
        },

        changeSource: function(){
            var element = this.element, o = this.options;
            var new_source = element.attr("data-source");

            if (String(new_source).trim() === "") {
                return ;
            }

            o.source = new_source;

            this._fireEvent("data-load", {
                source: o.source
            });

            this._loadSource();

            // $.json(o.source).then(function(data){
            //
            //     that._fireEvent("data-loaded", {
            //         source: o.source,
            //         data: data
            //     });
            //
            //     that.data = data;
            //     that.build();
            // }, function(xhr){
            //
            //     that._fireEvent("data-load-error", {
            //         source: o.source,
            //         xhr: xhr
            //     });
            // });

            this._fireEvent("source-change");
        },

        changeData: function(data){
            var element = this.element, o = this.options;
            var old_data = this.data;

            o.data =  typeof data === 'object' ? data : JSON.parse(element.attr("data-data"));

            this.data = o.data;

            this.build();

            this._fireEvent("data-change", {
                oldData: old_data,
                newData: o.data
            });
        },

        changeStreamSelectOption: function(){
            var element = this.element, o = this.options;

            o.streamSelect = element.attr("data-stream-select").toLowerCase() === "true";
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'data-source': this.changeSource(); break;
                case 'data-data': this.changeData(); break;
                case 'data-stream-select': this.changeStreamSelectOption(); break;
            }
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".stream-event");
            element.off(Metro.events.click, ".stream");
            element.find(".events-area").off(Metro.events.mousewheel);
            element.find(".events-area").last().off("scroll");
            // element.off(Metro.events.click, ".stream");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var SwitchDefaultConfig = {
        switchDeferred: 0,
        material: false,
        transition: true,
        caption: "",
        captionPosition: "right",
        clsSwitch: "",
        clsCheck: "",
        clsCaption: "",
        textOn: "",
        textOff: "",
        locale: METRO_LOCALE,
        showOnOff: false,
        onSwitchCreate: Metro.noop
    };

    Metro.switchSetup = function (options) {
        SwitchDefaultConfig = $.extend({}, SwitchDefaultConfig, options);
    };

    if (typeof window["metroSwitchSetup"] !== undefined) {
        Metro.switchSetup(window["metroSwitchSetup"]);
    }

    Metro.Component('switch', {
        init: function( options, elem ) {
            this._super(elem, options, SwitchDefaultConfig, {
                locale: null
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var container ;
            var check = $("<span>").addClass("check");
            var caption = $("<span>").addClass("caption").html(o.caption);

            element.attr("type", "checkbox");

            if (element.attr("readonly") !== undefined) {
                element.on("click", function(e){
                    e.preventDefault();
                })
            }

            container = element.wrap(
                $("<label>").addClass((o.material === true ? " switch-material " : " switch ") + element[0].className)
            );

            this.component = container;

            check.appendTo(container);
            caption.appendTo(container);

            if (o.transition === true) {
                container.addClass("transition-on");
            }

            if (o.captionPosition === 'left') {
                container.addClass("caption-left");
            }

            element[0].className = '';

            container.addClass(o.clsSwitch);
            caption.addClass(o.clsCaption);
            check.addClass(o.clsCheck);

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            this.i18n(o.locale);
            this._fireEvent("switch-create");
        },

        disable: function(){
            this.element.prop("disabled", true);
        },

        enable: function(){
            this.element.prop("disabled", false);
        },

        toggleState: function(){
            var element = this.element;

            if (!element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggle: function(v){
            var element = this.element;

            if (element.is(":disabled")) return this;

            if (!Utils.isValue(v)) {
                element.prop("checked", !Utils.bool(element.prop("checked")));
            } else {
                element.prop("checked", v === 1);
            }

            return this;
        },

        changeLocale: function(where, val){
            var element = this.element, o = this.options;
            var check = element.siblings(".check");

            o["text"+Cake.capitalize(where)] = val

            check.attr("data-"+where, val);
        },

        i18n: function(locale){
            var element = this.element, o = this.options;
            var check = element.siblings(".check");
            var on, off;

            o.locale = locale;
            this.locale = Metro.locales[o.locale] !== undefined ? Metro.locales[o.locale] : Metro.locales["en-US"];

            if (o.showOnOff) {
                on = element.attr("data-on") || o.textOn || this.locale.switch.on;
                off = element.attr("data-off") || o.textOff || this.locale.switch.off;

                check.attr("data-on", on);
                check.attr("data-off", off);
            } else {
                check.removeAttr("data-on");
                check.removeAttr("data-off");
            }
        },

        changeAttribute: function(attr, newVal){
            switch (attr) {
                case 'data-on':
                case 'data-text-on': this.changeLocale('on', newVal); break;
                case 'data-off':
                case 'data-text-off': this.changeLocale('off', newVal); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var TableDefaultConfig = {
        useCurrentSlice: false,
        showInspectorButton: false,
        inspectorButtonIcon: "<span class='default-icon-equalizer'>",
        tableDeferred: 0,
        templateBeginToken: "<%",
        templateEndToken: "%>",
        paginationDistance: 5,

        locale: METRO_LOCALE,

        horizontalScroll: false,
        horizontalScrollStop: null,
        check: false,
        checkType: "checkbox",
        checkStyle: 1,
        checkColIndex: 0,
        checkName: null,
        checkStoreKey: "TABLE:$1:KEYS",
        rownum: false,
        rownumTitle: "#",

        filters: null,
        filtersOperator: "and",

        head: null,
        body: null,
        static: false,
        source: null,

        searchMinLength: 1,
        searchThreshold: 500,
        searchFields: null,

        showRowsSteps: true,
        showSearch: true,
        showTableInfo: true,
        showPagination: true,
        paginationShortMode: true,
        showActivity: true,
        muteTable: true,
        showSkip: false,

        rows: 10,
        rowsSteps: "10,25,50,100",

        staticView: false,
        viewSaveMode: "client",
        viewSavePath: "TABLE:$1:OPTIONS",

        sortDir: "asc",
        decimalSeparator: ".",
        thousandSeparator: ",",

        tableRowsCountTitle: null,
        tableSearchTitle: null,
        tableInfoTitle: null,
        paginationPrevTitle: null,
        paginationNextTitle: null,
        allRecordsTitle: null,
        inspectorTitle: null,
        tableSkipTitle: null,
        emptyTableTitle: null,

        activityType: "atom",
        activityStyle: "color",
        activityTimeout: 100,

        searchWrapper: null,
        rowsWrapper: null,
        infoWrapper: null,
        paginationWrapper: null,
        skipWrapper: null,

        cellWrapper: true,

        clsComponent: "",
        clsTableContainer: "",
        clsTable: "",

        clsHead: "",
        clsHeadRow: "",
        clsHeadCell: "",

        clsBody: "",
        clsBodyRow: "",
        clsBodyCell: "",
        clsCellWrapper: "",

        clsFooter: "",
        clsFooterRow: "",
        clsFooterCell: "",

        clsTableTop: "",
        clsRowsCount: "",
        clsSearch: "",

        clsTableBottom: "",
        clsTableInfo: "",
        clsTablePagination: "",

        clsPagination: "",
        clsTableSkip: "",
        clsTableSkipInput: "",
        clsTableSkipButton: "",

        clsEvenRow: "",
        clsOddRow: "",
        clsRow: "",

        clsEmptyTableTitle: "",

        onDraw: Metro.noop,
        onDrawRow: Metro.noop,
        onDrawCell: Metro.noop,
        onAppendRow: Metro.noop,
        onAppendCell: Metro.noop,
        onSortStart: Metro.noop,
        onSortStop: Metro.noop,
        onSortItemSwitch: Metro.noop,
        onSearch: Metro.noop,
        onRowsCountChange: Metro.noop,
        onDataLoad: Metro.noop,
        onDataLoadError: Metro.noop,
        onDataLoaded: Metro.noop,
        onDataLoadEnd: Metro.noop,
        onDataSaveError: Metro.noop,
        onFilterRowAccepted: Metro.noop,
        onFilterRowDeclined: Metro.noop,
        onCheckClick: Metro.noop,
        onCheckClickAll: Metro.noop,
        onCheckDraw: Metro.noop,
        onViewSave: Metro.noop,
        onViewGet: Metro.noop,
        onViewCreated: Metro.noop,
        onTableCreate: Metro.noop,
        onSkip: Metro.noop
    };

    Metro.tableSetup = function(options){
        TableDefaultConfig = $.extend({}, TableDefaultConfig, options);
    };

    if (typeof window["metroTableSetup"] !== undefined) {
        Metro.tableSetup(window["metroTableSetup"]);
    }

    Metro.Component('table', {
        init: function( options, elem ) {
            this._super(elem, options, TableDefaultConfig, {
                currentPage: 1,
                pagesCount: 1,
                searchString: "",
                data: null,
                activity: null,
                loadActivity: null,
                busy: false,
                filters: [],
                wrapperInfo: null,
                wrapperSearch: null,
                wrapperRows: null,
                wrapperPagination: null,
                wrapperSkip: null,
                filterIndex: null,
                filtersIndexes: [],
                component: null,
                inspector: null,
                view: {},
                viewDefault: {},
                locale: Metro.locales["en-US"],
                input_interval: null,
                searchFields: [],
                id: Utils.elementId('table'),
                sort: {
                    dir: "asc",
                    colIndex: 0
                },
                service: [],
                heads: [],
                items: [],
                foots: [],
                filteredItems: [],
                currentSlice: [],
                index: {}
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var id = Utils.elementId("table");
            var table_component, table_container, activity;

            if (!Utils.isValue(element.attr("id"))) {
                element.attr("id", id);
            }

            if (Utils.isValue(Metro.locales[o.locale])) {
                this.locale = Metro.locales[o.locale];
            }

            if (Utils.isValue(o.searchFields)) {
                this.searchFields = o.searchFields.toArray();
            }

            if (Utils.isValue(o.head)) {
                var _head = o.head;
                o.head = Utils.isObject(o.head);
                if (!o.head) {
                    console.warn("Head "+_head+" defined but not exists!");
                    o.head = null;
                }
            }

            if (Utils.isValue(o.body)) {
                var _body = o.body;
                o.body = Utils.isObject(o.body);
                if (!o.body) {
                    console.warn("Body "+_body+" defined but not exists!");
                    o.body = null;
                }
            }

            if (o.static === true) {
                o.showPagination = false;
                o.showRowsSteps = false;
                o.showSearch = false;
                o.showTableInfo = false;
                o.showSkip = false;
                o.rows = -1;
            }

            table_component = $("<div>").addClass("table-component");
            table_component.insertBefore(element);

            table_container = $("<div>").addClass("table-container").addClass(o.clsTableContainer).appendTo(table_component);
            element.appendTo(table_container);

            if (o.horizontalScroll === true) {
                table_container.addClass("horizontal-scroll");
            }
            if (!Utils.isNull(o.horizontalScrollStop) && Utils.mediaExist(o.horizontalScrollStop)) {
                table_container.removeClass("horizontal-scroll");
            }

            table_component.addClass(o.clsComponent);

            this.activity =  $("<div>").addClass("table-progress").appendTo(table_component);

            activity = $("<div>").appendTo(this.activity);
            Metro.makePlugin(activity, "activity", {
                type: o.activityType,
                style: o.activityStyle
            });

            if (o.showActivity !== true) {
                this.activity.css({
                    visibility: "hidden"
                })
            }

            this.component = table_component[0];

            if (o.source !== null) {

                this._fireEvent("data-load", {
                    source: o.source
                });

                var objSource = Utils.isObject(o.source);

                if (objSource !== false && $.isPlainObject(objSource)) {
                    that._build(objSource);
                } else {
                    this.activity.show(function () {
                        fetch(o.source)
                            .then(Metro.fetch.status)
                            .then(Metro.fetch.json)
                            .then(function(data){
                                that.activity.hide();
                                if (typeof data !== "object") {
                                    throw new Error("Data for table is not a object");
                                }

                                that._fireEvent("data-loaded", {
                                    source: o.source,
                                    data: data
                                });

                                that._build(data);
                            })
                            .catch(function(error){
                                that.activity.hide();

                                that._fireEvent("data-load-error", {
                                    source: o.source,
                                    error: error
                                });
                            });
                    });
                }
            } else {
                that._build();
            }
        },

        _createIndex: function(){
            var that = this, colIndex = this.options.checkColIndex;
            setImmediate(function(){
                that.items.forEach(function(v, i){
                    that.index[v[colIndex]] = i;
                });
            });
        },

        _build: function(data){
            var that = this, element = this.element, o = this.options;
            var view, id = element.attr("id"), viewPath;

            o.rows = +o.rows;

            this.items = [];
            this.heads = [];
            this.foots = [];

            if (Array.isArray(o.head)) {
                this.heads = o.head;
            }

            if (Array.isArray(o.body)) {
                this.items = o.body;
            }

            if (Utils.isValue(data)) {
                this._createItemsFromJSON(data);
            } else {
                this._createItemsFromHTML()
            }

            // Create index
            this._createIndex();

            this.view = this._createView();
            this.viewDefault = Utils.objectClone(this.view);

            viewPath = o.viewSavePath.replace("$1", id);

            if (o.viewSaveMode.toLowerCase() === "client") {

                view = Metro.storage.getItem(viewPath);
                if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(this.view)) {
                    this.view = view;

                    this._fireEvent("view-get", {
                        source: "client",
                        view: view
                    });
                }
                this._final();

            } else {

                fetch(viewPath)
                    .then(Metro.fetch.status)
                    .then(Metro.fetch.json)
                    .then(function(view){
                        if (Utils.isValue(view) && Utils.objectLength(view) === Utils.objectLength(that.view)) {
                            that.view = view;
                            that._fireEvent("view-get", {
                                source: "server",
                                view: view
                            });
                        }
                        that._final();
                    })
                    .catch(function(error){
                        that._final();
                        console.warn("Warning! Error loading view for table " + element.attr('id') + ": " + error);
                    });
            }
        },

        _final: function(){
            var element = this.element, o = this.options;
            var id = element.attr("id");

            Metro.storage.delItem(o.checkStoreKey.replace("$1", id));

            this._service();
            this._createStructure();
            this._createInspector();
            this._createEvents();

            this._fireEvent("table-create", {
                element: element
            });
        },

        _service: function(){
            var o = this.options;

            this.service = [
                {
                    // Rownum
                    title: o.rownumTitle,
                    format: undefined,
                    name: undefined,
                    sortable: false,
                    sortDir: undefined,
                    clsColumn: "rownum-cell " + (o.rownum !== true ? "d-none" : ""),
                    cls: "rownum-cell " + (o.rownum !== true ? "d-none" : ""),
                    colspan: undefined,
                    type: "rownum"
                },
                {
                    // Check
                    title: o.checkType === "checkbox" ? "<input type='checkbox' data-role='checkbox' class='table-service-check-all' data-style='"+o.checkStyle+"'>" : "",
                    format: undefined,
                    name: undefined,
                    sortable: false,
                    sortDir: undefined,
                    clsColumn: "check-cell " + (o.check !== true ? "d-none" : ""),
                    cls: "check-cell "+(o.check !== true ? "d-none" : ""),
                    colspan: undefined,
                    type: "rowcheck"
                }
            ];
        },

        _createView: function(){
            var view;

            view = {};

            $.each(this.heads, function(i){

                if (Utils.isValue(this.cls)) {this.cls = this.cls.replace("hidden", "");}
                if (Utils.isValue(this.clsColumn)) {this.clsColumn = this.clsColumn.replace("hidden", "");}

                view[i] = {
                    "index": i,
                    "index-view": i,
                    "show": !Utils.isValue(this.show) ? true : this.show,
                    "size": Utils.isValue(this.size) ? this.size : ""
                }
            });

            this._fireEvent("view-created", {
                view: view
            });

            return view;
        },

        _createInspectorItems: function(table){
            var that = this, o = this.options;
            var j, tds = [], row;
            var cells = this.heads;

            table.html("");

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(i){
                row = $("<tr>");
                row.data('index', i);
                row.data('index-view', i);
                $("<td>").html("<input type='checkbox' data-style='"+o.checkStyle+"' data-role='checkbox' name='column_show_check[]' value='"+i+"' "+(Utils.bool(that.view[i]['show']) ? "checked" : "")+">").appendTo(row);
                $("<td>").html(this.title).appendTo(row);
                $("<td>").html("<input type='number' data-role='spinner' name='column_size' value='"+that.view[i]['size']+"' data-index='"+i+"'>").appendTo(row);
                $("<td>").html("" +
                    "<button class='button square js-table-inspector-field-up' type='button'><span class='mif-arrow-up'></span></button>" +
                    "<button class='button square js-table-inspector-field-down' type='button'><span class='mif-arrow-down'></span></button>" +
                    "").appendTo(row);
                tds[that.view[i]['index-view']] = row;
            });

            //
            for (j = 0; j < cells.length; j++){
                tds[j].appendTo(table);
            }
        },

        _createInspector: function(){
            var o = this.options;
            var inspector, table_wrap, table, tbody, actions;

            inspector = $("<div data-role='draggable' data-drag-element='.table-inspector-header' data-drag-area='body'>").addClass("table-inspector");
            inspector.attr("for", this.element.attr("id"));

            $("<div class='table-inspector-header'>"+(o.inspectorTitle || this.locale.table["inspector"])+"</div>").appendTo(inspector);

            table_wrap = $("<div>").addClass("table-wrap").appendTo(inspector);

            table = $("<table>").addClass("table subcompact");
            tbody = $("<tbody>").appendTo(table);

            table.appendTo(table_wrap);

            this._createInspectorItems(tbody);

            actions = $("<div class='table-inspector-actions'>").appendTo(inspector);
            $("<button class='button primary js-table-inspector-save' type='button'>").html(this.locale.buttons.save).appendTo(actions);
            $("<button class='button secondary js-table-inspector-reset ml-2 mr-2' type='button'>").html(this.locale.buttons.reset).appendTo(actions);
            $("<button class='button link js-table-inspector-cancel place-right' type='button'>").html(this.locale.buttons.cancel).appendTo(actions);

            inspector.data("open", false);
            this.inspector = inspector;

            $("body").append(inspector);

            this._createInspectorEvents();
        },

        _resetInspector: function(){
            var inspector = this.inspector;
            var table = inspector.find("table tbody");
            this._createInspectorItems(table);
            this._createInspectorEvents();
        },

        _createHeadsFromHTML: function(){
            var that = this, element = this.element;
            var head = element.find("thead");

            if (head.length > 0) $.each(head.find("tr > *"), function(){
                var item = $(this);
                var dir, head_item, item_class;

                if (Utils.isValue(item.data('sort-dir'))) {
                    dir = item.data('sort-dir');
                } else {
                    if (item.hasClass("sort-asc")) {
                        dir = "asc";
                    } else if (item.hasClass("sort-desc")) {
                        dir = "desc"
                    } else {
                        dir = undefined;
                    }
                }

                item_class = item[0].className.replace("sortable-column", "");
                item_class = item_class.replace("sort-asc", "");
                item_class = item_class.replace("sort-desc", "");
                item_class = item_class.replace("hidden", "");

                head_item = {
                    type: "data",
                    title: item.html(),
                    name: Utils.isValue(item.data("name")) ? item.data("name") : item.text().replace(" ", "_"),
                    sortable: item.hasClass("sortable-column") || (Utils.isValue(item.data('sortable')) && JSON.parse(item.data('sortable')) === true),
                    sortDir: dir,
                    format: Utils.isValue(item.data("format")) ? item.data("format") : "string",
                    formatMask: Utils.isValue(item.data("format-mask")) ? item.data("format-mask") : null,
                    clsColumn: Utils.isValue(item.data("cls-column")) ? item.data("cls-column") : "",
                    cls: item_class,
                    colspan: item.attr("colspan"),
                    size: Utils.isValue(item.data("size")) ? item.data("size") : "",
                    show: !(item.hasClass("hidden") || (Utils.isValue(item.data('show')) && JSON.parse(item.data('show')) === false)),

                    required: Utils.isValue(item.data("required")) ? JSON.parse(item.data("required")) === true  : false,
                    field: Utils.isValue(item.data("field")) ? item.data("field") : "input",
                    fieldType: Utils.isValue(item.data("field-type")) ? item.data("field-type") : "text",
                    validator: Utils.isValue(item.data("validator")) ? item.data("validator") : null,

                    template: Utils.isValue(item.data("template")) ? item.data("template") : null
                };
                that.heads.push(head_item);
            });
        },

        _createFootsFromHTML: function(){
            var that = this, element = this.element;
            var foot = element.find("tfoot");

            if (foot.length > 0) $.each(foot.find("tr > *"), function(){
                var item = $(this);
                var foot_item;

                foot_item = {
                    title: item.html(),
                    name: Utils.isValue(item.data("name")) ? item.data("name") : false,
                    cls: item[0].className,
                    colspan: item.attr("colspan")
                };

                that.foots.push(foot_item);
            });
        },

        _createItemsFromHTML: function(){
            var that = this, element = this.element;
            var body = element.find("tbody");

            if (body.length > 0) $.each(body.find("tr"), function(){
                var row = $(this);
                var tr = [];
                $.each(row.children("td"), function(){
                    var td = $(this);
                    tr.push(td.html());
                });
                that.items.push(tr);
            });

            this._createHeadsFromHTML();
            this._createFootsFromHTML();
        },

        _createItemsFromJSON: function(source){
            var that = this;

            if (typeof source === "string") {
                source = JSON.parse(source);
            }

            if (source.header !== undefined) {
                that.heads = source.header;
            } else {
                this._createHeadsFromHTML();
            }

            if (source.data !== undefined) {
                $.each(source.data, function(){
                    var row = this;
                    var tr = [];
                    $.each(row, function(){
                        var td = this;
                        tr.push(td);
                    });
                    that.items.push(tr);
                });
            }

            if (source.footer !== undefined) {
                this.foots = source.footer;
            } else {
                this._createFootsFromHTML();
            }
        },

        _createTableHeader: function(){
            var element = this.element, o = this.options;
            var head = element.find("thead");
            var tr, th, tds = [], j, cells;
            var view = o.staticView ? this._createView() : this.view;

            if (head.length === 0) {
                head = $("<thead>");
                element.prepend(head);
            }

            head.clear().addClass(o.clsHead);

            if (this.heads.length === 0) {
                return head;
            }

            tr = $("<tr>").addClass(o.clsHeadRow).appendTo(head);

            $.each(this.service, function(){
                var item = this, classes = [];
                th = $("<th>").appendTo(tr);
                if (Utils.isValue(item.title)) {th.html(item.title);}
                if (Utils.isValue(item.size)) {th.css({width: item.size});}
                if (Utils.isValue(item.cls)) {classes.push(item.cls);}
                classes.push(o.clsHeadCell);
                th.addClass(classes.join(" "));
            });

            cells = this.heads;

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(cell_index){
                var item = this;
                var classes = [];

                th = $("<th>");
                th.data("index", cell_index);

                if (Utils.isValue(item.title)) {th.html(item.title);}
                if (Utils.isValue(item.format)) {th.attr("data-format", item.format);}
                if (Utils.isValue(item.name)) {th.attr("data-name", item.name);}
                if (Utils.isValue(item.colspan)) {th.attr("colspan", item.colspan);}
                if (Utils.isValue(view[cell_index]['size'])) {th.css({width: view[cell_index]['size']});}
                if (item.sortable === true) {
                    classes.push("sortable-column");

                    if (Utils.isValue(item.sortDir)) {
                        classes.push("sort-" + item.sortDir);
                    }
                }
                if (Utils.isValue(item.cls)) {
                    $.each(item.cls.toArray(), function () {
                        classes.push(this);
                    });
                }
                if (Utils.bool(view[cell_index]['show']) === false) {
                    if (classes.indexOf('hidden') === -1) classes.push("hidden");
                }

                classes.push(o.clsHeadCell);

                if (Utils.bool(view[cell_index]['show'])) {
                    Utils.arrayDelete(classes, "hidden");
                }

                th.addClass(classes.join(" "));

                tds[view[cell_index]['index-view']] = th;
            });

            for (j = 0; j < cells.length; j++){
                tds[j].appendTo(tr);
            }
        },

        _createTableBody: function(){
            var body, head, element = this.element;

            head  = element.find("thead");
            body  = element.find("tbody");

            if (body.length === 0) {
                body = $("<tbody>").addClass(this.options.clsBody);
                if (head.length !== 0) {
                    body.insertAfter(head);
                } else {
                    element.append(body);
                }
            }

            body.clear();
        },

        _createTableFooter: function(){
            var element = this.element, o = this.options;
            var foot = element.find("tfoot");
            var tr, th;

            if (foot.length === 0) {
                foot = $("<tfoot>").appendTo(element);
            }

            foot.clear().addClass(o.clsFooter);

            if (this.foots.length === 0) {
                return;
            }

            tr = $("<tr>").addClass(o.clsHeadRow).appendTo(foot);
            $.each(this.foots, function(){
                var item = this;
                th = $("<th>").appendTo(tr);

                if (item.title !== undefined) {
                    th.html(item.title);
                }

                if (item.name !== undefined) {
                    th.addClass("foot-column-name-" + item.name);
                }

                if (item.cls !== undefined) {
                    th.addClass(item.cls);
                }

                if (Utils.isValue(item.colspan)) {
                    th.attr("colspan", item.colspan);
                }

                th.appendTo(tr);
            });
        },

        _createTopBlock: function (){
            var that = this, element = this.element, o = this.options;
            var top_block = $("<div>").addClass("table-top").addClass(o.clsTableTop).insertBefore(element.parent());
            var search_block, search_input, rows_block, rows_select;

            search_block = Utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $("<div>").addClass("table-search-block").addClass(o.clsSearch).appendTo(top_block);
            search_block.addClass(o.clsSearch);

            search_input = $("<input>").attr("type", "text").appendTo(search_block);
            Metro.makePlugin(search_input, "input", {
                prepend: o.tableSearchTitle || that.locale.table["search"]
            });

            if (o.showSearch !== true) {
                search_block.hide();
            }

            rows_block = Utils.isValue(this.wrapperRows) ? this.wrapperRows : $("<div>").addClass("table-rows-block").appendTo(top_block);
            rows_block.addClass(o.clsRowsCount);

            rows_select = $("<select>").appendTo(rows_block);
            $.each(o.rowsSteps.toArray(), function () {
                var val = parseInt(this);
                var option = $("<option>").attr("value", val).text(val === -1 ? (o.allRecordsTitle || that.locale.table["all"]) : val).appendTo(rows_select);
                if (val === parseInt(o.rows)) {
                    option.attr("selected", "selected");
                }
            });
            Metro.makePlugin(rows_select, "select",{
                filter: false,
                prepend: o.tableRowsCountTitle || that.locale.table["rowsCount"],
                onChange: function (val) {
                    val = parseInt(val);
                    if (val === parseInt(o.rows)) {
                        return;
                    }
                    o.rows = val;
                    that.currentPage = 1;
                    that._draw();

                    that._fireEvent("rows-count-change", {
                        val: val
                    });
                }
            });

            if (o.showInspectorButton) {
                $("<button>").addClass("button inspector-button").attr("type", "button").html(o.inspectorButtonIcon).insertAfter(rows_block);
            }

            if (o.showRowsSteps !== true) {
                rows_block.hide();
            }

            return top_block;
        },

        _createBottomBlock: function (){
            var element = this.element, o = this.options;
            var bottom_block = $("<div>").addClass("table-bottom").addClass(o.clsTableBottom).insertAfter(element.parent());
            var info, pagination, skip;

            info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : $("<div>").addClass("table-info").appendTo(bottom_block);
            info.addClass(o.clsTableInfo);
            if (o.showTableInfo !== true) {
                info.hide();
            }

            pagination = Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : $("<div>").addClass("table-pagination").appendTo(bottom_block);
            pagination.addClass(o.clsTablePagination);
            if (o.showPagination !== true) {
                pagination.hide();
            }

            skip = Utils.isValue(this.wrapperSkip) ? this.wrapperSkip : $("<div>").addClass("table-skip").appendTo(bottom_block);
            skip.addClass(o.clsTableSkip);

            $("<input type='text'>").addClass("input table-skip-input").addClass(o.clsTableSkipInput).appendTo(skip);
            $("<button>").addClass("button table-skip-button").addClass(o.clsTableSkipButton).html(o.tableSkipTitle || this.locale.table["skip"]).appendTo(skip);

            if (o.showSkip !== true) {
                skip.hide();
            }

            return bottom_block;
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var columns;
            var w_search = $(o.searchWrapper),
                w_info = $(o.infoWrapper),
                w_rows = $(o.rowsWrapper),
                w_paging = $(o.paginationWrapper),
                w_skip = $(o.skipWrapper);

            if (w_search.length > 0) {this.wrapperSearch = w_search;}
            if (w_info.length > 0) {this.wrapperInfo = w_info;}
            if (w_rows.length > 0) {this.wrapperRows = w_rows;}
            if (w_paging.length > 0) {this.wrapperPagination = w_paging;}
            if (w_skip.length > 0) {this.wrapperSkip = w_skip;}

            element.addClass(o.clsTable);

            this._createTableHeader();
            this._createTableBody();
            this._createTableFooter();

            this._createTopBlock();
            this._createBottomBlock();

            var need_sort = false;
            if (this.heads.length > 0) $.each(this.heads, function(i){
                var item = this;
                if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
                    need_sort = true;
                    that.sort.colIndex = i;
                    that.sort.dir = item.sortDir;
                }
            });

            if (need_sort) {
                columns = element.find("thead th");
                this._resetSortClass(columns);
                $(columns.get(this.sort.colIndex + that.service.length)).addClass("sort-"+this.sort.dir);
                this.sorting();
            }

            var filter_func;

            if (Utils.isValue(o.filters) && typeof o.filters === 'string') {
                $.each(o.filters.toArray(), function(){
                    filter_func = Utils.isFunc(this);
                    if (filter_func !== false) {
                        that.filtersIndexes.push(that.addFilter(filter_func));
                    }
                });
            }

            this.currentPage = 1;

            this._draw();
        },

        _resetSortClass: function(el){
            $(el).removeClass("sort-asc sort-desc");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var component = element.closest(".table-component");
            var table_container = component.find(".table-container");
            var search = component.find(".table-search-block input");
            var skip_button = o.skipWrapper ? $(o.skipWrapper).find('.table-skip-button') : component.find(".table-skip-button");
            var skip_input = o.skipWrapper ? $(o.skipWrapper).find('.table-skip-input') : component.find(".table-skip-input");
            var customSearch;
            var id = element.attr("id");
            var inspectorButton = component.find(".inspector-button");

            inspectorButton.on(Metro.events.click, function(){
                that.toggleInspector();
            });

            skip_button.on(Metro.events.click, function(){
                var skipTo = parseInt(skip_input.val().trim());

                if (isNaN(skipTo) || skipTo <=0 || skipTo > that.pagesCount) {
                    skip_input.val('');
                    return false;
                }

                skip_input.val('');

                that._fireEvent("skip", {
                    skipTo: skipTo,
                    skipFrom: that.currentPage
                });

                that.page(skipTo);
            });

            $(window).on(Metro.events.resize, function(){
                if (o.horizontalScroll === true) {
                    if (!Utils.isNull(o.horizontalScrollStop) && Utils.mediaExist(o.horizontalScrollStop)) {
                        table_container.removeClass("horizontal-scroll");
                    } else {
                        table_container.addClass("horizontal-scroll");
                    }
                }
            }, {ns: this.id});

            element.on(Metro.events.click, ".sortable-column", function(){

                if (o.muteTable === true) element.addClass("disabled");

                if (that.busy) {
                    return false;
                }
                that.busy = true;

                var col = $(this);

                that.activity.show(function(){
                    setImmediate(function(){
                        that.currentPage = 1;
                        that.sort.colIndex = col.data("index");
                        if (!col.hasClass("sort-asc") && !col.hasClass("sort-desc")) {
                            that.sort.dir = o.sortDir;
                        } else {
                            if (col.hasClass("sort-asc")) {
                                that.sort.dir = "desc";
                            } else {
                                that.sort.dir = "asc";
                            }
                        }
                        that._resetSortClass(element.find(".sortable-column"));
                        col.addClass("sort-"+that.sort.dir);
                        that.sorting();
                        that._draw(function(){
                            that.busy = false;
                            if (o.muteTable === true) element.removeClass("disabled");
                        });
                    });
                });
            });

            element.on(Metro.events.click, ".table-service-check input", function(){
                var check = $(this);
                var status = check.is(":checked");
                var val = ""+check.val();
                var store_key = o.checkStoreKey.replace("$1", id);
                var storage = Metro.storage;
                var data = storage.getItem(store_key);
                var is_radio = check.attr('type') === 'radio';

                if (is_radio) {
                    data = [];
                }

                if (status) {
                    if (!Utils.isValue(data)) {
                        data = [val];
                    } else {
                        if (Array(data).indexOf(val) === -1) {
                            data.push(val);
                        }
                    }
                } else {
                    if (Utils.isValue(data)) {
                        Utils.arrayDelete(data, val);
                    } else {
                        data = [];
                    }
                }

                storage.setItem(store_key, data);

                that._fireEvent("check-click", {
                    check: this,
                    status: status,
                    data: data
                });
            });

            element.on(Metro.events.click, ".table-service-check-all input", function(){
                var checked = $(this).is(":checked");
                var store_key = o.checkStoreKey.replace("$1", id);
                var storage = Metro.storage;
                var data, stored_keys;

                if (o.useCurrentSlice === true) {
                    stored_keys = storage.getItem(store_key, []);

                    if (checked) {
                        $.each(that.currentSlice, function(){
                            if (stored_keys.indexOf(""+this[o.checkColIndex]) === -1) {
                                stored_keys.push(""+this[o.checkColIndex])
                            }
                        });
                    } else {
                        $.each(that.currentSlice, function(){
                            var key = ""+this[o.checkColIndex];
                            if (stored_keys.indexOf(key) !== -1) {
                                Metro.utils.arrayDelete(stored_keys, key)
                            }
                        });
                    }
                    data = stored_keys
                } else {
                    if (checked) {
                        $.each(that.filteredItems, function () {
                            if (data.indexOf(this[o.checkColIndex]) !== -1) return;
                            data.push("" + this[o.checkColIndex]);
                        });
                    } else {
                        data = [];
                    }
                }

                storage.setItem(store_key, data);

                that._draw();

                that._fireEvent("check-click-all", {
                    check: this,
                    status: checked,
                    data: data
                });
            });

            var _search = function(){
                that.searchString = this.value.trim().toLowerCase();

                clearInterval(that.input_interval); that.input_interval = false;
                if (!that.input_interval) that.input_interval = setTimeout(function(){
                    that.currentPage = 1;
                    that._draw();
                    clearInterval(that.input_interval); that.input_interval = false;
                }, o.searchThreshold);
            };

            search.on(Metro.events.inputchange, _search);

            if (Utils.isValue(this.wrapperSearch)) {
                customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.on(Metro.events.inputchange, _search);
                }
            }

            function pageLinkClick(l){
                var link = $(l);
                var item = link.parent();
                if (that.filteredItems.length === 0) {
                    return ;
                }

                if (item.hasClass("active")) {
                    return ;
                }

                if (item.hasClass("service")) {
                    if (link.data("page") === "prev") {
                        that.currentPage--;
                        if (that.currentPage === 0) {
                            that.currentPage = 1;
                        }
                    } else {
                        that.currentPage++;
                        if (that.currentPage > that.pagesCount) {
                            that.currentPage = that.pagesCount;
                        }
                    }
                } else {
                    that.currentPage = link.data("page");
                }

                that._draw();
            }

            component.on(Metro.events.click, ".pagination .page-link", function(){
                pageLinkClick(this)
            });

            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.on(Metro.events.click, ".pagination .page-link", function(){
                    pageLinkClick(this)
                });
            }

            this._createInspectorEvents();

            element.on(Metro.events.click, ".js-table-crud-button", function(){

            });
        },

        _createInspectorEvents: function(){
            var that = this, inspector = this.inspector;
            // Inspector event

            this._removeInspectorEvents();

            inspector.on(Metro.events.click, ".js-table-inspector-field-up", function(){
                var button = $(this), tr = button.closest("tr");
                var tr_prev = tr.prev("tr");
                var index = tr.data("index");
                var index_view;
                if (tr_prev.length === 0) {
                    return ;
                }
                tr.insertBefore(tr_prev);
                tr.addClass("flash");
                setTimeout(function(){
                    tr.removeClass("flash");
                }, 1000);
                index_view = tr.index();

                tr.data("index-view", index_view);
                that.view[index]['index-view'] = index_view;

                $.each(tr.nextAll(), function(){
                    var t = $(this);
                    index_view++;
                    t.data("index-view", index_view);
                    that.view[t.data("index")]['index-view'] = index_view;
                });

                that._createTableHeader();
                that._draw();
            });

            inspector.on(Metro.events.click, ".js-table-inspector-field-down", function(){
                var button = $(this), tr = button.closest("tr");
                var tr_next = tr.next("tr");
                var index = tr.data("index");
                var index_view;
                if (tr_next.length === 0) {
                    return ;
                }
                tr.insertAfter(tr_next);
                tr.addClass("flash");
                setTimeout(function(){
                    tr.removeClass("flash");
                }, 1000);
                index_view = tr.index();

                tr.data("index-view", index_view);
                that.view[index]['index-view'] = index_view;

                $.each(tr.prevAll(), function(){
                    var t = $(this);
                    index_view--;
                    t.data("index-view", index_view);
                    that.view[t.data("index")]['index-view'] = index_view;
                });

                that._createTableHeader();
                that._draw();
            });

            inspector.on(Metro.events.click, "input[type=checkbox]", function(){
                var check = $(this);
                var status = check.is(":checked");
                var index = check.val();
                var op = ['cls', 'clsColumn'];

                if (status) {
                    $.each(op, function(){
                        var a;
                        a = Utils.isValue(that.heads[index][this]) ? (that.heads[index][this]).toArray(" ") : [];
                        Utils.arrayDelete(a, "hidden");
                        that.heads[index][this] = a.join(" ");
                        that.view[index]['show'] = true;
                    });
                } else {
                    $.each(op, function(){
                        var a;

                        a = Utils.isValue(that.heads[index][this]) ? (that.heads[index][this]).toArray(" ") : [];
                        if (a.indexOf("hidden") === -1) {
                            a.push("hidden");
                        }
                        that.heads[index][this] = a.join(" ");
                        that.view[index]['show'] = false;
                    });
                }

                that._createTableHeader();
                that._draw();
            });

            inspector.find("input[type=number]").on(Metro.events.inputchange, function(){
                var input = $(this);
                var index = input.attr("data-index");
                var val = parseInt(input.val());

                that.view[index]['size'] = val === 0 ? "" : val;

                that._createTableHeader();
            });

            inspector.on(Metro.events.click, ".js-table-inspector-save", function(){
                that._saveTableView();
                that.openInspector(false);
            });

            inspector.on(Metro.events.click, ".js-table-inspector-cancel", function(){
                that.openInspector(false);
            });

            inspector.on(Metro.events.click, ".js-table-inspector-reset", function(){
                that.resetView();
            });
        },

        _removeInspectorEvents: function(){
            var inspector = this.inspector;
            inspector.off(Metro.events.click, ".js-table-inspector-field-up");
            inspector.off(Metro.events.click, ".js-table-inspector-field-down");
            inspector.off(Metro.events.click, "input[type=checkbox]");
            inspector.off(Metro.events.click, ".js-table-inspector-save");
            inspector.off(Metro.events.click, ".js-table-inspector-cancel");
            inspector.off(Metro.events.click, ".js-table-inspector-reset");
            inspector.find("input[type=number]").off(Metro.events.inputchange);
        },

        _saveTableView: function(){
            var that = this, element = this.element, o = this.options;
            var view = this.view;
            var id = element.attr("id");
            var viewPath = o.viewSavePath.replace("$1", id);
            var storage = Metro.storage;

            if (o.viewSaveMode.toLowerCase() === "client") {
                storage.setItem(viewPath, view);

                this._fireEvent("view-save", {
                    target: "client",
                    path: o.viewSavePath,
                    view: view
                });
            } else {
                var post_data = {
                    id : element.attr("id"),
                    view : view
                };

                fetch(viewPath, {
                    method: "POST"
                    , body: JSON.stringify(post_data)
                    , header: {
                        "Content-type": "application/json;charset=utf-8"
                    }
                })
                    .then(Metro.fetch.status)
                    .then(Metro.fetch.text)
                    .then(function(data){
                        that._fireEvent("view-save", {
                            target: "server",
                            path: o.viewSavePath,
                            view: view,
                            post_data: post_data,
                            response: data
                        });
                    })
                    .catch(function(error){
                        that._fireEvent("data-save-error", {
                            source: o.viewSavePath,
                            error: error,
                            post_data: post_data
                        });
                    });
            }
        },

        _info: function(start, stop, length){
            var element = this.element, o = this.options;
            var component = element.closest(".table-component");
            var info = Utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".table-info");
            var text;

            if (info.length === 0) {
                return ;
            }

            if (stop > length) {
                stop = length;
            }

            if (this.items.length === 0) {
                start = stop = length = 0;
            }

            text = o.tableInfoTitle || this.locale.table["info"];
            text = text.replace("$1", start);
            text = text.replace("$2", stop);
            text = text.replace("$3", length);
            info.html(text);
        },

        _paging: function(length){
            var element = this.element, o = this.options;
            var component = element.closest(".table-component");
            this.pagesCount = Math.ceil(length / o.rows); // Костыль
            Metro.pagination({
                length: length,
                rows: o.rows,
                current: this.currentPage,
                target: Utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".table-pagination"),
                claPagination: o.clsPagination,
                prevTitle: o.paginationPrevTitle || this.locale.table["prev"],
                nextTitle: o.paginationNextTitle || this.locale.table["next"],
                distance: o.paginationShortMode === true ? o.paginationDistance : 0
            });
        },

        _filter: function(){
            var that = this, o = this.options;
            var items;
            if ((Utils.isValue(this.searchString) && that.searchString.length >= o.searchMinLength) || this.filters.length > 0) {
                items = this.items.filter(function(row){

                    var row_data = "", result, search_result, i, j = 0;

                    if (that.filters.length > 0) {

                        result = o.filtersOperator.toLowerCase() === "and";
                        for (i = 0; i < that.filters.length; i++) {
                            if (Utils.isNull(that.filters[i])) continue;
                            j++;
                            result = o.filtersOperator.toLowerCase() === "and" ?
                                result && Utils.exec(that.filters[i], [row, that.heads]) :
                                result || Utils.exec(that.filters[i], [row, that.heads])
                            ;
                        }

                        if (j === 0) result = true;
                    } else {
                        result = true;
                    }

                    if (that.searchFields.length > 0) {
                        $.each(that.heads, function(i, v){
                            if (that.searchFields.indexOf(v.name) > -1) {
                                row_data += "•"+row[i];
                            }
                        })
                    } else {
                        row_data = row.join("•");
                    }

                    row_data = row_data.replace(/[\n\r]+|[\s]{2,}/g, ' ').trim().toLowerCase();
                    search_result = Utils.isValue(that.searchString) && that.searchString.length >= o.searchMinLength ? ~row_data.indexOf(that.searchString) : true;

                    result = result && search_result;

                    if (result) {
                        that._fireEvent("filter-row-accepted", {
                            row: row
                        });
                    } else {
                        that._fireEvent("filter-row-declined", {
                            row: row
                        });
                    }

                    return result;
                });

            } else {
                items = this.items;
            }

            this._fireEvent("search", {
                search: that.searchString,
                items: items
            });

            this.filteredItems = items;

            return items;
        },

        _draw: function(cb){
            var that = this, element = this.element, o = this.options;
            var body = element.find("tbody");
            var i, j, tr, td, check, cells, tds, is_even_row;
            var start = parseInt(o.rows) === -1 ? 0 : o.rows * (this.currentPage - 1),
                stop = parseInt(o.rows) === -1 ? this.items.length - 1 : start + o.rows - 1;
            var items, checkedItems = [];
            var stored_keys = Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr('id')));

            var view = o.staticView ? this.viewDefault : this.view;

            body.html("");

            if (!this.heads.length) {
                console.warn("Heads is not defined for table ID " + element.attr("id"));
                return ;
            }

            items = this._filter();

            this.currentSlice = items.slice(start, stop + 1);
            checkedItems = [];

            if (items.length > 0) {
                for (i = start; i <= stop; i++) {
                    cells = items[i];
                    tds = [];
                    if (!Utils.isValue(cells)) {continue;}
                    tr = $("<tr>").addClass(o.clsBodyRow);
                    tr.data('original', cells);

                    // Rownum

                    is_even_row = i % 2 === 0;

                    td = $("<td>").html(i + 1);
                    if (that.service[0].clsColumn !== undefined) {
                        td.addClass(that.service[0].clsColumn);
                    }
                    td.appendTo(tr);

                    // Checkbox
                    td = $("<td>");
                    if (o.checkType === "checkbox") {
                        check = $("<input type='checkbox' data-style='"+o.checkStyle+"' data-role='checkbox' name='" + (Utils.isValue(o.checkName) ? o.checkName : 'table_row_check') + "[]' value='" + items[i][o.checkColIndex] + "'>");
                    } else {
                        check = $("<input type='radio' data-style='"+o.checkStyle+"' data-role='radio' name='" + (Utils.isValue(o.checkName) ? o.checkName : 'table_row_check') + "' value='" + items[i][o.checkColIndex] + "'>");
                    }

                    if (Utils.isValue(stored_keys) && Array.isArray(stored_keys) && stored_keys.indexOf(""+items[i][o.checkColIndex]) > -1) {
                        check.prop("checked", true);
                        checkedItems.push(cells)
                    }

                    check.addClass("table-service-check");

                    this._fireEvent("check-draw", {
                        check: check
                    });

                    check.appendTo(td);
                    if (that.service[1].clsColumn !== undefined) {
                        td.addClass(that.service[1].clsColumn);
                    }
                    td.appendTo(tr);
                    // End of check

                    for (j = 0; j < cells.length; j++){
                        tds[j] = null;
                    }

                    $.each(cells, function(cell_index){
                        var val = this;
                        var td = $("<td>");

                        if (Utils.isValue(that.heads[cell_index].template)) {
                            val = that.heads[cell_index].template.replace(/%VAL%/g, val);
                        }

                        td.html(val);

                        td.addClass(o.clsBodyCell);
                        if (Utils.isValue(that.heads[cell_index].clsColumn)) {
                            td.addClass(that.heads[cell_index].clsColumn);
                        }

                        if (Utils.bool(view[cell_index].show) === false) {
                            td.addClass("hidden");
                        }

                        if (Utils.bool(view[cell_index].show)) {
                            td.removeClass("hidden");
                        }

                        td.data('original',this);

                        tds[view[cell_index]['index-view']] = td;

                        that._fireEvent("draw-cell", {
                            td: td,
                            val: val,
                            cellIndex: cell_index,
                            head: that.heads[cell_index],
                            items: cells
                        });

                        if (o.cellWrapper === true) {
                            val = $("<div>").addClass("data-wrapper").addClass(o.clsCellWrapper).html(td.html());
                            td.html('').append(val);
                        }
                    });

                    for (j = 0; j < cells.length; j++){
                        tds[j].appendTo(tr);

                        that._fireEvent("append-cell", {
                            td: tds[j],
                            tr: tr,
                            index: j
                        });
                    }

                    that._fireEvent("draw-row", {
                        tr: tr,
                        view: that.view,
                        heads: that.heads,
                        items: cells
                    });

                    tr.addClass(o.clsRow).addClass(is_even_row ? o.clsEvenRow : o.clsOddRow).appendTo(body);

                    that._fireEvent("append-row", {
                        tr: tr
                    });
                }

                $(this.component).find(".table-service-check-all input").prop("checked", checkedItems.length);
            } else {
                j = 0;
                $.each(view, function(){
                    if (this.show) j++;
                });
                if (o.check === true) {
                    j++;
                }
                if (o.rownum === true) {
                    j++;
                }
                tr = $("<tr>").addClass(o.clsBodyRow).appendTo(body);
                td = $("<td>").attr("colspan", j).addClass("text-center").html($("<span>").addClass(o.clsEmptyTableTitle).html(o.emptyTableTitle || that.locale.table["empty"]));
                td.appendTo(tr);
            }

            this._info(start + 1, stop + 1, items.length);
            this._paging(items.length);

            if (this.activity) this.activity.hide();

            this._fireEvent("draw");

            if (cb !== undefined) {
                Utils.exec(cb, null, element[0])
            }
        },

        _getItemContent: function(row){
            var o = this.options;
            var result, col = row[this.sort.colIndex];
            var format = this.heads[this.sort.colIndex].format;
            var formatMask = !Utils.isNull(this.heads) && !Utils.isNull(this.heads[this.sort.colIndex]) && Utils.isValue(this.heads[this.sort.colIndex]['formatMask']) ? this.heads[this.sort.colIndex]['formatMask'] : "%Y-%m-%d";
            var thousandSeparator = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["thousandSeparator"] ? this.heads[this.sort.colIndex]["thousandSeparator"] : o.thousandSeparator;
            var decimalSeparator  = this.heads && this.heads[this.sort.colIndex] && this.heads[this.sort.colIndex]["decimalSeparator"] ? this.heads[this.sort.colIndex]["decimalSeparator"] : o.decimalSeparator;

            result = (""+col).toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, ' ').trim();

            if (Utils.isValue(result) && Utils.isValue(format)) {

                if (['number', 'int', 'float', 'money'].indexOf(format) !== -1) {
                    result = Utils.parseNumber(result, thousandSeparator, decimalSeparator);
                }

                switch (format) {
                    case "date": result = formatMask ? Datetime.from(result, formatMask, o.locale) : datetime(result); break;
                    case "number": result = +result; break;
                    case "int": result = parseInt(result); break;
                    case "float": result = parseFloat(result); break;
                    case "money": result = Utils.parseMoney(result); break;
                    case "card": result = Utils.parseCard(result); break;
                    case "phone": result = Utils.parsePhone(result); break;
                }
            }

            return result;
        },

        addItem: function(item, redraw){
            if (!Array.isArray(item)) {
                console.warn("Item is not an array and can't be added");
                return this;
            }
            this.items.push(item);
            if (redraw !== false) this.draw();
        },

        addItems: function(items, redraw){
            if (!Array.isArray(items)) {
                console.warn("Items is not an array and can't be added");
                return this;
            }
            items.forEach(function(item){
                if (Array.isArray(item))
                    this.items.push(item, false);
            });
            this.draw();
            if (redraw !== false) this.draw();
        },

        updateItem: function(key, field, value){
            var item = this.items[this.index[key]];
            var fieldIndex = null;
            if (Utils.isNull(item)) {
                console.warn('Item is undefined for update');
                return this;
            }
            if (isNaN(field)) {
                this.heads.forEach(function(v, i){
                    if (v['name'] === field) {
                        fieldIndex = i;
                    }
                });
            }
            if (Utils.isNull(fieldIndex)) {
                console.warn('Item is undefined for update. Field ' + field + ' not found in data structure');
                return this;
            }

            item[fieldIndex] = value;
            this.items[this.index[key]] = item;
            return this;
        },

        getItem: function(key){
            return this.items[this.index[key]];
        },

        deleteItem: function(fieldIndex, value){
            var i, deleteIndexes = [];
            var is_func = Utils.isFunc(value);
            for(i = 0; i < this.items.length; i++) {
                if (is_func) {
                    if (Utils.exec(value, [this.items[i][fieldIndex]])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (this.items[i][fieldIndex] === value) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        deleteItemByName: function(fieldName, value){
            var i, fieldIndex, deleteIndexes = [];
            var is_func = Utils.isFunc(value);

            for(i = 0; i < this.heads.length; i++) {
                if (this.heads[i]['name'] === fieldName) {
                    fieldIndex = i;
                    break;
                }
            }

            for(i = 0; i < this.items.length; i++) {
                if (is_func) {
                    if (Utils.exec(value, [this.items[i][fieldIndex]])) {
                        deleteIndexes.push(i);
                    }
                } else {
                    if (this.items[i][fieldIndex] === value) {
                        deleteIndexes.push(i);
                    }
                }
            }

            this.items = Utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);

            return this;
        },

        draw: function(){
            this._draw();
            return this;
        },

        sorting: function(dir){
            var that = this;

            if (Utils.isValue(dir)) {
                this.sort.dir = dir;
            }

            this._fireEvent("sort-start", {
                items: this.items
            });

            this.items.sort(function(a, b){
                var c1 = that._getItemContent(a);
                var c2 = that._getItemContent(b);
                var result = 0;

                if (c1 < c2) {
                    result = that.sort.dir === "asc" ? -1 : 1;
                }
                if (c1 > c2) {
                    result = that.sort.dir === "asc" ? 1 : -1;
                }

                if (result !== 0) {

                    that._fireEvent("sort-item-switch", {
                        a: a,
                        b: b,
                        result: result
                    });
                }

                return result;
            });

            this._fireEvent("sort-stop", {
                items: this.items
            });

            return this;
        },

        search: function(val){
            this.searchString = val.trim().toLowerCase();
            this.currentPage = 1;
            this._draw();
            return this;
        },

        _rebuild: function(review){
            var that = this, element = this.element;
            var need_sort = false, sortable_columns;

            this._createIndex();

            if (review === true) {
                this.view = this._createView();
            }

            this._createTableHeader();
            this._createTableBody();
            this._createTableFooter();

            if (this.heads.length > 0) $.each(this.heads, function(i){
                var item = this;
                if (!need_sort && ["asc", "desc"].indexOf(item.sortDir) > -1) {
                    need_sort = true;
                    that.sort.colIndex = i;
                    that.sort.dir = item.sortDir;
                }
            });

            if (need_sort) {
                sortable_columns = element.find(".sortable-column");
                this._resetSortClass(sortable_columns);
                $(sortable_columns.get(that.sort.colIndex)).addClass("sort-"+that.sort.dir);
                this.sorting();
            }

            that.currentPage = 1;

            that._draw();
        },

        setHeads: function(data){
            this.heads = data;
            return this;
        },

        setHeadItem: function(name, data){
            var i, index;
            for(i = 0; i < this.heads.length; i++) {
                if (this.heads[i].name === name) {
                    index = i;
                    break;
                }
            }
            this.heads[index] = data;
            return this;
        },

        setItems: function(data){
            this.items = data;
            return this;
        },

        setData: function(/*obj*/ data){
            var o = this.options;

            this.items = [];
            this.heads = [];
            this.foots = [];

            if (Array.isArray(o.head)) {
                this.heads = o.head;
            }

            if (Array.isArray(o.body)) {
                this.items = o.body;
            }

            this._createItemsFromJSON(data);

            this._rebuild(true);

            return this;
        },

        loadData: function(source, review){
            var that = this, element = this.element, o = this.options;

            if (!Utils.isValue(review)) {
                review = true;
            }

            element.html("");

            if (!Utils.isValue(source)) {

                this._rebuild(review);

            } else {
                o.source = source;

                this._fireEvent("data-load", {
                    source: o.source
                });

                that.activity.show(function(){
                    fetch(o.source)
                        .then(Metro.fetch.status)
                        .then(Metro.fetch.json)
                        .then(function(data){
                            that.activity.hide();
                            that.items = [];
                            that.heads = [];
                            that.foots = [];

                            that._fireEvent("data-loaded", {
                                source: o.source,
                                data: data
                            });

                            if (Array.isArray(o.head)) {
                                that.heads = o.head;
                            }

                            if (Array.isArray(o.body)) {
                                that.items = o.body;
                            }

                            that._createItemsFromJSON(data);
                            that._rebuild(review);
                            that._resetInspector();

                            that._fireEvent("data-load-end", {
                                source: o.source,
                                data: data
                            });
                        })
                        .catch(function(error){
                            that.activity.hide();
                            that._fireEvent("data-load-error", {
                                source: o.source,
                                error: error
                            });
                        })
                });

            }
        },

        reload: function(review){
            this.loadData(this.options.source, review);
        },

        clear: function(){
            this.items = [];
            return this.draw();
        },

        next: function(){
            if (this.items.length === 0) return ;
            this.currentPage++;
            if (this.currentPage > this.pagesCount) {
                this.currentPage = this.pagesCount;
                return ;
            }
            this._draw();
            return this;
        },

        prev: function(){
            if (this.items.length === 0) return ;
            this.currentPage--;
            if (this.currentPage === 0) {
                this.currentPage = 1;
                return ;
            }
            this._draw();
            return this;
        },

        first: function(){
            if (this.items.length === 0) return ;
            this.currentPage = 1;
            this._draw();
            return this;
        },

        last: function(){
            if (this.items.length === 0) return ;
            this.currentPage = this.pagesCount;
            this._draw();
            return this;
        },

        page: function(num){
            if (num <= 0) {
                num = 1;
            }

            if (num > this.pagesCount) {
                num = this.pagesCount;
            }

            this.currentPage = num;
            this._draw();
            return this;
        },

        addFilter: function(f, redraw){
            var filterIndex = null, i, func = Utils.isFunc(f);
            if (func === false) {
                return ;
            }

            for(i = 0; i < this.filters.length; i++) {
                if (Utils.isNull(this.filters[i])) {
                    filterIndex = i;
                    this.filters[i] = func;
                    break;
                }
            }

            if (Utils.isNull(filterIndex)) {
                this.filters.push(func);
                filterIndex = this.filters.length - 1;
            }

            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }

            return filterIndex
        },

        removeFilter: function(key, redraw){
            this.filters[key] = null;
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        removeFilters: function(redraw){
            this.filters = [];
            if (redraw === true) {
                this.currentPage = 1;
                this.draw();
            }
            return this;
        },

        getItems: function(){
            return this.items;
        },

        getHeads: function(){
            return this.heads;
        },

        getView: function(){
            return this.view;
        },

        getFilteredItems: function(){
            return this.filteredItems.length > 0 ? this.filteredItems : this.items;
        },

        getSelectedItems: function(){
            var element = this.element, o = this.options;
            var stored_keys = Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr("id")));
            var selected = [];

            if (!Utils.isValue(stored_keys)) {
                return [];
            }

            $.each(this.items, function(){
                if (stored_keys.indexOf(""+this[o.checkColIndex]) !== -1) {
                    selected.push(this);
                }
            });
            return selected;
        },

        getStoredKeys: function(){
            var element = this.element, o = this.options;
            return Metro.storage.getItem(o.checkStoreKey.replace("$1", element.attr("id")), []);
        },

        clearSelected: function(redraw){
            var element = this.element, o = this.options;
            Metro.storage.setItem(o.checkStoreKey.replace("$1", element.attr("id")), []);
            element.find("table-service-check-all input").prop("checked", false);
            if (redraw === true) this._draw();
        },

        getFilters: function(){
            return this.filters;
        },

        getFiltersIndexes: function(){
            return this.filtersIndexes;
        },

        openInspector: function(mode){
            var ins = this.inspector;
            if (mode) {
                ins.show(0, function(){
                    ins.css({
                        top: ($(window).height()  - ins.outerHeight(true)) / 2 + pageYOffset,
                        left: ($(window).width() - ins.outerWidth(true)) / 2 + pageXOffset
                    }).data("open", true);
                });
            } else {
                ins.hide().data("open", false);
            }
        },

        closeInspector: function(){
            this.openInspector(false);
        },

        toggleInspector: function(){
            this.openInspector(!this.inspector.data("open"));
        },

        resetView: function(){

            this.view = this._createView();

            this._createTableHeader();
            this._createTableFooter();
            this._draw();

            this._resetInspector();
            this._saveTableView();
        },

        rebuildIndex: function(){
            this._createIndex();
        },

        getIndex: function(){
            return this.index;
        },

        export: function(to, mode, filename, options){
            var Export = Metro.export;
            var that = this, o = this.options;
            var table = document.createElement("table");
            var head = $("<thead>").appendTo(table);
            var body = $("<tbody>").appendTo(table);
            var i, j, cells, tds = [], items, tr, td;
            var start, stop;

            if (typeof Export.tableToCSV !== 'function') {
                return ;
            }

            mode = Utils.isValue(mode) ? mode.toLowerCase() : "all-filtered";
            filename = Utils.isValue(filename) ? filename : Utils.elementId("table")+"-export.csv";

            // Create table header
            tr = $("<tr>");
            cells = this.heads;

            for (j = 0; j < cells.length; j++){
                tds[j] = null;
            }

            $.each(cells, function(cell_index){
                var item = this;
                if (Utils.bool(that.view[cell_index]['show']) === false) {
                    return ;
                }
                td = $("<th>");
                if (Utils.isValue(item.title)) {
                    td.html(item.title);
                }
                tds[that.view[cell_index]['index-view']] = td;
            });

            for (j = 0; j < cells.length; j++){
                if (Utils.isValue(tds[j])) tds[j].appendTo(tr);
            }
            tr.appendTo(head);

            // Create table data
            if (mode === "checked") {
                items = this.getSelectedItems();
                start = 0; stop = items.length - 1;
            } else if (mode === "view") {
                items = this._filter();
                start = parseInt(o.rows) === -1 ? 0 : o.rows * (this.currentPage - 1);
                stop = parseInt(o.rows) === -1 ? items.length - 1 : start + o.rows - 1;
            } else if (mode === "all") {
                items = this.items;
                start = 0; stop = items.length - 1;
            } else {
                items = this._filter();
                start = 0; stop = items.length - 1;
            }

            for (i = start; i <= stop; i++) {
                if (Utils.isValue(items[i])) {
                    tr = $("<tr>");

                    cells = items[i];

                    for (j = 0; j < cells.length; j++){
                        tds[j] = null;
                    }

                    $.each(cells, function(cell_index){
                        if (Utils.bool(that.view[cell_index].show) === false) {
                            return ;
                        }
                        td = $("<td>").html(this);
                        tds[that.view[cell_index]['index-view']] = td;
                    });

                    for (j = 0; j < cells.length; j++){
                        if (Utils.isValue(tds[j])) tds[j].appendTo(tr);
                    }

                    tr.appendTo(body);
                }
            }

            // switch (to) {
            //     default: Export.tableToCSV(table, filename, options);
            // }
            Export.tableToCSV(table, filename, options);
            table.remove();
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            function dataCheck(){
                o.check = Utils.bool(element.attr("data-check"));
                that._service();
                that._createTableHeader();
                that._draw();
            }

            function dataRownum(){
                o.rownum = Utils.bool(element.attr("data-rownum"));
                that._service();
                that._createTableHeader();
                that._draw();
            }

            switch (attributeName) {
                case "data-check": dataCheck(); break;
                case "data-rownum": dataRownum(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var component = element.closest(".table-component");
            var search_input = component.find("input");
            var rows_select = component.find("select");

            search_input.data("input").destroy();
            rows_select.data("select").destroy();

            $(window).off(Metro.events.resize, {ns: this.id});

            element.off(Metro.events.click, ".sortable-column");

            element.off(Metro.events.click, ".table-service-check input");

            element.off(Metro.events.click, ".table-service-check-all input");

            search_input.off(Metro.events.inputchange);

            if (Utils.isValue(this.wrapperSearch)) {
                var customSearch = this.wrapperSearch.find("input");
                if (customSearch.length > 0) {
                    customSearch.off(Metro.events.inputchange);
                }
            }

            component.off(Metro.events.click, ".pagination .page-link");
            if (Utils.isValue(this.wrapperPagination)) {
                this.wrapperPagination.off(Metro.events.click, ".pagination .page-link");
            }
            element.off(Metro.events.click, ".js-table-crud-button");

            this._removeInspectorEvents();

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var MaterialTabsDefaultConfig = {
        wheelStep: 20,
        materialtabsDeferred: 0,
        deep: false,
        fixedTabs: false,
        duration: 300,
        appBar: false,

        clsComponent: "",
        clsTabs: "",
        clsTab: "",
        clsTabActive: "",
        clsMarker: "",

        onBeforeTabOpen: Metro.noop_true,
        onTabOpen: Metro.noop,
        onTabsScroll: Metro.noop,
        onTabsCreate: Metro.noop
    };

    Metro.materialTabsSetup = function (options) {
        MaterialTabsDefaultConfig = $.extend({}, MaterialTabsDefaultConfig, options);
    };

    if (typeof window["metroMaterialTabsSetup"] !== undefined) {
        Metro.materialTabsSetup(window["metroMaterialTabsSetup"]);
    }

    Metro.Component('material-tabs', {
        init: function( options, elem ) {
            this._super(elem, options, MaterialTabsDefaultConfig, {
                marker: null,
                scroll: 0,
                scrollDir: "left"
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("tabs-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var tabs = element.find("li"), active_tab = element.find("li.active");
            var wrapper = $("<div>").addClass("tabs-material-wrapper").addClass(o.clsComponent).insertBefore(element);

            if (o.appBar === true) {
                wrapper.addClass("app-bar-present");
            }
            if (o.appBar === "more") {
                wrapper.addClass("app-bar-present-more");
            }

            element.appendTo(wrapper);
            element.addClass("tabs-material").addClass(o.clsTabs);
            tabs.addClass(o.clsTab);

            if (o.deep === true) {
                element.addClass("deep");
            }

            if (o.fixedTabs === true) {
                element.addClass("fixed-tabs");
            }

            this.marker = element.find(".tab-marker");

            if (this.marker.length === 0) {
                this.marker = $("<span>").addClass("tab-marker").addClass(o.clsMarker).appendTo(element);
            }

            this.openTab(active_tab.length === 0 ? tabs[0] : active_tab[0]);
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.click, "li", function(e){
                var tab = $(this);
                var active_tab = element.find("li.active");
                var tab_next = tab.index() > active_tab.index();
                var target = tab.children("a").attr("href");

                e.preventDefault();

                if (Utils.isValue(target) && target[0] === "#") {
                    if (tab.hasClass("active")) return;
                    if (tab.hasClass("disabled")) return;
                    if (Utils.exec(o.onBeforeTabOpen, [tab, target, tab_next], this) === false) return;
                    that.openTab(tab, tab_next);
                }
            });

            element.on(Metro.events.scroll, function(){
                var oldScroll = that.scroll;

                that.scrollDir = that.scroll < element[0].scrollLeft ? "left" : "right";
                that.scroll = element[0].scrollLeft;

                that._fireEvent("tabs-scroll", {
                    scrollLeft: element[0].scrollLeft,
                    oldScroll: oldScroll,
                    scrollDir: that.scrollDir
                });

            });

            element.on(Metro.events.mousewheel, function(e){
                if (e.deltaY === undefined) {
                    return ;
                }

                var scroll, scrollable = $(this);
                var dir = e.deltaY > 0 ? -1 : 1;
                var step = o.wheelStep;


                scroll = scrollable.scrollLeft() - ( dir * step);
                scrollable.scrollLeft(scroll);
            })
        },

        openTab: function(tab, tab_next){
            var element = this.element, o = this.options;
            var tabs = element.find("li");
            var magic = 52, shift, width, tab_width, target, tab_left, scroll, scrollLeft;

            tab = $(tab);

            $.each(tabs, function(){
                var target = $(this).find("a").attr("href");
                if (!Utils.isValue(target)) return;
                if (target[0] === "#" && target.length > 1) {
                    $(target).hide();
                }
            });

            width = element.width();
            scroll = element.scrollLeft();
            tab_left = tab.position().left;
            tab_width = tab.width();
            shift = tab_left + tab_width;

            tabs.removeClass("active").removeClass(o.clsTabActive);
            tab.addClass("active").addClass(o.clsTabActive);

            if (shift + magic > width + scroll) {
                scrollLeft = scroll + (magic * 2);
            } else if (tab_left < scroll) {
                scrollLeft = tab_left - magic * 2;
            } else {
                scrollLeft = scroll;
            }

            element.animate({
                draw: {
                    scrollLeft: scrollLeft
                },
                dur: o.duration
            });

            this.marker.animate({
                draw: {
                    left: tab_left,
                    width: tab_width
                },
                dur: o.duration
            });

            target = tab.find("a").attr("href");
            if (Utils.isValue(target)) {
                if (target[0] === "#" && target.length > 1) {
                    $(target).show();
                }
            }

            this._fireEvent("tab-open", {
                tab: tab[0],
                target: target,
                tab_next: tab_next
            });
        },

        open: function(tab_num){
            var element = this.element;
            var tabs = element.find("li");
            var active_tab = element.find("li.active");
            var tab = tabs.eq(tab_num - 1);
            var tab_next = tabs.index(tab) > tabs.index(active_tab);
            this.openTab(tab, tab_next);
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, "li");
            element.off(Metro.events.scroll);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var TabsDefaultConfig = {
        tabsDeferred: 0,
        expand: false,
        expandPoint: null,
        tabsPosition: "top",
        tabsType: "default",

        clsTabs: "",
        clsTabsList: "",
        clsTabsListItem: "",
        clsTabsListItemActive: "",

        onTab: Metro.noop,
        onBeforeTab: Metro.noop_true,
        onTabsCreate: Metro.noop
    };

    Metro.tabsSetup = function (options) {
        TabsDefaultConfig = $.extend({}, TabsDefaultConfig, options);
    };

    if (typeof window["metroTabsSetup"] !== undefined) {
        Metro.tabsSetup(window["metroTabsSetup"]);
    }

    Metro.Component('tabs', {
        init: function( options, elem ) {
            this._super(elem, options, TabsDefaultConfig, {
                _targets: [],
                id: Utils.elementId('tabs')
            });

            return this;
        },

        _create: function(){
            var element = this.element;
            var tab = element.find(".active").length > 0 ? $(element.find(".active")[0]) : undefined;

            this._createStructure();
            this._createEvents();
            this._open(tab);

            this._fireEvent("tabs-create", {
                element: element
            });
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var parent = element.parent();
            var right_parent = parent.hasClass("tabs");
            var container = right_parent ? parent : $("<div>").addClass("tabs tabs-wrapper");
            var expandTitle, hamburger;

            container.addClass(o.tabsPosition.replace(["-", "_", "+"], " "));

            element.addClass("tabs-list");
            if (o.tabsType !== "default") {
                element.addClass("tabs-"+o.tabsType);
            }
            if (!right_parent) {
                container.insertBefore(element);
                element.appendTo(container);
            }

            element.data('expanded', false);

            expandTitle = $("<div>").addClass("expand-title"); container.prepend(expandTitle);
            hamburger = container.find(".hamburger");
            if (hamburger.length === 0) {
                hamburger = $("<button>").attr("type", "button").addClass("hamburger menu-down").appendTo(container);
                for(var i = 0; i < 3; i++) {
                    $("<span>").addClass("line").appendTo(hamburger);
                }

                if (Metro.colors.isLight(Utils.getStyleOne(container, "background-color")) === true) {
                    hamburger.addClass("dark");
                }
            }

            container.addClass(o.clsTabs);
            element.addClass(o.clsTabsList);
            element.children("li").addClass(o.clsTabsListItem);

            if (o.expand === true && !o.tabsPosition.includes("vertical")) {
                container.addClass("tabs-expand");
            } else {
                if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint) && !o.tabsPosition.includes("vertical")) {
                    container.addClass("tabs-expand");
                }
            }

            if (o.tabsPosition.includes("vertical")) {
                container.addClass("tabs-expand");
            }

        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.parent();

            $(window).on(Metro.events.resize, function(){

                if (o.tabsPosition.includes("vertical")) {
                    return ;
                }

                if (o.expand === true && !o.tabsPosition.includes("vertical")) {
                    container.addClass("tabs-expand");
                } else {
                    if (Utils.isValue(o.expandPoint) && Utils.mediaExist(o.expandPoint) && !o.tabsPosition.includes("vertical")) {
                        if (!container.hasClass("tabs-expand")) container.addClass("tabs-expand");
                    } else {
                        if (container.hasClass("tabs-expand")) container.removeClass("tabs-expand");
                    }
                }
            }, {ns: this.id});

            container.on(Metro.events.click, ".hamburger, .expand-title", function(){
                if (element.data('expanded') === false) {
                    element.addClass("expand");
                    element.data('expanded', true);
                    container.find(".hamburger").addClass("active");
                } else {
                    element.removeClass("expand");
                    element.data('expanded', false);
                    container.find(".hamburger").removeClass("active");
                }
            });

            element.on(Metro.events.click, "a", function(e){
                var link = $(this);
                var href = link.attr("href").trim();
                var tab = link.parent("li");

                if (tab.hasClass("active")) {
                    e.preventDefault();
                }

                if (element.data('expanded') === true) {
                    element.removeClass("expand");
                    element.data('expanded', false);
                    container.find(".hamburger").removeClass("active");
                }

                if (Utils.exec(o.onBeforeTab, [tab, element], tab[0]) !== true) {
                    return false;
                }

                if (Utils.isValue(href) && href[0] === "#") {
                    that._open(tab);
                    e.preventDefault();
                }
            });
        },

        _collectTargets: function(){
            var that = this, element = this.element;
            var tabs = element.find("li");

            this._targets = [];

            $.each(tabs, function(){
                var target = $(this).find("a").attr("href").trim();
                if (target.length > 1 && target[0] === "#") {
                    that._targets.push(target);
                }
            });
        },

        _open: function(tab){
            var element = this.element, o = this.options;
            var tabs = element.find("li");
            var expandTitle = element.siblings(".expand-title");


            if (tabs.length === 0) {
                return;
            }

            this._collectTargets();

            if (tab === undefined) {
                tab = $(tabs[0]);
            }

            var target = tab.find("a").attr("href");

            if (target === undefined) {
                return;
            }

            tabs.removeClass("active").removeClass(o.clsTabsListItemActive);
            if (tab.parent().hasClass("d-menu")) {
                tab.parent().parent().addClass("active");
            } else {
                tab.addClass("active");
            }

            $.each(this._targets, function(){
                var t = $(this);
                if (t.length > 0) t.hide();
            });

            if (target !== "#" && target[0] === "#") {
                $(target).show();
            }

            expandTitle.html(tab.find("a").html());

            tab.addClass(o.clsTabsListItemActive);

            this._fireEvent("tab", {
                tab: tab[0]
            });
        },

        next: function(){
            var element = this.element;
            var next, active_tab = element.find("li.active");

            next = active_tab.next("li");
            if (next.length > 0) {
                this._open(next);
            }
        },

        prev: function(){
            var element = this.element;
            var next, active_tab = element.find("li.active");

            next = active_tab.prev("li");
            if (next.length > 0) {
                this._open(next);
            }
        },

        open: function(tab){
            var element = this.element;
            var tabs = element.find("li");

            if (!Utils.isValue(tab)) {
                tab = 1;
            }

            if (Utils.isInt(tab)) {
                if (Utils.isValue(tabs[tab-1])) this._open($(tabs[tab-1]));
            } else {
                this._open($(tab));
            }
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;
            var container = element.parent();

            $(window).off(Metro.events.resize,{ns: this.id});

            container.off(Metro.events.click, ".hamburger, .expand-title");

            element.off(Metro.events.click, "a");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var TagInputDefaultConfig = {
        autocomplete: null,
        autocompleteUnique: true,
        autocompleteUrl: null,
        autocompleteUrlMethod: "GET",
        autocompleteUrlKey: null,
        autocompleteDivider: ",",
        autocompleteListHeight: 200,

        label: "",
        size: "normal",
        taginputDeferred: 0,
        static: false,
        clearButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",

        randomColor: false,
        maxTags: 0,
        tagSeparator: ",",
        tagTrigger: "Enter, Space, Comma",
        backspace: true,

        clsComponent: "",
        clsInput: "",
        clsClearButton: "",
        clsTag: "",
        clsTagTitle: "",
        clsTagRemover: "",
        clsLabel: "",

        onBeforeTagAdd: Metro.noop_true,
        onTagAdd: Metro.noop,
        onBeforeTagRemove: Metro.noop_true,
        onTagRemove: Metro.noop,
        onTag: Metro.noop,
        onClear: Metro.noop,
        onTagTrigger: Metro.noop,
        onTagInputCreate: Metro.noop
    };

    Metro.tagInputSetup = function (options) {
        TagInputDefaultConfig = $.extend({}, TagInputDefaultConfig, options);
    };

    if (typeof window["metroTagInputSetup"] !== undefined) {
        Metro.tagInputSetup(window["metroTagInputSetup"]);
    }

    Metro.Component('tag-input', {
        init: function( options, elem ) {
            this._super(elem, options, TagInputDefaultConfig, {
                values: [],
                triggers: [],
                autocomplete: []
            });

            return this;
        },

        _create: function(){
            this.triggers = (""+this.options.tagTrigger).toArray(",");

            if (this.triggers.includes("Space") || this.triggers.includes("Spacebar")) {
                this.triggers.push(" ");
                this.triggers.push("Spacebar");
            }

            if (this.triggers.includes("Comma")) {
                this.triggers.push(",");
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("tag-input-create", {
                element: this.element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var container, input, clearButton;
            var values = element.val().trim();

            container = $("<div>").addClass("tag-input "  + element[0].className).addClass(o.clsComponent).insertBefore(element);
            element.appendTo(container);

            container.addClass("input-" + o.size)

            element[0].className = "";

            element.addClass("original-input");
            input = $("<input type='text'>").addClass("input-wrapper").addClass(o.clsInput).attr("size", 1);
            input.appendTo(container);

            if (o.clearButton !== false && !element[0].readOnly) {
                container.addClass("padding-for-clear");
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(container);
            }

            if (Utils.isValue(values)) {
                $.each(values.toArray(o.tagSeparator), function(){
                    that._addTag(this);
                })
            }

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(":disabled")) {
                this.disable();
            } else {
                this.enable();
            }

            if (o.static === true || element.attr("readonly") !== undefined) {
                container.addClass("static-mode");
            }

            if (!Utils.isNull(o.autocomplete) || !Utils.isNull(o.autocompleteUrl)) {
                $("<div>").addClass("autocomplete-list").css({
                    maxHeight: o.autocompleteListHeight,
                    display: "none"
                }).appendTo(container);
            }

            if (Utils.isValue(o.autocomplete)) {
                var autocomplete_obj = Utils.isObject(o.autocomplete);

                if (autocomplete_obj !== false) {
                    this.autocomplete = autocomplete_obj;
                } else {
                    this.autocomplete = o.autocomplete.toArray(o.autocompleteDivider);
                }
            }

            if (Utils.isValue(o.autocompleteUrl)) {
                fetch(o.autocompleteUrl, {
                    method: o.autocompleteUrlMethod
                }).then(function(response){
                    return response.text()
                }).then(function(data){
                    var newData = [];

                    try {
                        newData = JSON.parse(data);
                        if (o.autocompleteUrlKey) {
                            newData = newData[o.autocompleteUrlKey];
                        }
                    } catch (e) {
                        newData = data.split("\n");
                    }

                    that.autocomplete = that.autocomplete.concat(newData);
                });
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");
            var autocompleteList = container.find(".autocomplete-list");

            input.on(Metro.events.focus, function(){
                container.addClass("focused");
            });

            input.on(Metro.events.blur, function(){
                container.removeClass("focused");
            });

            input.on(Metro.events.inputchange, function(){
                input.attr("size", Math.ceil(input.val().length / 2) + 2);
            });

            input.on(Metro.events.keydown, function(e){
                var val = input.val().trim();
                var key = e.key;

                if (key === "Enter") e.preventDefault();

                if (o.backspace === true && key === "Backspace" && val.length === 0) {
                    if (that.values.length > 0) {
                        that.values.splice(-1,1);
                        element.siblings(".tag").last().remove();
                        element.val(that.values.join(o.tagSeparator));
                    }
                    return ;
                }

                if (val === "") {return ;}

                if (!that.triggers.includes(key)) {
                    return ;
                }

                that._fireEvent("tag-trigger", {
                    key: key
                });

                input.val("");
                that._addTag(val);
                input.attr("size", 1);
            });

            input.on(Metro.events.keyup, function(e){
                var val = input.val();
                var key = e.key;

                if (that.triggers.includes(key) && val[val.length - 1] === key) {
                    input.val(val.slice(0, -1));
                }
            });

            container.on(Metro.events.click, ".tag .remover", function(){
                var tag = $(this).closest(".tag");
                that._delTag(tag);
            });

            container.on(Metro.events.click, function(){
                input.focus();
            });

            container.on(Metro.events.click, ".input-clear-button", function(){
                var val = element.val();
                that.clear();

                that._fireEvent("clear", {
                    val: val
                });
            });

            input.on(Metro.events.input, function(){
                var val = this.value.toLowerCase();
                that._drawAutocompleteList(val);
            });

            container.on(Metro.events.click, ".autocomplete-list .item", function(){
                var val = $(this).attr("data-autocomplete-value");

                input.val("");
                that._addTag(val);
                input.attr("size", 1);

                autocompleteList.css({
                    display: "none"
                });
                that._fireEvent("autocomplete-select", {
                    value: val
                });
            });
        },

        _drawAutocompleteList: function(val){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");
            var autocompleteList = container.find(".autocomplete-list");
            var items;

            if (autocompleteList.length === 0) {
                return;
            }

            autocompleteList.html("");

            items = this.autocomplete.filter(function(item){
                return item.toLowerCase().indexOf(val) > -1;
            });

            autocompleteList.css({
                display: items.length > 0 ? "block" : "none",
                left: input.position().left
            });

            $.each(items, function(){
                if (o.autocompleteUnique && that.values.indexOf(this) !== -1) {
                    return ;
                }

                var v = this;
                var index = v.toLowerCase().indexOf(val), content;
                var item = $("<div>").addClass("item").attr("data-autocomplete-value", v);

                if (index === 0) {
                    content = "<strong>"+v.substr(0, val.length)+"</strong>"+v.substr(val.length);
                } else {
                    content = v.substr(0, index) + "<strong>"+v.substr(index, val.length)+"</strong>"+v.substr(index + val.length);
                }

                item.html(content).appendTo(autocompleteList);

                that._fireEvent("draw-autocomplete-item", {
                    item: item
                })
            });
        },

        _addTag: function(val){
            var element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");
            var tag, title, remover;
            var tagSize, tagStatic;

            if (container.hasClass("input-large")) {
                tagSize = "large";
            } else if (container.hasClass("input-small")) {
                tagSize = "small"
            }

            if (o.maxTags > 0 && this.values.length === o.maxTags) {
                return ;
            }

            if ((""+val).trim() === "") {
                return ;
            }

            if (!Utils.exec(o.onBeforeTagAdd, [val, this.values], element[0])) {
                return ;
            }


            tag = $("<span>")
                .addClass("tag")
                .addClass(tagSize)
                .addClass(o.clsTag)
                .insertBefore(input);
            tag.data("value", val);

            tagStatic = o.static || container.hasClass("static-mode") || element.readonly || element.disabled || container.hasClass("disabled");
            if (tagStatic) {
                tag.addClass("static");
            }

            title = $("<span>").addClass("title").addClass(o.clsTagTitle).html(val);
            remover = $("<span>").addClass("remover").addClass(o.clsTagRemover).html("&times;");

            title.appendTo(tag);
            remover.appendTo(tag);

            if (o.randomColor === true) {
                var colors = Metro.colors.colors(Metro.colors.PALETTES.ALL), bg, fg, bg_r;

                bg = colors[$.random(0, colors.length - 1)];
                bg_r = Metro.colors.darken(bg, 15);
                fg = Metro.colors.isDark(bg) ? "#ffffff" : "#000000";

                tag.css({
                    backgroundColor: bg,
                    color: fg
                });
                remover.css({
                    backgroundColor: bg_r,
                    color: fg
                });
            }

            this.values.push(val);
            element.val(this.values.join(o.tagSeparator));

            this._fireEvent("tag-add", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            this._fireEvent("tag", {
                tag: tag[0],
                val: val,
                values: this.values
            });
        },

        _delTag: function(tag) {
            var element = this.element, o = this.options;
            var val = tag.data("value");

            if (!Utils.exec(o.onBeforeTagRemove, [tag, val, this.values], element[0])) {
                return ;
            }

            Utils.arrayDelete(this.values, val);
            element.val(this.values.join(o.tagSeparator));

            this._fireEvent("tag-remove", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            this._fireEvent("tag", {
                tag: tag[0],
                val: val,
                values: this.values
            });

            tag.remove();
        },

        tags: function(){
            return this.values;
        },

        val: function(v){
            var that = this, element = this.element, o = this.options;
            var container = element.closest(".tag-input");
            var newValues = [];

            if (!Utils.isValue(v)) {
                return this.tags();
            }

            this.values = [];
            container.find(".tag").remove();

            if (typeof v === "string") {
                newValues = (""+v).toArray(o.tagSeparator);
            } else {
                if (Array.isArray(v)) {
                    newValues = v;
                }
            }

            $.each(newValues, function(){
                that._addTag(this);
            });

            return this;
        },

        append: function(v){
            var that = this, o = this.options;
            var newValues = this.values;

            if (typeof v === "string") {
                newValues = (""+v).toArray(o.tagSeparator);
            } else {
                if (Array.isArray(v)) {
                    newValues = v;
                }
            }

            $.each(newValues, function(){
                that._addTag(this);
            });

            return this;
        },

        clear: function(){
            var element = this.element;
            var container = element.closest(".tag-input");

            this.values = [];

            element.val("").trigger("change");

            container.find(".tag").remove();

            return this;
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        toggleStatic: function(val){
            var container = this.element.closest(".tag-input");
            var staticMode;

            if (Utils.isValue(val)) {
                staticMode = Utils.bool(val);
            } else {
                staticMode = !container.hasClass("static-mode");
            }

            if (staticMode) {
                container.addClass("static-mode");
            } else {
                container.removeClass("static-mode");
            }
        },

        setAutocompleteList: function(l){
            var autocomplete_list = Utils.isObject(l);
            if (autocomplete_list !== false) {
                this.autocomplete = autocomplete_list;
            } else if (typeof l === "string") {
                this.autocomplete = l.toArray(this.options.autocompleteDivider);
            }
        },

        changeAttribute: function(attributeName){
            var that = this, element = this.element, o = this.options;

            var changeValue = function(){
                var val = element.attr("value").trim();
                that.clear();
                if (!Utils.isValue(val)) {
                    return ;
                }
                that.val(val.toArray(o.tagSeparator));
            };

            switch (attributeName) {
                case "value": changeValue(); break;
                case "disabled": this.toggleState(); break;
                case "static": this.toggleStatic(); break;
            }
        },

        destroy: function(){
            var element = this.element;
            var container = element.closest(".tag-input");
            var input = container.find(".input-wrapper");

            input.off(Metro.events.focus);
            input.off(Metro.events.blur);
            input.off(Metro.events.keydown);
            container.off(Metro.events.click, ".tag .remover");
            container.off(Metro.events.click);

            return element;
        }
    });

    $(document).on(Metro.events.click, function(){
        $('.tag-input .autocomplete-list').hide();
    });

}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;

    var Engine = function(html, options, conf) {
        var ReEx, re = '<%(.+?)%>',
            reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,
            code = 'with(obj) { var r=[];\n',
            cursor = 0,
            result,
            match;
        var add = function(line, js) {
            /* jshint -W030 */
            js? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
                (code += line !== '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
            return add;
        };

        if (Utils.isValue(conf)) {
            if (($.hasProp(conf, 'beginToken'))) {
                re = re.replace('<%', conf.beginToken);
            }
            if (($.hasProp(conf,'endToken'))) {
                re = re.replace('%>', conf.endToken);
            }
        }

        ReEx = new RegExp(re, 'g');
        match = ReEx.exec(html);

        while(match) {
            add(html.slice(cursor, match.index))(match[1], true);
            cursor = match.index + match[0].length;
            match = ReEx.exec(html);
        }
        add(html.substr(cursor, html.length - cursor));
        code = (code + 'return r.join(""); }').replace(/[\r\t\n]/g, ' ');
        /* jshint -W054 */
        try { result = new Function('obj', code).apply(options, [options]); }
        catch(err) { console.error("'" + err.message + "'", " in \n\nCode:\n", code, "\n"); }
        return result;
    };

    var TemplateDefaultConfig = {
        templateData: null,
        onTemplateCompile: Metro.noop,
        onTemplateCreate: Metro.noop
    };

    Metro.templateSetup = function (options) {
        TemplateDefaultConfig = $.extend({}, TemplateDefaultConfig, options);
    };

    if (typeof window["metroTemplateSetup"] !== undefined) {
        Metro.templateSetup(window["metroTemplateSetup"]);
    }

    Metro.Component('template', {
        init: function( options, elem ) {
            this._super(elem, options, TemplateDefaultConfig, {
                template: null,
                data: {}
            });
            return this;
        },

        _compile: function(){
            var element = this.element;
            var template, compiled;

            template = this.template
                .replace(/(&lt;%)/gm, "<%")
                .replace(/(%&gt;)/gm, "%>")
                .replace(/(&lt;)/gm, "<")
                .replace(/(&gt;)/gm, ">");

            compiled = Engine(template, this.data);
            element.html(compiled);

            this._fireEvent('template-compile', {
                template: template,
                compiled: compiled,
                element: element
            });
        },

        _create: function(){
            var element = this.element, o = this.options;
            this.template = element.html();
            this.data = Utils.isObject(o.templateData) || {};
            this._compile();
            this._fireEvent('template-create', {
                element: element
            });
        },

        buildWith: function(obj){
            var data = Utils.isObject(obj);
            if (!data) {
                return;
            }
            this.data = data;
            this._compile();
        },

        changeAttribute: function(a, v){
            if (a === "data-template-data") {
                this.options.templateData = v;
                this.data = Utils.isObject(v) || {};
                this._compile();
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro.template = Engine;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TextareaDefaultConfig = {
        label: "",
        textareaDeferred: 0,
        charsCounter: null,
        charsCounterTemplate: "$1",
        defaultValue: "",
        prepend: "",
        append: "",
        copyInlineStyles: false,
        clearButton: true,
        clearButtonIcon: "<span class='default-icon-cross'></span>",
        autoSize: true,
        maxHeight: 0,
        clsPrepend: "",
        clsAppend: "",
        clsComponent: "",
        clsTextarea: "",
        clsLabel: "",
        onChange: Metro.noop,
        onTextareaCreate: Metro.noop
    };

    Metro.textareaSetup = function (options) {
        TextareaDefaultConfig = $.extend({}, TextareaDefaultConfig, options);
    };

    if (typeof window["metroTextareaSetup"] !== undefined) {
        Metro.textareaSetup(window["metroTextareaSetup"]);
    }

    Metro.Component('textarea', {
        init: function( options, elem ) {
            this._super(elem, options, TextareaDefaultConfig);
            return this;
        },

        _create: function(){
            var element = this.element;

            this._createStructure();
            this._createEvents();

            this._fireEvent("textarea-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, elem = this.elem, o = this.options;
            var container = $("<div>").addClass("textarea " + element[0].className);
            var fakeTextarea = $("<textarea>").addClass("fake-textarea");
            var clearButton;

            container.insertBefore(element);
            element.appendTo(container);
            fakeTextarea.appendTo(container);

            if (o.clearButton !== false && !element[0].readOnly) {
                clearButton = $("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o.clearButtonIcon);
                clearButton.appendTo(container);
            }

            if (element.attr('dir') === 'rtl' ) {
                container.addClass("rtl").attr("dir", "rtl");
            }

            if (o.prepend !== "") {
                var prepend = $("<div>").html(o.prepend);
                prepend.addClass("prepend").addClass(o.clsPrepend).appendTo(container);
            }

            if (o.append !== "") {
                var append = $("<div>").html(o.append);
                append.addClass("append").addClass(o.clsAppend).appendTo(container);
                clearButton.css({
                    right: append.outerWidth() + 4
                });
            }

            elem.className = '';
            if (o.copyInlineStyles === true) {
                for (var i = 0, l = elem.style.length; i < l; i++) {
                    container.css(elem.style[i], element.css(elem.style[i]));
                }
            }

            if (Utils.isValue(o.defaultValue) && element.val().trim() === "") {
                element.val(o.defaultValue);
            }

            container.addClass(o.clsComponent);
            element.addClass(o.clsTextarea);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(container);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            if (element.is(':disabled')) {
                this.disable();
            } else {
                this.enable();
            }

            fakeTextarea.val(element.val());

            if (o.autoSize === true) {
                container.addClass("autosize no-scroll-vertical");

                setTimeout(function(){
                    that.resize();
                }, 100);
            }
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;
            var textarea = element.closest(".textarea");
            var fakeTextarea = textarea.find(".fake-textarea");
            var chars_counter = $(o.charsCounter);

            textarea.on(Metro.events.click, ".input-clear-button", function(){
                element.val(Utils.isValue(o.defaultValue) ? o.defaultValue : "").trigger('change').trigger('keyup').focus();
            });

            if (o.autoSize) {
                element.on(Metro.events.inputchange + " " + Metro.events.keyup, function(){
                    fakeTextarea.val(this.value);
                    that.resize();
                });
            }

            element.on(Metro.events.blur, function(){textarea.removeClass("focused");});
            element.on(Metro.events.focus, function(){textarea.addClass("focused");});

            element.on(Metro.events.keyup, function(){
                if (Utils.isValue(o.charsCounter) && chars_counter.length > 0) {
                    if (chars_counter[0].tagName === "INPUT") {
                        chars_counter.val(that.length());
                    } else {
                        chars_counter.html(o.charsCounterTemplate.replace("$1", that.length()));
                    }
                }

                that._fireEvent("change", {
                    val: element.val(),
                    length: that.length()
                });

            })
        },

        resize: function(){
            var element = this.element, o = this.options,
                textarea = element.closest(".textarea"),
                fakeTextarea = textarea.find(".fake-textarea"),
                currentHeight = fakeTextarea[0].scrollHeight;

            if (o.maxHeight && currentHeight >= o.maxHeight) {
                textarea.removeClass("no-scroll-vertical");
                return ;
            }

            if (o.maxHeight && currentHeight < o.maxHeight) {
                textarea.addClass("no-scroll-vertical");
            }

            fakeTextarea[0].style.cssText = 'height:auto;';
            fakeTextarea[0].style.cssText = 'height:' + fakeTextarea[0].scrollHeight + 'px';
            element[0].style.cssText = 'height:' + fakeTextarea[0].scrollHeight + 'px';
        },

        clear: function(){
            this.element.val("").trigger('change').trigger('keyup').focus();
        },

        toDefault: function(){
            this.element.val(Utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "").trigger('change').trigger('keyup').focus();
        },

        length: function(){
            var characters = this.elem.value.split('');
            return characters.length;
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case 'disabled': this.toggleState(); break;
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;
            var textarea = element.closest(".textarea");

            textarea.off(Metro.events.click, ".input-clear-button");

            if (o.autoSize) {
                element.off(Metro.events.inputchange + " " + Metro.events.keyup);
            }

            element.off(Metro.events.blur);
            element.off(Metro.events.focus);

            element.off(Metro.events.keyup);

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var effects = [
        "slide-up", "slide-down", "slide-left", "slide-right", "fade", "zoom", "swirl", "switch"
    ];
    var TileDefaultConfig = {
        tileDeferred: 0,
        size: "medium",
        cover: "",
        coverPosition: "center",
        effect: "", // slide-up, slide-down, slide-left, slide-right, fade, zoom, swirl, switch
        effectInterval: 3000,
        effectDuration: 500,
        target: null,
        canTransform: true,
        onTileClick: Metro.noop,
        onTileCreate: Metro.noop
    };

    Metro.tileSetup = function (options) {
        TileDefaultConfig = $.extend({}, TileDefaultConfig, options);
    };

    if (typeof window["metroTileSetup"] !== undefined) {
        Metro.tileSetup(window["metroTileSetup"]);
    }

    Metro.Component('tile', {
        init: function( options, elem ) {
            this._super(elem, options, TileDefaultConfig, {
                effectInterval: false,
                images: [],
                slides: [],
                currentSlide: -1,
                unload: false
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createTile();
            this._createEvents();

            this._fireEvent("tile-create", {
                element: element
            });
        },

        _createTile: function(){
            function switchImage(el, img_src, i){
                $.setTimeout(function(){
                    el.fadeOut(500, function(){
                        el.css("background-image", "url(" + img_src + ")");
                        el.fadeIn();
                    });
                }, i * 300);
            }

            var that = this, element = this.element, o = this.options;
            var slides = element.find(".slide");
            var slides2 = element.find(".slide-front, .slide-back");

            element.addClass("tile-" + o.size);

            if (o.effect.indexOf("hover-") > -1) {
                element.addClass("effect-" + o.effect);
                $.each(slides2, function(){
                    var slide = $(this);

                    if (slide.data("cover") !== undefined) {
                        that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
                    }
                })
            }

            if (effects.includes(o.effect) && slides.length > 1) {
                $.each(slides, function(i){
                    var slide = $(this);

                    that.slides.push(this);

                    if (slide.data("cover") !== undefined) {
                        that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
                    }

                    if (i > 0) {
                        if (["slide-up", "slide-down"].indexOf(o.effect) > -1) slide.css("top", "100%");
                        if (["slide-left", "slide-right"].indexOf(o.effect) > -1) slide.css("left", "100%");
                        if (["fade", "zoom", "swirl", "switch"].indexOf(o.effect) > -1) slide.css("opacity", 0);
                    }
                });

                this.currentSlide = 0;

                this._runEffects();
            }

            if (o.cover !== "") {
                this._setCover(element, o.cover);
            }

            if (o.effect === "image-set") {
                element.addClass("image-set");

                $.each(element.children("img"), function(){
                    that.images.push(this);
                    $(this).remove();
                });

                var temp = this.images.slice();

                for(var i = 0; i < 5; i++) {
                    var rnd_index = $.random(0, temp.length - 1);
                    var div = $("<div>").addClass("img -js-img-"+i).css("background-image", "url("+temp[rnd_index].src+")");
                    element.prepend(div);
                    temp.splice(rnd_index, 1);
                }

                var a = [0, 1, 4, 3, 2];

                $.setInterval(function(){
                    var temp = that.images.slice();
                    var bg = Metro.colors.random();

                    element.css("background-color", bg);

                    for(var i = 0; i < a.length; i++) {
                        var rnd_index = $.random(0, temp.length - 1);
                        var div = element.find(".-js-img-"+a[i]);
                        switchImage(div, temp[rnd_index].src, i);
                        temp.splice(rnd_index, 1);
                    }

                    a = a.reverse();
                }, 5000);
            }
        },

        _runEffects: function(){
            var that = this, o = this.options;

            if (this.effectInterval === false) this.effectInterval = $.setInterval(function(){
                var current, next;

                current = $(that.slides[that.currentSlide]);

                that.currentSlide++;
                if (that.currentSlide === that.slides.length) {
                    that.currentSlide = 0;
                }

                next = that.slides[that.currentSlide];

                if (effects.includes(o.effect)) {
                    Metro.animations[Cake.camelCase(o.effect)]($(current), $(next), {duration: o.effectDuration});
                }

            }, o.effectInterval);
        },

        _stopEffects: function(){
            $.clearInterval(this.effectInterval);
            this.effectInterval = false;
        },

        _setCover: function(to, src, pos){
            if (!Utils.isValue(pos)) {
                pos = this.options.coverPosition;
            }
            to.css({
                backgroundImage: "url("+src+")",
                backgroundSize: "cover",
                backgroundRepeat: "no-repeat",
                backgroundPosition: pos
            });
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options;

            element.on(Metro.events.startAll, function(e){
                var tile = $(this);
                var dim = {w: element.width(), h: element.height()};
                var X = Utils.pageXY(e).x - tile.offset().left,
                    Y = Utils.pageXY(e).y - tile.offset().top;
                var side;

                if (Utils.isRightMouse(e) === false) {

                    if (X < dim.w * 1 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                        side = 'left';
                    } else if (X > dim.w * 2 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                        side = 'right';
                    } else if (X > dim.w * 1 / 3 && X < dim.w * 2 / 3 && Y > dim.h / 2) {
                        side = 'bottom';
                    } else {
                        side = "top";
                    }

                    if (o.canTransform === true) tile.addClass("transform-" + side);

                    if (o.target !== null) {
                        setTimeout(function(){
                            document.location.href = o.target;
                        }, 100);
                    }

                    that._fireEvent("tile-click", {
                        side: side
                    });
                }
            });

            element.on([Metro.events.stopAll, Metro.events.leave].join(" "), function(){
                $(this)
                    .removeClass("transform-left")
                    .removeClass("transform-right")
                    .removeClass("transform-top")
                    .removeClass("transform-bottom");
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.startAll);

            element.off([Metro.events.stopAll, Metro.events.leave].join(" "));

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TimePickerDefaultConfig = {
        label: "",
        timepickerDeferred: 0,
        hoursStep: 1,
        minutesStep: 1,
        secondsStep: 1,
        value: null,
        locale: METRO_LOCALE,
        distance: 3,
        hours: true,
        minutes: true,
        seconds: true,
        showLabels: true,
        scrollSpeed: 4,
        copyInlineStyles: false,
        clsPicker: "",
        clsPart: "",
        clsHours: "",
        clsMinutes: "",
        clsSeconds: "",
        clsLabel: "",
        clsButton: "",
        clsOkButton: "",
        clsCancelButton: "",
        okButtonIcon: "<span class='default-icon-check'></span>",
        cancelButtonIcon: "<span class='default-icon-cross'></span>",
        onSet: Metro.noop,
        onOpen: Metro.noop,
        onClose: Metro.noop,
        onScroll: Metro.noop,
        onTimePickerCreate: Metro.noop
    };

    Metro.timePickerSetup = function (options) {
        TimePickerDefaultConfig = $.extend({}, TimePickerDefaultConfig, options);
    };

    if (typeof window["metroTimePickerSetup"] !== undefined) {
        Metro.timePickerSetup(window["metroTimePickerSetup"]);
    }

    Metro.Component('time-picker', {
        init: function( options, elem ) {
            this._super(elem, options, TimePickerDefaultConfig, {
                picker: null,
                isOpen: false,
                value: [],
                locale: Metro.locales[METRO_LOCALE]['calendar'],
                listTimer: {
                    hours: null,
                    minutes: null,
                    seconds: null
                },
                id: Utils.elementId("time-picker")
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            var i;

            if (o.distance < 1) {
                o.distance = 1;
            }

            if (o.hoursStep < 1) {o.hoursStep = 1;}
            if (o.hoursStep > 23) {o.hoursStep = 23;}

            if (o.minutesStep < 1) {o.minutesStep = 1;}
            if (o.minutesStep > 59) {o.minutesStep = 59;}

            if (o.secondsStep < 1) {o.secondsStep = 1;}
            if (o.secondsStep > 59) {o.secondsStep = 59;}

            if (element.val() === "" && (!Utils.isValue(o.value))) {
                o.value = datetime().format("HH:mm:ss");
            }

            this.value = (element.val() !== "" ? element.val() : ""+o.value).toArray(":");

            for(i = 0; i < 3; i++) {
                if (this.value[i] === undefined || this.value[i] === null) {
                    this.value[i] = 0;
                } else {
                    this.value[i] = parseInt(this.value[i]);
                }
            }

            this._normalizeValue();

            if (Metro.locales[o.locale] === undefined) {
                o.locale = METRO_LOCALE;
            }

            this.locale = Metro.locales[o.locale]['calendar'];

            this._createStructure();
            this._createEvents();
            this._set();

            this._fireEvent("time-picker-create", {
                element: element
            });
        },

        _normalizeValue: function(){
            var o = this.options;

            if (o.hoursStep > 1) {
                this.value[0] = Utils.nearest(this.value[0], o.hoursStep, true);
            }
            if (o.minutesStep > 1) {
                this.value[1] = Utils.nearest(this.value[1], o.minutesStep, true);
            }
            if (o.minutesStep > 1) {
                this.value[2] = Utils.nearest(this.value[2], o.secondsStep, true);
            }
        },

        _createStructure: function(){
            var element = this.element, o = this.options;
            var picker, hours, minutes, seconds, i;
            var timeWrapper, selectWrapper, selectBlock, actionBlock;

            picker = $("<div>").addClass("wheel-picker time-picker " + element[0].className).addClass(o.clsPicker);

            picker.insertBefore(element);
            element.attr("readonly", true).appendTo(picker);

            if (o.label) {
                var label = $("<label>").addClass("label-for-input").addClass(o.clsLabel).html(o.label).insertBefore(picker);
                if (element.attr("id")) {
                    label.attr("for", element.attr("id"));
                }
                if (element.attr("dir") === "rtl") {
                    label.addClass("rtl");
                }
            }

            timeWrapper = $("<div>").addClass("time-wrapper").appendTo(picker);

            if (o.hours === true) {
                hours = $("<div>").attr("data-title", this.locale['time']['hours']).addClass("hours").addClass(o.clsPart).addClass(o.clsHours).appendTo(timeWrapper);
            }
            if (o.minutes === true) {
                minutes = $("<div>").attr("data-title", this.locale['time']['minutes']).addClass("minutes").addClass(o.clsPart).addClass(o.clsMinutes).appendTo(timeWrapper);
            }
            if (o.seconds === true) {
                seconds = $("<div>").attr("data-title", this.locale['time']['seconds']).addClass("seconds").addClass(o.clsPart).addClass(o.clsSeconds).appendTo(timeWrapper);
            }

            selectWrapper = $("<div>").addClass("select-wrapper").appendTo(picker);

            selectBlock = $("<div>").addClass("select-block").appendTo(selectWrapper);
            if (o.hours === true) {
                hours = $("<ul>").addClass("sel-hours").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
                for (i = 0; i < 24; i = i + o.hoursStep) {
                    $("<li>").addClass("js-hours-"+i).html(Cake.lpad(i, 2, "0")).data("value", i).appendTo(hours);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
            }
            if (o.minutes === true) {
                minutes = $("<ul>").addClass("sel-minutes").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
                for (i = 0; i < 60; i = i + o.minutesStep) {
                    $("<li>").addClass("js-minutes-"+i).html(Cake.lpad(i, 2, "0")).data("value", i).appendTo(minutes);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
            }
            if (o.seconds === true) {
                seconds = $("<ul>").addClass("sel-seconds").appendTo(selectBlock);
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
                for (i = 0; i < 60; i = i + o.secondsStep) {
                    $("<li>").addClass("js-seconds-"+i).html(Cake.lpad(i, 2, "0")).data("value", i).appendTo(seconds);
                }
                for (i = 0; i < o.distance; i++) $("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
            }

            selectBlock.height((o.distance * 2 + 1) * 40);

            actionBlock = $("<div>").addClass("action-block").appendTo(selectWrapper);
            $("<button>").attr("type", "button").addClass("button action-ok").addClass(o.clsButton).addClass(o.clsOkButton).html(o.okButtonIcon).appendTo(actionBlock);
            $("<button>").attr("type", "button").addClass("button action-cancel").addClass(o.clsButton).addClass(o.clsCancelButton).html(o.cancelButtonIcon).appendTo(actionBlock);


            element[0].className = '';
            if (o.copyInlineStyles === true) {
                for (i = 0; i < element[0].style.length; i++) {
                    picker.css(element[0].style[i], element.css(element[0].style[i]));
                }
            }

            if (o.showLabels === true) {
                picker.addClass("show-labels");
            }

            if (element.prop("disabled")) {
                picker.addClass("disabled");
            }

            this.picker = picker;
        },

        _createEvents: function(){
            var that = this, o = this.options;
            var picker = this.picker;

            picker.on(Metro.events.start, ".select-block ul", function(e){

                if (e.changedTouches) {
                    return ;
                }

                var target = this;
                var pageY = Utils.pageXY(e).y;

                $(document).on(Metro.events.move, function(e){

                    target.scrollTop -= o.scrollSpeed * (pageY  > Utils.pageXY(e).y ? -1 : 1);

                    pageY = Utils.pageXY(e).y;
                }, {ns: that.id});

                $(document).on(Metro.events.stop, function(){
                    $(document).off(Metro.events.move, {ns: that.id});
                    $(document).off(Metro.events.stop, {ns: that.id});
                }, {ns: that.id});
            });

            picker.on(Metro.events.click, function(e){
                if (that.isOpen === false) that.open();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-ok", function(e){
                var h, m, s;
                var sh = picker.find(".sel-hours li.active"),
                    sm = picker.find(".sel-minutes li.active"),
                    ss = picker.find(".sel-seconds li.active");

                h = sh.length === 0 ? 0 : sh.data("value");
                m = sm.length === 0 ? 0 : sm.data("value");
                s = ss.length === 0 ? 0 : ss.data("value");

                that.value = [h, m, s];
                that._normalizeValue();
                that._set();

                that.close();
                e.stopPropagation();
            });

            picker.on(Metro.events.click, ".action-cancel", function(e){
                that.close();
                e.stopPropagation();
            });

            var scrollLatency = 150;
            $.each(['hours', 'minutes', 'seconds'], function(){
                var part = this, list = picker.find(".sel-"+part);

                list.on("scroll", function(){
                    if (!that.isOpen) {
                        return ;
                    }

                    if (that.listTimer[part]) {
                        clearTimeout(that.listTimer[part]);
                        that.listTimer[part] = null;
                    }

                    if (!that.listTimer[part]) that.listTimer[part] = setTimeout(function () {

                        var target, targetElement, scrollTop;

                        that.listTimer[part] = null;

                        target = Math.round((Math.ceil(list.scrollTop()) / 40));

                        if (part === "hours" && o.hoursStep) {
                            target *= parseInt(o.hoursStep);
                        }
                        if (part === "minutes" && o.minutesStep) {
                            target *= parseInt(o.minutesStep);
                        }
                        if (part === "seconds" && o.secondsStep) {
                            target *= parseInt(o.secondsStep);
                        }

                        targetElement = list.find(".js-" + part + "-" + target);
                        scrollTop = targetElement.position().top - (o.distance * 40);

                        list.find(".active").removeClass("active");

                        list[0].scrollTop = scrollTop;
                        targetElement.addClass("active");
                        Utils.exec(o.onScroll, [targetElement, list, picker], list[0]);

                    }, scrollLatency);

                })
            });
        },

        _set: function(){
            var element = this.element, o = this.options;
            var picker = this.picker;
            var h = "00", m = "00", s = "00";

            if (o.hours === true) {
                h = parseInt(this.value[0]);
                picker.find(".hours").html(Cake.lpad(h, 2, "0"));
            }
            if (o.minutes === true) {
                m = parseInt(this.value[1]);
                picker.find(".minutes").html(Cake.lpad(m, 2, "0"));
            }
            if (o.seconds === true) {
                s = parseInt(this.value[2]);
                picker.find(".seconds").html(Cake.lpad(s, 2, "0"));
            }

            element.val([h, m, s].join(":")).trigger("change");

            this._fireEvent("set", {
                val: this.value,
                elementVal: element.val()
            });

        },

        open: function(){
            var o = this.options;
            var picker = this.picker;
            var h, m, s;
            var h_list, m_list, s_list;
            var items = picker.find("li");
            var select_wrapper = picker.find(".select-wrapper");
            var select_wrapper_in_viewport, select_wrapper_rect;
            var h_item, m_item, s_item;

            select_wrapper.parent().removeClass("for-top for-bottom");
            select_wrapper.show(0);
            items.removeClass("active");

            select_wrapper_in_viewport = Utils.inViewport(select_wrapper[0]);
            select_wrapper_rect = Utils.rect(select_wrapper[0]);

            if (!select_wrapper_in_viewport && select_wrapper_rect.top > 0) {
                select_wrapper.parent().addClass("for-bottom");
            }

            if (!select_wrapper_in_viewport && select_wrapper_rect.top < 0) {
                select_wrapper.parent().addClass("for-top");
            }

            var animateList = function(list, item){
                list
                    .scrollTop(0)
                    .animate({
                        draw: {
                            scrollTop: item.position().top - (o.distance * 40) + list.scrollTop()
                        },
                        dur: 100
                    });
            };

            if (o.hours === true) {
                h = parseInt(this.value[0]);
                h_list = picker.find(".sel-hours");
                h_item = h_list.find("li.js-hours-" + h).addClass("active");
                animateList(h_list, h_item);
            }
            if (o.minutes === true) {
                m = parseInt(this.value[1]);
                m_list = picker.find(".sel-minutes");
                m_item = m_list.find("li.js-minutes-" + m).addClass("active");
                animateList(m_list, m_item);
            }
            if (o.seconds === true) {
                s = parseInt(this.value[2]);
                s_list = picker.find(".sel-seconds");
                s_item = s_list.find("li.js-seconds-" + s).addClass("active");
                animateList(s_list, s_item);
            }

            this.isOpen = true;

            this._fireEvent("open", {
                val: this.value
            });

        },

        close: function(){
            var picker = this.picker;
            picker.find(".select-wrapper").hide(0);
            this.isOpen = false;

            this._fireEvent("close", {
                val: this.value
            });
        },

        _convert: function(t){
            var result;

            if (Array.isArray(t)) {
                result = t;
            } else if (typeof  t.getMonth === 'function') {
                result = [t.getHours(), t.getMinutes(), t.getSeconds()];
            } else if (Utils.isObject(t)) {
                result = [t.h, t.m, t.s];
            } else {
                result = t.toArray(":");
            }

            return result;
        },

        val: function(t){
            if (t === undefined) {
                return this.element.val();
            }
            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        time: function(t){
            if (t === undefined) {
                return {
                    h: this.value[0],
                    m: this.value[1],
                    s: this.value[2]
                }
            }

            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        date: function(t){
            if (t === undefined || typeof t.getMonth !== 'function') {
                return datetime()
                    .hour(this.value[0])
                    .minute(this.value[1])
                    .second(this.value[2])
                    .ms(0)
                    .val();
            }

            this.value = this._convert(t);
            this._normalizeValue();
            this._set();
        },

        disable: function(){
            this.element.data("disabled", true);
            this.element.parent().addClass("disabled");
        },

        enable: function(){
            this.element.data("disabled", false);
            this.element.parent().removeClass("disabled");
        },

        toggleState: function(){
            if (this.elem.disabled) {
                this.disable();
            } else {
                this.enable();
            }
        },

        changeAttribute: function(attr, newValue){
            switch (attr) {
                case "data-value":
                    this.val(newValue);
                    break;
                case "disabled":
                    this.toggleState();
                    break;
            }
        },

        destroy: function(){
            var element = this.element;
            var picker = this.picker;

            $.each(['hours', 'minutes', 'seconds'], function(){
                picker.find(".sel-"+this).off("scroll");
            });

            picker.off(Metro.events.start, ".select-block ul");
            picker.off(Metro.events.click);
            picker.off(Metro.events.click, ".action-ok");
            picker.off(Metro.events.click, ".action-cancel");

            return element;
        }

    });

    $(document).on(Metro.events.click, function(){
        $.each($(".time-picker"), function(){
            $(this).find("input").each(function(){
                Metro.getPlugin(this, "timepicker").close();
            });
        });
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var ToastDefaultConfig = {
        callback: Metro.noop,
        timeout: METRO_TIMEOUT,
        distance: 20,
        showTop: false,
        clsToast: ""
    };

    Metro.toastSetup = function(options){
        ToastDefaultConfig = $.extend({}, ToastDefaultConfig, options);
    };

    if (typeof window["metroToastSetup"] !== undefined) {
        Metro.toastSetup(window["metroToastSetup"]);
    }

    var Toast = {
        create: function(message, /*callback, timeout, cls, */options){
            var o, toast, width;
            var args = Array.from(arguments);
            var timeout, callback, cls;

            if (!$.isPlainObject(options)) {
                options = args[4];
                callback = args[1];
                timeout = args[2];
                cls = args[3];
            }

            o = $.extend({}, ToastDefaultConfig, options);

            toast = $("<div>").addClass("toast").html(message).appendTo($("body"));
            width = toast.outerWidth();
            toast.hide();

            timeout = timeout || o.timeout;
            callback = callback || o.callback;
            cls = cls || o.clsToast;

            if (o.showTop === true) {
                toast.addClass("show-top").css({
                    top: o.distance
                });
            } else {
                toast.css({
                    bottom: o.distance
                })
            }

            toast
                .css({
                    'left': '50%',
                    'margin-left': -(width / 2)
                })
                .addClass(o.clsToast)
                .addClass(cls)
                .fadeIn(METRO_ANIMATION_DURATION, function(){
                    setTimeout(function(){
                        Toast.remove(toast, callback);
                    }, timeout);
                });
        },

        remove: function(toast, cb){
            if (!toast) return ;

            toast.fadeOut(METRO_ANIMATION_DURATION, function(){
                toast.remove();
                Utils.exec(cb, null, toast[0]);
            });
        }
    };

    Metro['toast'] = Toast;
    Metro['createToast'] = Toast.create;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var TokenizerDefaultConfig = {
        textToTokenize: "",
        spaceSymbol: "",
        spaceClass: "space",
        tokenClass: "",
        splitter: "",
        tokenElement: "span",
        useTokenSymbol: true,
        useTokenIndex: true,
        clsTokenizer: "",
        clsToken: "",
        clsTokenOdd: "",
        clsTokenEven: "",
        onTokenCreate: Metro.noop,
        onTokenize: Metro.noop,
        onTokenizerCreate: Metro.noop
    };

    Metro.tokenizerSetup = function (options) {
        TokenizerDefaultConfig = $.extend({}, TokenizerDefaultConfig, options);
    };

    if (typeof window["metroTokenizerSetup"] !== undefined) {
        Metro.tokenizerSetup(window["metroTokenizerSetup"]);
    }

    Metro.Component('tokenizer', {
        init: function( options, elem ) {
            this._super(elem, options, TokenizerDefaultConfig, {
                // define instance vars here
                originalText: ""
            });
            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;
            this.originalText = o.textToTokenize ? o.textToTokenize.trim() : element.text().trim().replace(/[\r\n\t]/gi, '').replace(/\s\s+/g, " ");

            this._createStructure();
            this._fireEvent('tokenizer-create');
        },

        _tokenize: function(){
            var that = this, element = this.element, o = this.options;
            var index = 0, append, prepend;

            element.clear().attr("aria-label", this.originalText);

            $.each(this.originalText.split(o.splitter), function(i){
                var symbol = this;
                var isSpace = symbol === " ";
                var token;

                token = $("<"+o.tokenElement+">")
                    .html(isSpace ? o.spaceSymbol : symbol)
                    .attr("aria-hidden", true)
                    .addClass(isSpace ? o.spaceClass : "")
                    .addClass(isSpace && o.useTokenSymbol ? "" : "ts-"+symbol.replace(" ", "_"))
                    .addClass(isSpace && o.useTokenIndex ? "" : "ti-" + (i + 1))
                    .addClass(o.tokenClass ? o.tokenClass : "")
                    .addClass(!isSpace ? o.clsToken : "");

                if (!isSpace) {
                    index++;
                    token.addClass(index % 2 === 0 ? "te-even" : "te-odd");
                    token.addClass(index % 2 === 0 ? o.clsTokenEven : o.clsTokenOdd);
                }

                if (o.prepend) {
                    prepend = $.isSelector(o.prepend) ? $(o.prepend) : $("<span>").html(o.prepend);
                    token.prepend(prepend);
                }

                if (o.append) {
                    append = $.isSelector(o.append) ? $(o.append) : $("<span>").html(o.append);
                    token.append(append);
                }

                element.append(token);

                that._fireEvent("token-create", {
                    token: token[0]
                });
            });

            that._fireEvent("tokenize", {
                tokens: element.children().items(),
                originalText: this.originalText
            });
        },

        _createStructure: function(){
            var element = this.element,  o = this.options;
            element.addClass(o.clsTokenizer);
            this._tokenize();
        },

        tokenize: function(v){
            this.originalText = v;
            this._tokenize();
        },

        destroy: function(){
            this.element.remove();
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TouchConst = {
        LEFT : "left",
        RIGHT : "right",
        UP : "up",
        DOWN : "down",
        IN : "in",
        OUT : "out",
        NONE : "none",
        AUTO : "auto",
        SWIPE : "swipe",
        PINCH : "pinch",
        TAP : "tap",
        DOUBLE_TAP : "doubletap",
        LONG_TAP : "longtap",
        HOLD : "hold",
        HORIZONTAL : "horizontal",
        VERTICAL : "vertical",
        ALL_FINGERS : "all",
        DOUBLE_TAP_THRESHOLD : 10,
        PHASE_START : "start",
        PHASE_MOVE : "move",
        PHASE_END : "end",
        PHASE_CANCEL : "cancel",
        SUPPORTS_TOUCH : 'ontouchstart' in window,
        SUPPORTS_POINTER_IE10 : window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !('ontouchstart' in window),
        SUPPORTS_POINTER : (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !('ontouchstart' in window),
        IN_TOUCH: "intouch"
    };

    var TouchDefaultConfig = {
        touchDeferred: 0,
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        triggerOnTouchEnd: true,
        triggerOnTouchLeave: false,
        allowPageScroll: "auto",
        fallbackToMouseEvents: true,
        excludedElements: ".no-swipe",
        preventDefaultEvents: true,

        onSwipe: Metro.noop,
        onSwipeLeft: Metro.noop,
        onSwipeRight: Metro.noop,
        onSwipeUp: Metro.noop,
        onSwipeDown: Metro.noop,
        onSwipeStatus: Metro.noop_true, // params: phase, direction, distance, duration, fingerCount, fingerData, currentDirection
        onPinchIn: Metro.noop,
        onPinchOut: Metro.noop,
        onPinchStatus: Metro.noop_true,
        onTap: Metro.noop,
        onDoubleTap: Metro.noop,
        onLongTap: Metro.noop,
        onHold: Metro.noop,

        onTouchCreate: Metro.noop
    };

    Metro.touchSetup = function (options) {
        TouchDefaultConfig = $.extend({}, TouchDefaultConfig, options);
    };

    if (typeof window["metroTouchSetup"] !== undefined) {
        Metro.touchSetup(window["metroTouchSetup"]);
    }

    Metro.Component('touch', {
        init: function( options, elem ) {
            this._super(elem, options, TouchDefaultConfig, {
                useTouchEvents: null,
                START_EV: null,
                MOVE_EV: null,
                END_EV: null,
                LEAVE_EV: null,
                CANCEL_EV: null,

                distance: 0,
                direction: null,
                currentDirection: null,
                duration: 0,
                startTouchesDistance: 0,
                endTouchesDistance: 0,
                pinchZoom: 1,
                pinchDistance: 0,
                pinchDirection: 0,
                maximumsMap: null,

                phase: "start",

                fingerCount: 0,

                fingerData: {},

                startTime: 0,
                endTime: 0,
                previousTouchEndTime: 0,
                fingerCountAtRelease: 0,
                doubleTapStartTime: 0,

                singleTapTimeout: null,
                holdTimeout: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;

            this.useTouchEvents = (TouchConst.SUPPORTS_TOUCH || TouchConst.SUPPORTS_POINTER || !this.options.fallbackToMouseEvents);
            this.START_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerDown' : 'pointerdown') : 'touchstart') : 'mousedown';
            this.MOVE_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerMove' : 'pointermove') : 'touchmove') : 'mousemove';
            this.END_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerUp' : 'pointerup') : 'touchend') : 'mouseup';
            this.LEAVE_EV = this.useTouchEvents ? (TouchConst.SUPPORTS_POINTER ? 'mouseleave' : null) : 'mouseleave'; //we manually detect leave on touch devices, so null event here
            this.CANCEL_EV = (TouchConst.SUPPORTS_POINTER ? (TouchConst.SUPPORTS_POINTER_IE10 ? 'MSPointerCancel' : 'pointercancel') : 'touchcancel');

            if (o.allowPageScroll === undefined && (o.onSwipe !== Metro.noop || o.onSwipeStatus !== Metro.noop)) {
                o.allowPageScroll = TouchConst.NONE;
            }

            try {
                element.on(this.START_EV, $.proxy(this.touchStart, that));
                element.on(this.CANCEL_EV, $.proxy(this.touchCancel, that));
            } catch (e) {
                throw new Error('Events not supported ' + this.START_EV + ',' + this.CANCEL_EV + ' on Swipe');
            }

            this._fireEvent("touch-create", {
                element: element
            });
        },

        touchStart: function(e) {
            var element = this.element, options = this.options;

            //If we already in a touch event (a finger already in use) then ignore subsequent ones..
            if (this.getTouchInProgress()) {
                return;
            }

            //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
            if ($(e.target).closest(options.excludedElements).length > 0) {
                return;
            }

            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e;

            var ret,
                touches = event.touches,
                evt = touches ? touches[0] : event;

            this.phase = TouchConst.PHASE_START;

            //If we support touches, get the finger count
            if (touches) {
                // get the total number of fingers touching the screen
                this.fingerCount = touches.length;
            }
            //Else this is the desktop, so stop the browser from dragging content
            else if (options.preventDefaultEvents !== false) {
                e.preventDefault(); //call this on jq event so we are cross browser
            }

            //clear vars..
            this.distance = 0;
            this.direction = null;
            this.currentDirection=null;
            this.pinchDirection = null;
            this.duration = 0;
            this.startTouchesDistance = 0;
            this.endTouchesDistance = 0;
            this.pinchZoom = 1;
            this.pinchDistance = 0;
            this.maximumsMap = this.createMaximumsData();
            this.cancelMultiFingerRelease();

            //Create the default finger data
            this.createFingerData(0, evt);

            // check the number of fingers is what we are looking for, or we are capturing pinches
            if (!touches || (this.fingerCount === options.fingers || options.fingers === TouchConst.ALL_FINGERS) || this.hasPinches()) {
                // get the coordinates of the touch
                this.startTime = this.getTimeStamp();

                if (this.fingerCount === 2) {
                    //Keep track of the initial pinch distance, so we can calculate the diff later
                    //Store second finger data as start
                    this.createFingerData(1, touches[1]);
                    this.startTouchesDistance = this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].start, this.fingerData[1].start);
                }

                if (options.onSwipeStatus !== Metro.noop || options.onPinchStatus !== Metro.noop) {
                    ret = this.triggerHandler(event, this.phase);
                }
            } else {
                //A touch with more or less than the fingers we are looking for, so cancel
                ret = false;
            }

            //If we have a return value from the users handler, then return and cancel
            if (ret === false) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
                return ret;
            } else {
                if (options.onHold !== Metro.noop) {
                    this.holdTimeout = setTimeout($.proxy(function() {
                        //Trigger the event
                        element.trigger('hold', [event.target]);
                        //Fire the callback
                        if (options.onHold !== Metro.noop) { // TODO Remove this if
                            ret = Utils.exec(options.onHold, [event, event.target], element[0]);
                            element.fire("hold", {
                                event: event,
                                target: event.target
                            });
                        }
                    }, this), options.longTapThreshold);
                }

                this.setTouchInProgress(true);
            }

            return null;
        },

        touchMove: function(e) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e;

            //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
            if (this.phase === TouchConst.PHASE_END || this.phase === TouchConst.PHASE_CANCEL || this.inMultiFingerRelease())
                return;

            var ret,
                touches = event.touches,
                evt = touches ? touches[0] : event;

            //Update the  finger data
            var currentFinger = this.updateFingerData(evt);
            this.endTime = this.getTimeStamp();

            if (touches) {
                this.fingerCount = touches.length;
            }

            if (this.options.onHold !== Metro.noop) {
                clearTimeout(this.holdTimeout);
            }

            this.phase = TouchConst.PHASE_MOVE;

            //If we have 2 fingers get Touches distance as well
            if (this.fingerCount === 2) {

                //Keep track of the initial pinch distance, so we can calculate the diff later
                //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
                if (this.startTouchesDistance === 0) {
                    //Create second finger if this is the first time...
                    this.createFingerData(1, touches[1]);

                    this.startTouchesDistance = this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].start, this.fingerData[1].start);
                } else {
                    //Else just update the second finger
                    this.updateFingerData(touches[1]);

                    this.endTouchesDistance = this.calculateTouchesDistance(this.fingerData[0].end, this.fingerData[1].end);
                    this.pinchDirection = this.calculatePinchDirection(this.fingerData[0].end, this.fingerData[1].end);
                }

                this.pinchZoom = this.calculatePinchZoom(this.startTouchesDistance, this.endTouchesDistance);
                this.pinchDistance = Math.abs(this.startTouchesDistance - this.endTouchesDistance);
            }

            if ((this.fingerCount === this.options.fingers || this.options.fingers === TouchConst.ALL_FINGERS) || !touches || this.hasPinches()) {

                //The overall direction of the swipe. From start to now.
                this.direction = this.calculateDirection(currentFinger.start, currentFinger.end);

                //The immediate direction of the swipe, direction between the last movement and this one.
                this.currentDirection = this.calculateDirection(currentFinger.last, currentFinger.end);

                //Check if we need to prevent default event (page scroll / pinch zoom) or not
                this.validateDefaultEvent(e, this.currentDirection);

                //Distance and duration are all off the main finger
                this.distance = this.calculateDistance(currentFinger.start, currentFinger.end);
                this.duration = this.calculateDuration();

                //Cache the maximum distance we made in this direction
                this.setMaxDistance(this.direction, this.distance);

                //Trigger status handler
                ret = this.triggerHandler(event, this.phase);


                //If we trigger end events when threshold are met, or trigger events when touch leaves element
                if (!this.options.triggerOnTouchEnd || this.options.triggerOnTouchLeave) {

                    var inBounds = true;

                    //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
                    if (this.options.triggerOnTouchLeave) {
                        var bounds = this.getBounds(this);
                        inBounds = this.isInBounds(currentFinger.end, bounds);
                    }

                    //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
                    if (!this.options.triggerOnTouchEnd && inBounds) {
                        this.phase = this.getNextPhase(TouchConst.PHASE_MOVE);
                    }
                    //We end if out of bounds here, so set current phase to END, and check if its modified
                    else if (this.options.triggerOnTouchLeave && !inBounds) {
                        this.phase = this.getNextPhase(TouchConst.PHASE_END);
                    }

                    if (this.phase === TouchConst.PHASE_CANCEL || this.phase === TouchConst.PHASE_END) {
                        this.triggerHandler(event, this.phase);
                    }
                }
            } else {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }

            if (ret === false) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }
        },

        touchEnd: function(e) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = e,
                touches = event.touches;

            //If we are still in a touch with the device wait a fraction and see if the other finger comes up
            //if it does within the threshold, then we treat it as a multi release, not a single release and end the touch / swipe
            if (touches) {
                if (touches.length && !this.inMultiFingerRelease()) {
                    this.startMultiFingerRelease(event);
                    return true;
                } else if (touches.length && this.inMultiFingerRelease()) {
                    return true;
                }
            }

            //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
            //This is used to allow 2 fingers to release fractionally after each other, whilst maintaining the event as containing 2 fingers, not 1
            if (this.inMultiFingerRelease()) {
                this.fingerCount = this.fingerCountAtRelease;
            }

            //Set end of swipe
            this.endTime = this.getTimeStamp();

            //Get duration incase move was never fired
            this.duration = this.calculateDuration();

            //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
            if (this.didSwipeBackToCancel() || !this.validateSwipeDistance()) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            } else if (this.options.triggerOnTouchEnd || (this.options.triggerOnTouchEnd === false && this.phase === TouchConst.PHASE_MOVE)) {
                //call this on jq event so we are cross browser
                if (this.options.preventDefaultEvents !== false) {
                    e.preventDefault();
                }
                this.phase = TouchConst.PHASE_END;
                this.triggerHandler(event, this.phase);
            }
            //Special cases - A tap should always fire on touch end regardless,
            //So here we manually trigger the tap end handler by itself
            //We dont run trigger handler as it will re-trigger events that may have fired already
            else if (!this.options.triggerOnTouchEnd && this.hasTap()) {
                //Trigger the pinch events...
                this.phase = TouchConst.PHASE_END;
                this.triggerHandlerForGesture(event, this.phase, TouchConst.TAP);
            } else if (this.phase === TouchConst.PHASE_MOVE) {
                this.phase = TouchConst.PHASE_CANCEL;
                this.triggerHandler(event, this.phase);
            }

            this.setTouchInProgress(false);

            return null;
        },

        touchCancel: function() {
            // reset the variables back to default values
            this.fingerCount = 0;
            this.endTime = 0;
            this.startTime = 0;
            this.startTouchesDistance = 0;
            this.endTouchesDistance = 0;
            this.pinchZoom = 1;

            //If we were in progress of tracking a possible multi touch end, then re set it.
            this.cancelMultiFingerRelease();

            this.setTouchInProgress(false);
        },

        touchLeave: function(e) {
            if (this.options.triggerOnTouchLeave) {
                this.phase = this.getNextPhase(TouchConst.PHASE_END);
                this.triggerHandler(e, this.phase);
            }
        },

        getNextPhase: function(currentPhase) {
            var options  = this.options;
            var nextPhase = currentPhase;

            // Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)
            var validTime = this.validateSwipeTime();
            var validDistance = this.validateSwipeDistance();
            var didCancel = this.didSwipeBackToCancel();

            //If we have exceeded our time, then cancel
            if (!validTime || didCancel) {
                nextPhase = TouchConst.PHASE_CANCEL;
            }
            //Else if we are moving, and have reached distance then end
            else if (validDistance && currentPhase === TouchConst.PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) {
                nextPhase = TouchConst.PHASE_END;
            }
            //Else if we have ended by leaving and didn't reach distance, then cancel
            else if (!validDistance && currentPhase === TouchConst.PHASE_END && options.triggerOnTouchLeave) {
                nextPhase = TouchConst.PHASE_CANCEL;
            }

            return nextPhase;
        },

        triggerHandler: function(event, phase) {
            var ret,
                touches = event.touches;

            // SWIPE GESTURES
            if (this.didSwipe() || this.hasSwipes()) {
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.SWIPE);
            }

            // PINCH GESTURES (if the above didn't cancel)
            if ((this.didPinch() || this.hasPinches()) && ret !== false) {
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.PINCH);
            }

            // CLICK / TAP (if the above didn't cancel)
            if (this.didDoubleTap() && ret !== false) {
                //Trigger the tap events...
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.DOUBLE_TAP);
            }

            // CLICK / TAP (if the above didn't cancel)
            else if (this.didLongTap() && ret !== false) {
                //Trigger the tap events...
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.LONG_TAP);
            }

            // CLICK / TAP (if the above didn't cancel)
            else if (this.didTap() && ret !== false) {
                //Trigger the tap event..
                ret = this.triggerHandlerForGesture(event, phase, TouchConst.TAP);
            }

            // If we are cancelling the gesture, then manually trigger the reset handler
            if (phase === TouchConst.PHASE_CANCEL) {
                this.touchCancel(event);
            }

            // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
            if (phase === TouchConst.PHASE_END) {
                //If we support touch, then check that all fingers are off before we cancel
                if (touches) {
                    if (!touches.length) {
                        this.touchCancel(event);
                    }
                } else {
                    this.touchCancel(event);
                }
            }

            return ret;
        },

        triggerHandlerForGesture: function(event, phase, gesture) {

            var ret, element = this.element, options = this.options;

            //SWIPES....
            if (gesture === TouchConst.SWIPE) {
                //Trigger status every time..
                element.trigger('swipeStatus', [phase, this.direction || null, this.distance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.currentDirection]);

                ret = Utils.exec(options.onSwipeStatus, [event, phase, this.direction || null, this.distance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                element.fire("swipestatus", {
                    event: event,
                    phase: phase,
                    direction: this.direction,
                    distance: this.distance,
                    duration: this.duration,
                    fingerCount: this.fingerCount,
                    fingerData: this.fingerData,
                    currentDirection: this.currentDirection
                });
                if (ret === false) return false;

                if (phase === TouchConst.PHASE_END && this.validateSwipe()) {

                    //Cancel any taps that were in progress...
                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);

                    element.trigger('swipe', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);

                    ret = Utils.exec(options.onSwipe, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                    element.fire("swipe", {
                        event: event,
                        direction: this.direction,
                        distance: this.distance,
                        duration: this.duration,
                        fingerCount: this.fingerCount,
                        fingerData: this.fingerData,
                        currentDirection: this.currentDirection
                    });

                    if (ret === false) return false;

                    //trigger direction specific event handlers
                    switch (this.direction) {
                        case TouchConst.LEFT:
                            element.trigger('swipeLeft', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeLeft, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipeleft", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.RIGHT:
                            element.trigger('swipeRight', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeRight, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swiperight", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.UP:
                            element.trigger('swipeUp', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeUp, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipeup", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;

                        case TouchConst.DOWN:
                            element.trigger('swipeDown', [this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection]);
                            ret = Utils.exec(options.onSwipeDown, [event, this.direction, this.distance, this.duration, this.fingerCount, this.fingerData, this.currentDirection], element[0]);
                            element.fire("swipedown", {
                                event: event,
                                direction: this.direction,
                                distance: this.distance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                currentDirection: this.currentDirection
                            });
                            break;
                    }
                }
            }


            //PINCHES....
            if (gesture === TouchConst.PINCH) {
                element.trigger('pinchStatus', [phase, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);

                ret = Utils.exec(options.onPinchStatus, [event, phase, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                element.fire("pinchstatus", {
                    event: event,
                    phase: phase,
                    direction: this.pinchDirection,
                    distance: this.pinchDistance,
                    duration: this.duration,
                    fingerCount: this.fingerCount,
                    fingerData: this.fingerData,
                    zoom: this.pinchZoom
                });
                if (ret === false) return false;

                if (phase === TouchConst.PHASE_END && this.validatePinch()) {

                    switch (this.pinchDirection) {
                        case TouchConst.IN:
                            element.trigger('pinchIn', [this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);
                            ret = Utils.exec(options.onPinchIn, [event, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                            element.fire("pinchin", {
                                event: event,
                                direction: this.pinchDirection,
                                distance: this.pinchDistance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                zoom: this.pinchZoom
                            });
                            break;

                        case TouchConst.OUT:
                            element.trigger('pinchOut', [this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom]);
                            ret = Utils.exec(options.onPinchOut, [event, this.pinchDirection || null, this.pinchDistance || 0, this.duration || 0, this.fingerCount, this.fingerData, this.pinchZoom], element[0]);
                            element.fire("pinchout", {
                                event: event,
                                direction: this.pinchDirection,
                                distance: this.pinchDistance,
                                duration: this.duration,
                                fingerCount: this.fingerCount,
                                fingerData: this.fingerData,
                                zoom: this.pinchZoom
                            });
                            break;
                    }
                }
            }

            if (gesture === TouchConst.TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {

                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);

                    //If we are also looking for doubelTaps, wait incase this is one...
                    if (this.hasDoubleTap() && !this.inDoubleTap()) {
                        this.doubleTapStartTime = this.getTimeStamp();

                        //Now wait for the double tap timeout, and trigger this single tap
                        //if its not cancelled by a double tap
                        this.singleTapTimeout = setTimeout($.proxy(function() {
                            this.doubleTapStartTime = null;
                            ret = Utils.exec(options.onTap, [event, event.target], element[0]);
                            element.fire("tap", {
                                event: event,
                                target: event.target
                            });
                        }, this), options.doubleTapThreshold);

                    } else {
                        this.doubleTapStartTime = null;
                        ret = Utils.exec(options.onTap, [event, event.target], element[0]);
                        element.fire("tap", {
                            event: event,
                            target: event.target
                        });
                    }
                }
            } else if (gesture === TouchConst.DOUBLE_TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {
                    clearTimeout(this.singleTapTimeout);
                    clearTimeout(this.holdTimeout);
                    this.doubleTapStartTime = null;

                    ret = Utils.exec(options.onDoubleTap, [event, event.target], element[0]);
                    element.fire("doubletap", {
                        event: event,
                        target: event.target
                    });
                }
            } else if (gesture === TouchConst.LONG_TAP) {
                if (phase === TouchConst.PHASE_CANCEL || phase === TouchConst.PHASE_END) {
                    clearTimeout(this.singleTapTimeout);
                    this.doubleTapStartTime = null;

                    ret = Utils.exec(options.onLongTap, [event, event.target], element[0]);
                    element.fire("longtap", {
                        event: event,
                        target: event.target
                    });
                }
            }

            return ret;
        },

        validateSwipeDistance: function() {
            var valid = true;
            //If we made it past the min swipe distance..
            if (this.options.threshold !== null) {
                valid = this.distance >= this.options.threshold;
            }

            return valid;
        },

        didSwipeBackToCancel: function() {
            var options = this.options;
            var cancelled = false;
            if (options.cancelThreshold !== null && this.direction !== null) {
                cancelled = (this.getMaxDistance(this.direction) - this.distance) >= options.cancelThreshold;
            }

            return cancelled;
        },

        validatePinchDistance: function() {
            if (this.options.pinchThreshold !== null) {
                return this.pinchDistance >= this.options.pinchThreshold;
            }
            return true;
        },

        validateSwipeTime: function() {
            var result, options = this.options;

            if (options.maxTimeThreshold) {
                result = this.duration < options.maxTimeThreshold;
            } else {
                result = true;
            }

            return result;
        },

        validateDefaultEvent: function(e, direction) {
            var options = this.options;

            //If the option is set, allways allow the event to bubble up (let user handle weirdness)
            if (options.preventDefaultEvents === false) {
                return;
            }

            if (options.allowPageScroll === TouchConst.NONE) {
                e.preventDefault();
            } else {
                var auto = options.allowPageScroll === TouchConst.AUTO;

                switch (direction) {
                    case TouchConst.LEFT:
                        if ((options.onSwipeLeft !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.HORIZONTAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.RIGHT:
                        if ((options.onSwipeRight !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.HORIZONTAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.UP:
                        if ((options.onSwipeUp !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.VERTICAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.DOWN:
                        if ((options.onSwipeDown !== Metro.noop && auto) || (!auto && options.allowPageScroll.toLowerCase() !== TouchConst.VERTICAL)) {
                            e.preventDefault();
                        }
                        break;

                    case TouchConst.NONE:

                        break;
                }
            }
        },

        validatePinch: function() {
            var hasCorrectFingerCount = this.validateFingers();
            var hasEndPoint = this.validateEndPoint();
            var hasCorrectDistance = this.validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
        },

        hasPinches: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.options.onPinchStatus || this.options.onPinchIn || this.options.onPinchOut);
        },

        didPinch: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validatePinch() && this.hasPinches());
        },

        validateSwipe: function() {
            //Check validity of swipe
            var hasValidTime = this.validateSwipeTime();
            var hasValidDistance = this.validateSwipeDistance();
            var hasCorrectFingerCount = this.validateFingers();
            var hasEndPoint = this.validateEndPoint();
            var didCancel = this.didSwipeBackToCancel();

            // if the user swiped more than the minimum length, perform the appropriate action
            // hasValidDistance is null when no distance is set
            return !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
        },

        hasSwipes: function() {
            var o = this.options;
            //Enure we dont return 0 or null for false values
            return !!(
                o.onSwipe !== Metro.noop
                || o.onSwipeStatus  !== Metro.noop
                || o.onSwipeLeft  !== Metro.noop
                || o.onSwipeRight  !== Metro.noop
                || o.onSwipeUp  !== Metro.noop
                || o.onSwipeDown !== Metro.noop
            );
        },

        didSwipe: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateSwipe() && this.hasSwipes());
        },

        validateFingers: function() {
            //The number of fingers we want were matched, or on desktop we ignore
            return ((this.fingerCount === this.options.fingers || this.options.fingers === TouchConst.ALL_FINGERS) || !TouchConst.SUPPORTS_TOUCH);
        },

        validateEndPoint: function() {
            //We have an end value for the finger
            return this.fingerData[0].end.x !== 0;
        },

        hasTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onTap !== Metro.noop;
        },

        hasDoubleTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onDoubleTap !== Metro.noop;
        },

        hasLongTap: function() {
            //Enure we dont return 0 or null for false values
            return this.options.onLongTap !== Metro.noop;
        },

        validateDoubleTap: function() {
            if (this.doubleTapStartTime == null) {
                return false;
            }
            var now = this.getTimeStamp();
            return (this.hasDoubleTap() && ((now - this.doubleTapStartTime) <= this.options.doubleTapThreshold));
        },

        inDoubleTap: function() {
            return this.validateDoubleTap();
        },

        validateTap: function() {
            return ((this.fingerCount === 1 || !TouchConst.SUPPORTS_TOUCH) && (isNaN(this.distance) || this.distance < this.options.threshold));
        },

        validateLongTap: function() {
            var options = this.options;
            //slight threshold on moving finger
            return ((this.duration > options.longTapThreshold) && (this.distance < TouchConst.DOUBLE_TAP_THRESHOLD)); // check double_tab_threshold where from
        },

        didTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateTap() && this.hasTap());
        },

        didDoubleTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateDoubleTap() && this.hasDoubleTap());
        },

        didLongTap: function() {
            //Enure we dont return 0 or null for false values
            return !!(this.validateLongTap() && this.hasLongTap());
        },

        startMultiFingerRelease: function(event) {
            this.previousTouchEndTime = this.getTimeStamp();
            this.fingerCountAtRelease = event.touches.length + 1;
        },

        cancelMultiFingerRelease: function() {
            this.previousTouchEndTime = 0;
            this.fingerCountAtRelease = 0;
        },

        inMultiFingerRelease: function() {
            var withinThreshold = false;

            if (this.previousTouchEndTime) {
                var diff = this.getTimeStamp() - this.previousTouchEndTime;
                if (diff <= this.options.fingerReleaseThreshold) {
                    withinThreshold = true;
                }
            }

            return withinThreshold;
        },

        getTouchInProgress: function() {
            var element = this.element;
            //strict equality to ensure only true and false are returned
            return (element.data('intouch') === true);
        },

        setTouchInProgress: function(val) {
            var element = this.element;

            //If destroy is called in an event handler, we have no el, and we have already cleaned up, so return.
            if(!element) { return; }

            //Add or remove event listeners depending on touch status
            if (val === true) {
                element.on(this.MOVE_EV, $.proxy(this.touchMove, this));
                element.on(this.END_EV, $.proxy(this.touchEnd, this));

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (this.LEAVE_EV) {
                    element.on(this.LEAVE_EV, $.proxy(this.touchLeave, this));
                }
            } else {

                element.off(this.MOVE_EV);
                element.off(this.END_EV);

                //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
                if (this.LEAVE_EV) {
                    element.off(this.LEAVE_EV);
                }
            }

            //strict equality to ensure only true and false can update the value
            element.data('intouch', val === true);
        },

        createFingerData: function(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX;
            f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY;
            this.fingerData[id] = f;
            return f;
        },

        updateFingerData: function(evt) {
            var id = evt.identifier !== undefined ? evt.identifier : 0;
            var f = this.getFingerData(id);

            if (f === null) {
                f = this.createFingerData(id, evt);
            }

            f.last.x = f.end.x;
            f.last.y = f.end.y;

            f.end.x = evt.pageX || evt.clientX;
            f.end.y = evt.pageY || evt.clientY;

            return f;
        },

        getFingerData: function(id) {
            return this.fingerData[id] || null;
        },

        setMaxDistance: function(direction, distance) {
            if (direction === TouchConst.NONE) return;
            distance = Math.max(distance, this.getMaxDistance(direction));
            this.maximumsMap[direction].distance = distance;
        },

        getMaxDistance: function(direction) {
            return (this.maximumsMap[direction]) ? this.maximumsMap[direction].distance : undefined;
        },

        createMaximumsData: function() {
            var maxData = {};
            maxData[TouchConst.LEFT] = this.createMaximumVO(TouchConst.LEFT);
            maxData[TouchConst.RIGHT] = this.createMaximumVO(TouchConst.RIGHT);
            maxData[TouchConst.UP] = this.createMaximumVO(TouchConst.UP);
            maxData[TouchConst.DOWN] = this.createMaximumVO(TouchConst.DOWN);

            return maxData;
        },

        createMaximumVO: function(dir) {
            return {
                direction: dir,
                distance: 0
            }
        },

        calculateDuration: function(){
            return this.endTime - this.startTime;
        },

        calculateTouchesDistance: function(startPoint, endPoint){
            var diffX = Math.abs(startPoint.x - endPoint.x);
            var diffY = Math.abs(startPoint.y - endPoint.y);

            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        },

        calculatePinchZoom: function(startDistance, endDistance){
            var percent = (endDistance / startDistance) * 100; // 1 ? 100
            return percent.toFixed(2);
        },

        calculatePinchDirection: function(){
            if (this.pinchZoom < 1) {
                return TouchConst.OUT;
            } else {
                return TouchConst.IN;
            }
        },

        calculateDistance: function(startPoint, endPoint){
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        },

        calculateAngle: function(startPoint, endPoint){
            var x = startPoint.x - endPoint.x;
            var y = endPoint.y - startPoint.y;
            var r = Math.atan2(y, x); //radians
            var angle = Math.round(r * 180 / Math.PI); //degrees

            //ensure value is positive
            if (angle < 0) {
                angle = 360 - Math.abs(angle);
            }

            return angle;
        },

        calculateDirection: function(startPoint, endPoint){
            if( this.comparePoints(startPoint, endPoint) ) {
                return TouchConst.NONE;
            }

            var angle = this.calculateAngle(startPoint, endPoint);

            if ((angle <= 45) && (angle >= 0)) {
                return TouchConst.LEFT;
            } else if ((angle <= 360) && (angle >= 315)) {
                return TouchConst.LEFT;
            } else if ((angle >= 135) && (angle <= 225)) {
                return TouchConst.RIGHT;
            } else if ((angle > 45) && (angle < 135)) {
                return TouchConst.DOWN;
            } else {
                return TouchConst.UP;
            }
        },

        getTimeStamp: function(){
            return (new Date()).getTime();
        },

        getBounds: function (el) {
            el = $(el);
            var offset = el.offset();

            return {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            };
        },

        isInBounds: function(point, bounds){
            return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
        },

        comparePoints: function(pointA, pointB) {
            return (pointA.x === pointB.x && pointA.y === pointB.y);
        },

        removeListeners: function() {
            var element = this.element;

            element.off(this.START_EV);
            element.off(this.CANCEL_EV);
            element.off(this.MOVE_EV);
            element.off(this.END_EV);

            //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
            if (this.LEAVE_EV) {
                element.off(this.LEAVE_EV);
            }

            this.setTouchInProgress(false);
        },

        enable: function(){
            this.disable();
            this.element.on(this.START_EV, this.touchStart);
            this.element.on(this.CANCEL_EV, this.touchCancel);
            return this.element;
        },

        disable: function(){
            this.removeListeners();
            return this.element;
        },

        changeAttribute: function(){
        },

        destroy: function(){
            this.removeListeners();
        }
    });

    Metro['touch'] = TouchConst;
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var TreeViewDefaultConfig = {
        treeviewDeferred: 0,
        showChildCount: false,
        duration: 100,
        onNodeClick: Metro.noop,
        onNodeDblClick: Metro.noop,
        onNodeDelete: Metro.noop,
        onNodeInsert: Metro.noop,
        onNodeClean: Metro.noop,
        onCheckClick: Metro.noop,
        onRadioClick: Metro.noop,
        onExpandNode: Metro.noop,
        onCollapseNode: Metro.noop,
        onTreeViewCreate: Metro.noop
    };

    Metro.treeViewSetup = function (options) {
        TreeViewDefaultConfig = $.extend({}, TreeViewDefaultConfig, options);
    };

    if (typeof window["metroTreeViewSetup"] !== undefined) {
        Metro.treeViewSetup(window["metroTreeViewSetup"]);
    }

    Metro.Component('tree-view', {
        init: function( options, elem ) {
            this._super(elem, options, TreeViewDefaultConfig);
            return this;
        },

        _create: function(){
            var that = this, element = this.element;

            this._createTree();
            this._createEvents();

            $.each(element.find("input"), function(){
                if (!$(this).is(":checked")) return;
                that._recheck(this);
            });

            this._fireEvent("tree-view-create", {
                element: element
            });
        },

        _createIcon: function(data){
            var icon, src;

            src = Utils.isTag(data) ? $(data) : $("<img src='' alt=''>").attr("src", data);
            icon = $("<span>").addClass("icon");
            icon.html(src.outerHTML());

            return icon;
        },

        _createCaption: function(data){
            return $("<span>").addClass("caption").html(data);
        },


        _createToggle: function(){
            return $("<span>").addClass("node-toggle");
        },


        _createNode: function(data){
            var node;

            node = $("<li>");

            if (data.caption !== undefined) {
                node.prepend(this._createCaption(data.caption));
            }

            if (data.icon !== undefined) {
                node.prepend(this._createIcon(data.icon));
            }

            if (data.html !== undefined) {
                node.append(data.html);
            }

            return node;
        },

        _createTree: function(){
            var that = this, element = this.element, o = this.options;
            var nodes = element.find("li");

            element.addClass("treeview");

            $.each(nodes, function(){
                var node = $(this);
                var caption, icon;

                caption = node.data("caption");
                icon = node.data("icon");

                if (caption !== undefined) {
                    if (node.children("ul").length > 0 && o.showChildCount === true) {
                        caption += " ("+node.children("ul").children("li").length+")"
                    }
                    node.prepend(that._createCaption(caption));
                }

                if (icon !== undefined) {
                    node.prepend(that._createIcon(icon));
                }

                if (node.children("ul").length > 0) {

                    node.addClass("tree-node");

                    node.append(that._createToggle());

                    if (Utils.bool(node.attr("data-collapsed")) !== true) {
                        node.addClass("expanded");
                    } else {
                        node.children("ul").hide();
                    }
                }

            });
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".node-toggle", function(e){
                var toggle = $(this);
                var node = toggle.parent();

                that.toggleNode(node);

                e.preventDefault();
            });

            element.on(Metro.events.click, "li > .caption", function(e){
                var node = $(this).parent();

                that.current(node);

                that._fireEvent("node-click", {
                    node: node[0]
                });

                e.preventDefault();
            });

            element.on(Metro.events.dblclick, "li > .caption", function(e){
                var node = $(this).closest("li");
                var toggle = node.children(".node-toggle");
                var subtree = node.children("ul");

                if (toggle.length > 0 || subtree.length > 0) {
                    that.toggleNode(node);
                }

                that._fireEvent("node-dbl-click", {
                    node: node[0]
                })

                e.preventDefault();
            });

            element.on(Metro.events.click, "input[type=radio]", function(){
                var check = $(this);
                var checked = check.is(":checked");
                var node = check.closest("li");

                that.current(node);

                that._fireEvent("radio-click", {
                    checked: checked,
                    check: check[0],
                    node: node[0]
                });
            });

            element.on(Metro.events.click, "input[type=checkbox]", function(){
                var check = $(this);
                var checked = check.is(":checked");
                var node = check.closest("li");

                that._recheck(check);

                that._fireEvent("check-click", {
                    checked: checked,
                    check: check[0],
                    node: node[0]
                });
            });
        },

        _recheck: function(check){
            var element = this.element;
            var checked, node, checks, all_checks;

            check = $(check);

            checked = check.is(":checked");
            node = check.closest("li");

            this.current(node);

            // down
            checks = check.closest("li").find("ul input[type=checkbox]");
            checks.attr("data-indeterminate", false);
            checks.prop("checked", checked);
            checks.trigger('change');

            all_checks = [];

            $.each(element.find("input[type=checkbox]"), function(){
                all_checks.push(this);
            });

            $.each(all_checks.reverse(), function(){
                var ch = $(this);
                var children = ch.closest("li").children("ul").find("input[type=checkbox]").length;
                var children_checked = ch.closest("li").children("ul").find("input[type=checkbox]").filter(function(el){
                    return el.checked;
                }).length;

                if (children > 0 && children_checked === 0) {
                    ch.attr("data-indeterminate", false);
                    ch.prop("checked", false);
                    ch.trigger('change');
                }

                if (children_checked === 0) {
                    ch.attr("data-indeterminate", false);
                } else {
                    if (children_checked > 0 && children > children_checked) {
                        ch.attr("data-indeterminate", true);
                    } else if (children === children_checked) {
                        ch.attr("data-indeterminate", false);
                        ch.prop("checked", true);
                        ch.trigger('change');
                    }
                }
            });
        },

        current: function(node){
            var element = this.element;

            if (node === undefined) {
                return element.find("li.current")
            }

            element.find("li").removeClass("current");
            node.addClass("current");
        },

        toggleNode: function(n){
            var node = $(n);
            var o = this.options;
            var func;
            var toBeExpanded = !node.data("collapsed");//!node.hasClass("expanded");

            node.toggleClass("expanded");
            node.data("collapsed", toBeExpanded);

            func = toBeExpanded === true ? "slideUp" : "slideDown";

            if (!toBeExpanded) {

                this._fireEvent("expand-node", {
                    node: node[0]
                });

            } else {

                this._fireEvent("collapse-node", {
                    node: node[0]
                });

            }

            node.children("ul")[func](o.duration);
        },

        addTo: function(node, data){
            var element = this.element;
            var target;
            var new_node;
            var toggle;

            if (node === null) {
                target = element;
            } else {
                node = $(node);
                target = node.children("ul");
                if (target.length === 0) {
                    target = $("<ul>").appendTo(node);
                    toggle = this._createToggle();
                    toggle.appendTo(node);
                    node.addClass("expanded");
                }
            }

            new_node = this._createNode(data);

            new_node.appendTo(target);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node ? node[0] : null
            });

            return new_node;
        },

        insertBefore: function(node, data){
            var new_node = this._createNode(data);

            if (Utils.isNull(node)) {
                return this.addTo(node, data);
            }

            node = $(node);
            new_node.insertBefore(node);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node ? node[0] : null
            });

            return new_node;
        },

        insertAfter: function(node, data){
            var new_node = this._createNode(data);

            if (Utils.isNull(node)) {
                return this.addTo(node, data);
            }

            node = $(node);
            new_node.insertAfter(node);

            this._fireEvent("node-insert", {
                node: new_node[0],
                parent: node[0]
            });

            return new_node;
        },

        del: function(node){
            var element = this.element;
            node = $(node);
            var parent_list = node.closest("ul");
            var parent_node = parent_list.closest("li");

            this._fireEvent("node-delete", {
                node: node[0]
            });

            node.remove();

            if (parent_list.children().length === 0 && !parent_list.is(element)) {
                parent_list.remove();
                parent_node.removeClass("expanded");
                parent_node.children(".node-toggle").remove();
            }
        },

        clean: function(node){
            node = $(node);
            node.children("ul").remove();
            node.removeClass("expanded");
            node.children(".node-toggle").remove();

            this._fireEvent("node-clean", {
                node: node[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".node-toggle");
            element.off(Metro.events.click, "li > .caption");
            element.off(Metro.events.dblclick, "li > .caption");
            element.off(Metro.events.click, "input[type=radio]");
            element.off(Metro.events.click, "input[type=checkbox]");

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ValidatorFuncs = {
        required: function(val){
            if (Array.isArray(val)) {
                return val.length > 0 ? val : false;
            } else {
                return Utils.isValue(val) ? val.trim() : false;
            }
        },
        length: function(val, len){
            if (Array.isArray(val)) {return val.length === parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length === parseInt(len);
        },
        minlength: function(val, len){
            if (Array.isArray(val)) {return val.length >= parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length >= parseInt(len);
        },
        maxlength: function(val, len){
            if (Array.isArray(val)) {return val.length <= parseInt(len);}
            if (!Utils.isValue(len) || isNaN(len) || len <= 0) {
                return false;
            }
            return val.trim().length <= parseInt(len);
        },
        min: function(val, min_value){
            if (!Utils.isValue(min_value) || isNaN(min_value)) {
                return false;
            }
            if (!this.number(val)) {
                return false;
            }
            if (isNaN(val)) {
                return false;
            }
            return Number(val) >= Number(min_value);
        },
        max: function(val, max_value){
            if (!Utils.isValue(max_value) || isNaN(max_value)) {
                return false;
            }
            if (!this.number(val)) {
                return false;
            }
            if (isNaN(val)) {
                return false;
            }
            return Number(val) <= Number(max_value);
        },
        email: function(val){
            /* eslint-disable-next-line */
            return /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i.test(val);
        },
        domain: function(val){
            /* eslint-disable-next-line */
            return /^((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/.test(val);
        },
        url: function(val){
            /* eslint-disable-next-line */
            var regexp    = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
            return regexp.test(val);
        },
        date: function(val, format, locale){
            try {
                if (!format) {
                    datetime(val);
                } else {
                    Datetime.from(val, format, locale);
                }
                return true;
            } catch (e) {
                return false;
            }
        },
        number: function(val){
            return !isNaN(val);
        },
        integer: function(val){
            return Utils.isInt(val);
        },
        float: function(val){
            return Utils.isFloat(val);
        },
        digits: function(val){
            return /^\d+$/.test(val);
        },
        hexcolor: function(val){
            /* eslint-disable-next-line */
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(val);
        },
        color: function(val){
            if (!Utils.isValue(val)) return false;
            return Metro.colors.color(val, Metro.colors.PALETTES.STANDARD) !== false || Metro.colors.isColor(Metro.colors.parse(val));
        },
        pattern: function(val, pat){
            if (!Utils.isValue(val)) return false;
            if (!Utils.isValue(pat)) return false;
            var reg = new RegExp(pat);
            return reg.test(val);
        },
        compare: function(val, val2){
            return val === val2;
        },
        not: function(val, not_this){
            return val !== not_this;
        },
        notequals: function(val, val2){
            if (Utils.isNull(val)) return false;
            if (Utils.isNull(val2)) return false;
            return val.trim() !== val2.trim();
        },
        equals: function(val, val2){
            if (Utils.isNull(val)) return false;
            if (Utils.isNull(val2)) return false;
            return val.trim() === val2.trim();
        },
        custom: function(val, func){
            if (Utils.isFunc(func) === false) {
                return false;
            }
            return Utils.exec(func, [val]);
        },

        is_control: function(el){
            return el.parent().hasClass("input")
                || el.parent().hasClass("select")
                || el.parent().hasClass("textarea")
                || el.parent().hasClass("checkbox")
                || el.parent().hasClass("switch")
                || el.parent().hasClass("radio")
                || el.parent().hasClass("spinner")
                ;
        },

        reset_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().removeClass("invalid valid");
            } else {
                input.removeClass("invalid valid");
            }
        },

        set_valid_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().addClass("valid");
            } else {
                input.addClass("valid");
            }
        },

        set_invalid_state: function(el){
            var input = $(el);
            var is_control = ValidatorFuncs.is_control(input);

            if (is_control) {
                input.parent().addClass("invalid");
            } else {
                input.addClass("invalid");
            }
        },

        reset: function(form){
            var that = this;
            $.each($(form).find("[data-validate]"), function(){
                that.reset_state(this);
            });

            return this;
        },

        validate: function(el, result, cb_ok, cb_error, required_mode){
            var this_result = true;
            var input = $(el);
            var funcs = input.data('validate') !== undefined ? String(input.data('validate')).split(" ").map(function(s){return s.trim();}) : [];
            var errors = [];
            var hasForm = input.closest('form').length > 0;
            var attr_name, radio_checked;

            if (funcs.length === 0) {
                return true;
            }

            this.reset_state(input);

            if (input.attr('type') && input.attr('type').toLowerCase() === "checkbox") {
                if (funcs.indexOf('required') === -1) {
                    this_result = true;
                } else {
                    this_result = input.is(":checked");
                }

                if (this_result === false) {
                    errors.push('required');
                }

                if (result !== undefined) {
                    result.val += this_result ? 0 : 1;
                }
            } else if (input.attr('type') && input.attr('type').toLowerCase() === "radio") {
                attr_name = input.attr('name');
                if (typeof attr_name  === undefined) {
                    this_result = true;
                } else {
                    /*
                    * Fix with escaped name by nlared https://github.com/nlared
                    * */
                    radio_checked = $("input[name=" + attr_name.replace("[", "\\\[").replace("]", "\\\]") + "]:checked"); // eslint-disable-line
                    this_result = radio_checked.length > 0;
                }
                if (result !== undefined) {
                    result.val += this_result ? 0 : 1;
                }
            } else {
                $.each(funcs, function(){
                    if (this_result === false) return;
                    var rule = this.split("=");
                    var f, a, b;

                    f = rule[0]; rule.shift();
                    a = rule.join("=");

                    if (['compare', 'equals', 'notequals'].indexOf(f) > -1) {
                        a = hasForm ? input[0].form.elements[a].value : $("[name="+a+"]").val();
                    }

                    if (f === 'date') {
                        a = input.attr("data-value-format");
                        b = input.attr("data-value-locale");
                    }

                    if (Utils.isFunc(ValidatorFuncs[f]) === false)  {
                        this_result = true;
                    } else {
                        if (required_mode === true || f === "required") {
                            this_result = ValidatorFuncs[f](input.val(), a, b);
                        } else {
                            if (input.val().trim() !== "") {
                                this_result = ValidatorFuncs[f](input.val(), a, b);
                            } else {
                                this_result = true;
                            }
                        }
                    }

                    if (this_result === false) {
                        errors.push(f);
                    }

                    if (result !== undefined) {
                        result.val += this_result ? 0 : 1;
                    }
                });
            }

            if (this_result === false) {
                this.set_invalid_state(input);

                if (result !== undefined) {
                    result.log.push({
                        input: input[0],
                        name: input.attr("name"),
                        value: input.val(),
                        funcs: funcs,
                        errors: errors
                    });
                }

                if (cb_error !== undefined) Utils.exec(cb_error, [input, input.val()], input[0]);

            } else {
                this.set_valid_state(input);

                if (cb_ok !== undefined) Utils.exec(cb_ok, [input, input.val()], input[0]);
            }

            return this_result;
        }
    };

    Metro['validator'] = ValidatorFuncs;

    var ValidatorDefaultConfig = {
        validatorDeferred: 0,
        submitTimeout: 200,
        interactiveCheck: false,
        clearInvalid: 0,
        requiredMode: true,
        useRequiredClass: true,
        onBeforeSubmit: Metro.noop_true,
        onSubmit: Metro.noop,
        onError: Metro.noop,
        onValidate: Metro.noop,
        onErrorForm: Metro.noop,
        onValidateForm: Metro.noop,
        onValidatorCreate: Metro.noop
    };

    Metro.validatorSetup = function (options) {
        ValidatorDefaultConfig = $.extend({}, ValidatorDefaultConfig, options);
    };

    if (typeof window["metroValidatorSetup"] !== undefined) {
        Metro.validatorSetup(window["metroValidatorSetup"]);
    }

    Metro.Component('validator', {
        name: "Validator",

        init: function( options, elem ) {
            this._super(elem, options, ValidatorDefaultConfig, {
                _onsubmit: null,
                _onreset: null,
                result: []
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var inputs = element.find("[data-validate]");

            element
                .attr("novalidate", 'novalidate');

            $.each(inputs, function(){
                var input = $(this);
                var funcs = input.data("validate");
                var required = funcs.indexOf("required") > -1;
                if (required && o.useRequiredClass === true) {
                    if (ValidatorFuncs.is_control(input)) {
                        input.parent().addClass("required");
                    } else {
                        input.addClass("required");
                    }
                }
                if (o.interactiveCheck === true) {
                    input.on(Metro.events.inputchange, function () {
                        ValidatorFuncs.validate(this, undefined, undefined, undefined, o.requiredMode);
                    });
                }
            });

            this._onsubmit = null;
            this._onreset = null;

            if (element[0].onsubmit !== null) {
                this._onsubmit = element[0].onsubmit;
                element[0].onsubmit = null;
            }

            if (element[0].onreset !== null) {
                this._onreset = element[0].onreset;
                element[0].onreset = null;
            }

            element[0].onsubmit = function(){
                return that._submit();
            };

            element[0].onreset = function(){
                return that._reset();
            };

            this._fireEvent("validator-create", {
                element: element
            });
        },

        _reset: function(){
            ValidatorFuncs.reset(this.element);
            if (this._onsubmit !==  null) Utils.exec(this._onsubmit, null, this.element[0]);
        },

        _submit: function(){
            var that = this, element = this.element, o = this.options;
            var form = this.elem;
            var inputs = element.find("[data-validate]");
            var submit = element.find("input[type=submit], button[type=submit]");
            var result = {
                val: 0,
                log: []
            };
            var formData = $.serializeToArray(element);

            if (submit.length > 0) {
                submit.attr('disabled', 'disabled').addClass('disabled');
            }

            $.each(inputs, function(){
                ValidatorFuncs.validate(this, result, o.onValidate, o.onError, o.requiredMode);
            });

            submit.removeAttr("disabled").removeClass("disabled");

            result.val += Utils.exec(o.onBeforeSubmit, [formData], this.elem) === false ? 1 : 0;

            if (result.val === 0) {

                this._fireEvent("validate-form", {
                    data: formData
                });

                setTimeout(function(){
                    // TODO need fix event name to equivalent
                    Utils.exec(o.onSubmit, [formData], form);
                    element.fire("formsubmit", {
                        data: formData
                    });
                    if (that._onsubmit !==  null) Utils.exec(that._onsubmit, null, form);
                }, o.submitTimeout);
            } else {

                this._fireEvent("error-form", {
                    log: result.log,
                    data: formData
                });

                if (o.clearInvalid > 0) {
                    setTimeout(function(){
                        $.each(inputs, function(){
                            var inp  = $(this);
                            if (ValidatorFuncs.is_control(inp)) {
                                inp.parent().removeClass("invalid");
                            } else {
                                inp.removeClass("invalid");
                            }
                        })
                    }, o.clearInvalid);
                }
            }

            return result.val === 0;
        },

        changeAttribute: function(){
        }
    });
}(Metro, m4q));

/**
 * Component Vegas based on Vegas by Jay Salvat (http://jaysalvat.com/)
 * Original code https://github.com/jaysalvat/vegas
 * MIT License, Copyright 2018 Jay Salvat
 *
 * Adaptation for Metro 4 by Serhii Pimenov,
 * Copyright 2020 Serhii Pimenov
 */

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var VegasDefaultConfig = {
        duration: 4000,
        animationDuration: null,
        transitionDuration: null,
        transition: "fade",
        animation: null,
        slides: [],
        shuffle: false,
        align: "center",
        valign: "center",
        loop: true,
        autoplay: true,
        mute: true,
        cover: true,
        preload: true,
        timer: true,
        overlay: 2,
        color: null,
        volume: 1,
        onPlay: Metro.noop,
        onPause: Metro.noop,
        onEnd: Metro.noop,
        onWalk: Metro.noop,
        onNext: Metro.noop,
        onPrev: Metro.noop,
        onJump: Metro.noop,
        onVegasCreate: Metro.noop
    };

    Metro.vegasSetup = function (options) {
        VegasDefaultConfig = $.extend({}, VegasDefaultConfig, options);
    };

    if (typeof window["metroVegasSetup"] !== undefined) {
        Metro.vegasSetup(window["metroVegasSetup"]);
    }

    Metro.Component('vegas', {

        videoCache: {},

        init: function( options, elem ) {
            this.transitions = [
                "fade", "fade2",
                "slideLeft", "slideLeft2",
                "slideRight", "slideRight2",
                "slideUp", "slideUp2",
                "slideDown", "slideDown2",
                "zoomIn", "zoomIn2",
                "zoomOut", "zoomOut2",
                "swirlLeft", "swirlLeft2",
                "swirlRight", "swirlRight2"
            ];
            this.animations = [
                "kenburns",
                "kenburnsUp",
                "kenburnsDown",
                "kenburnsRight",
                "kenburnsLeft",
                "kenburnsUpLeft",
                "kenburnsUpRight",
                "kenburnsDownLeft",
                "kenburnsDownRight"
            ];

            this.support = {
                objectFit:  'objectFit'  in document.body.style,
                video: !/(Android|webOS|Phone|iPad|iPod|BlackBerry|Windows Phone)/i.test(navigator.userAgent)
            }

            this._super(elem, options, VegasDefaultConfig, {
                slide: 0,
                slides: null,
                total: 0,
                noshow: false,
                paused: false,
                ended: false,
                timer: null,
                overlay: null,
                first: true,
                timeout: false
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            this.slides = Utils.isObject(o.slides) || [];
            this.total = this.slides.length;
            this.noshow = this.total < 2;
            this.paused = !o.autoplay || this.noshow;

            if (o.shuffle) {
                this.slides.shuffle();
            }

            if (o.preload) {
                this._preload();
            }

            this._createStructure();
            this._createEvents();

            this._fireEvent("vegas-create", {
                element: element
            });
        },

        _createStructure: function(){
            var that = this, element = this.element, o = this.options;
            var isBody = element[0].tagName === 'BODY';
            var wrapper;

            if (!isBody) {
                element.css('height', element.css('height')); // it is not clear why this line

                wrapper = $('<div class="vegas-wrapper">')
                    .css('overflow', element.css('overflow'))
                    .css('padding',  element.css('padding'));

                if (!element.css('padding')) {
                    wrapper
                        .css('padding-top',    element.css('padding-top'))
                        .css('padding-bottom', element.css('padding-bottom'))
                        .css('padding-left',   element.css('padding-left'))
                        .css('padding-right',  element.css('padding-right'));
                }

                element.children().appendTo(wrapper);
                element.clear();
            }

            element.addClass("vegas-container");

            if (!isBody) {
                element.append(wrapper);
            }

            if (o.timer) {
                this.timer = $('<div class="vegas-timer"><div class="vegas-timer-progress">');
                element.append(this.timer);
            }

            if (o.overlay) {
                this.overlay = $('<div class="vegas-overlay">').addClass('overlay' + (typeof o.overlay === 'boolean' || isNaN(o.overlay) ? 2 : +o.overlay));
                element.append(this.overlay);
            }

            setTimeout(function(){
                Utils.exec(o.onPlay, null, element[0]);
                that._goto(that.slide);
            },1)
        },

        _createEvents: function(){
        },

        _preload: function(){
            var img, i;

            for (i = 0; i < this.slides.length; i++) {

                var obj = this.slides[i];

                if (obj.src) {
                    img = new Image();
                    img.src = this.slides[i].src;
                }

                if (obj.video) {
                    if (obj.video instanceof Array) {
                        this._video(obj.video);
                    } else {
                        this._video(obj.video.src);
                    }
                }
            }
        },

        _slideShow: function () {
            var that = this, o = this.options;

            if (this.total > 1 && !this.ended && !this.paused && !this.noshow) {
                this.timeout = setTimeout(function () {
                    that.next();
                }, o.duration);
            }
        },

        _timer: function (state) {
            var that = this, o = this.options;

            clearTimeout(this.timeout);

            if (!this.timer) {
                return;
            }

            this.timer
                .removeClass('vegas-timer-running')
                .find('div')
                .css('transition-duration', '0ms');

            if (this.ended || this.paused || this.noshow) {
                return;
            }

            if (state) {
                setTimeout(function () {
                    that.timer
                        .addClass('vegas-timer-running')
                        .find('div')
                        .css('transition-duration', +o.duration - 100 + 'ms');
                }, 100);
            }
        },

        _fadeSoundIn: function(video, duration){
            var o = this.options;

            $.animate({
                el: video,
                draw: {
                    volume: +o.volume
                },
                dur: duration
            })
        },

        _fadeSoundOut: function(video, duration){
            $.animate({
                el: video,
                draw: {
                    volume: 0
                },
                dur: duration
            })
        },

        _video: function(sources){
            var video, source;
            var cacheKey = sources.toString();

            if (this.videoCache[cacheKey]) {
                return this.videoCache[cacheKey];
            }

            if (!Array.isArray(sources)) {
                sources = [sources];
            }

            video = document.createElement("video");
            video.preload = true;

            sources.forEach(function(src){
                source = document.createElement("source");
                source.src = src;
                video.appendChild(source);
            });

            this.videoCache[cacheKey] = video;

            return video;
        },

        _goto: function(n){
            var that = this, element = this.element, o = this.options;

            if (typeof this.slides[n] === 'undefined') {
                n = 0;
            }

            this.slide = n;

            var $slide, $inner, video, img, $video;
            var slides = element.children(".vegas-slide");
            var obj = this.slides[n];
            var cover = o.cover;
            var transition, animation;
            var transitionDuration, animationDuration;

            if (this.first) {
                this.first = false;
            }

            if (cover !== 'repeat') {
                if (cover === true) {
                    cover = 'cover';
                } else if (cover === false) {
                    cover = 'contain';
                }
            }

            if (o.transition === 'random') {
                transition = $.random(this.transitions);
            } else {
                transition = o.transition ? o.transition : this.transitions[0];
            }

            if (o.animation === 'random') {
                animation = $.random(this.animations);
            } else {
                animation = o.animation ? o.animation : this.animations[0];
            }

            if (!o.transitionDuration) {
                transitionDuration = +o.duration;
            } else if (o.transitionDuration === 'auto' || +o.transitionDuration > +o.duration) {
                transitionDuration = +o.duration;
            } else {
                transitionDuration = +o.transitionDuration;
            }

            if (!o.animationDuration) {
                animationDuration = +o.duration;
            } else if (o.animationDuration === 'auto' || +o.animationDuration > +o.duration) {
                animationDuration = +o.duration;
            } else {
                animationDuration = +o.animationDuration;
            }

            $slide = $("<div>").addClass("vegas-slide").addClass('vegas-transition-' + transition);

            if (this.support.video && obj.video) {
                video = obj.video instanceof Array ? this._video(obj.video) : this._video(obj.video.src);
                video.loop = obj.video.loop ? obj.video.loop : o.loop;
                video.muted = obj.video.mute ? obj.video.mute : o.mute;

                if (!video.muted) {
                    this._fadeSoundIn(video, transitionDuration);
                } else {
                    video.pause();
                }

                $video = $(video)
                    .addClass('vegas-video')
                    .css('background-color', o.color || '#000000');

                if (this.support.objectFit) {
                    $video
                        .css('object-position', o.align + ' ' + o.valign)
                        .css('object-fit', cover)
                        .css('width',  '100%')
                        .css('height', '100%');
                } else if (cover === 'contain') {
                    $video
                        .css('width',  '100%')
                        .css('height', '100%');
                }

                $slide.append($video);
            } else {
                img = new Image();
                $inner = $("<div>").addClass('vegas-slide-inner')
                    .css({
                        backgroundImage: 'url("'+obj.src+'")',
                        backgroundColor: o.color || '#000000',
                        backgroundPosition: o.align + ' ' + o.valign
                    });

                if (cover === 'repeat') {
                    $inner.css('background-repeat', 'repeat');
                } else {
                    $inner.css('background-size', cover);
                }

                if (animation) {
                    $inner
                        .addClass('vegas-animation-' + animation)
                        .css('animation-duration',  animationDuration + 'ms');
                }

                $slide.append($inner);
            }

            if (slides.length) {
                slides.eq(slides.length - 1).after($slide);
            } else {
                element.prepend($slide);
            }

            slides
                .css('transition', 'all 0ms')
                .each(function(){
                    this.className  = 'vegas-slide';

                    if (this.tagName === 'VIDEO') {
                        this.className += ' vegas-video';
                    }

                    if (transition) {
                        this.className += ' vegas-transition-' + transition;
                        this.className += ' vegas-transition-' + transition + '-in';
                    }
                }
            );

            this._timer(false);

            function go(){
                that._timer(true);
                setTimeout(function () {
                    slides
                        .css('transition', 'all ' + transitionDuration + 'ms')
                        .addClass('vegas-transition-' + transition + '-out');

                    slides.each(function () {
                        var video = slides.find('video').get(0);

                        if (video) {
                            video.volume = 1;
                            that._fadeSoundOut(video, transitionDuration);
                        }
                    });

                    $slide
                        .css('transition', 'all ' + transitionDuration + 'ms')
                        .addClass('vegas-transition-' + transition + '-in');

                    for (var i = 0; i < slides.length - 1; i++) {
                        slides.eq(i).remove();
                    }

                    that._fireEvent("walk", {
                        slide: that.current(true)
                    });

                    that._slideShow();
                }, 100);
            }

            if (video) {
                if (video.readyState === 4) {
                    video.currentTime = 0;
                }

                video.play();
                go();
            } else {
                img.src = obj.src;

                if (img.complete) {
                    go();
                } else {
                    img.onload = go;
                }
            }
        },

        _end: function(){
            this.ended = this.options.autoplay;
            this._timer(false);

            this._fireEvent("end", {
                slide: this.current(true)
            });
        },

        play: function(){
            if (!this.paused) {
                return ;
            }

            this._fireEvent("play", {
                slide: this.current(true)
            });

            this.paused = false;
            this.next();
        },

        pause: function(){
            this._timer(false);
            this.paused = true;

            this._fireEvent("pause", {
                slide: this.current(true)
            });
        },

        toggle: function(){
            this.paused ? this.play() : this.pause();
        },

        playing: function(){
            return !this.paused && !this.noshow;
        },

        current: function (advanced) {
            if (advanced) {
                return {
                    slide: this.slide,
                    data:  this.slides[this.slide]
                };
            }
            return this.slide;
        },

        jump: function(n){
            if (n <= 0 || n > this.slides.length || n === this.slide + 1) {
                return this;
            }

            this.slide = n - 1;

            this._fireEvent("jump", {
                slide: this.current(true)
            })

            this._goto(this.slide);
        },

        next: function(){
            var o = this.options;

            this.slide++;

            if (this.slide >= this.slides.length) {
                if (!o.loop) {
                    return this._end();
                }

                this.slide = 0;
            }

            this._fireEvent("next", {
                slide: this.current(true)
            });

            this._goto(this.slide);
        },

        prev: function(){
            var o = this.options;

            this.slide--;

            if (this.slide < 0) {
                if (!o.loop) {
                    this.slide++;
                    return this._end();
                }

                this.slide = this.slides.length - 1;
            }

            this._fireEvent("prev", {
                slide: this.current(true)
            });

            this._goto(this.slide);
        },

        changeAttribute: function(attr){
            var element = this.element, o = this.options;
            var propName = Cake.camelCase(attr.replace("data-", ""));

            if (propName === 'slides') {
                o.slides = element.attr('data-slides');
                this.slides = Utils.isObject(o.slides) || [];
                this.total = this.slides.length;
                this.noshow = this.total < 2;
                this.paused = !this.options.autoplay || this.noshow;
            } else {
                if (typeof VegasDefaultConfig[propName] !== 'undefined')
                    o[propName] = JSON.parse(element.attr(attr));
            }
        },

        destroy: function(){
            var element = this.element, o = this.options;

            clearTimeout(this.timeout);
            element.removeClass('vegas-container');
            element.find('> .vegas-slide').remove();
            element.find('> .vegas-wrapper').children().appendTo(element);
            element.find('> .vegas-wrapper').remove();

            if (o.timer) {
                this.timer.remove();
            }

            if (o.overlay) {
                this.overlay.remove();
            }

            return element[0];
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var VideoPlayerDefaultConfig = {
        videoDeferred: 0,
        src: null,

        poster: "",
        logo: "",
        logoHeight: 32,
        logoWidth: "auto",
        logoTarget: "",

        volume: .5,
        loop: false,
        autoplay: false,

        fullScreenMode: Metro.fullScreenMode.DESKTOP,
        aspectRatio: Metro.aspectRatio.HD,

        controlsHide: 3000,

        showLoop: true,
        showPlay: true,
        showStop: true,
        showMute: true,
        showFull: true,
        showStream: true,
        showVolume: true,
        showInfo: true,

        loopIcon: "<span class='default-icon-loop'></span>",
        stopIcon: "<span class='default-icon-stop'></span>",
        playIcon: "<span class='default-icon-play'></span>",
        pauseIcon: "<span class='default-icon-pause'></span>",
        muteIcon: "<span class='default-icon-mute'></span>",
        volumeLowIcon: "<span class='default-icon-low-volume'></span>",
        volumeMediumIcon: "<span class='default-icon-medium-volume'></span>",
        volumeHighIcon: "<span class='default-icon-high-volume'></span>",
        screenMoreIcon: "<span class='default-icon-enlarge'></span>",
        screenLessIcon: "<span class='default-icon-shrink'></span>",

        onPlay: Metro.noop,
        onPause: Metro.noop,
        onStop: Metro.noop,
        onEnd: Metro.noop,
        onMetadata: Metro.noop,
        onTime: Metro.noop,
        onVideoPlayerCreate: Metro.noop
    };

    Metro.videoPlayerSetup = function (options) {
        VideoPlayerDefaultConfig = $.extend({}, VideoPlayerDefaultConfig, options);
    };

    if (typeof window["metroVideoPlayerSetup"] !== undefined) {
        Metro.videoPlayerSetup(window["metroVideoPlayerSetup"]);
    }

    Metro.Component('video-player', {
        init: function( options, elem ) {
            this._super(elem, options, VideoPlayerDefaultConfig, {
                fullscreen: false,
                preloader: null,
                player: null,
                video: elem,
                stream: null,
                volume: null,
                volumeBackup: 0,
                muted: false,
                fullScreenInterval: false,
                isPlaying: false,
                id: Utils.elementId('video-player')
            });

            return this;
        },

        _create: function(){
            var element = this.element, o = this.options;

            if (Metro.fullScreenEnabled === false) {
                o.fullScreenMode = Metro.fullScreenMode.WINDOW;
            }

            this._createPlayer();
            this._createControls();
            this._createEvents();
            this._setAspectRatio();

            if (o.autoplay === true) {
                this.play();
            }

            this._fireEvent("video-player-create", {
                element: element,
                player: this.player
            });
        },

        _createPlayer: function(){
            var element = this.element, o = this.options, video = this.video;
            var player = $("<div>").addClass("media-player video-player " + element[0].className);
            var preloader = $("<div>").addClass("preloader").appendTo(player);
            var logo = $("<a>").attr("href", o.logoTarget).addClass("logo").appendTo(player);

            player.insertBefore(element);
            element.appendTo(player);

            $.each(['muted', 'autoplay', 'controls', 'height', 'width', 'loop', 'poster', 'preload'], function(){
                element.removeAttr(this);
            });

            element.attr("preload", "auto");

            if (o.poster !== "") {
                element.attr("poster", o.poster);
            }

            video.volume = o.volume;

            preloader.activity({
                type: "cycle",
                style: "color"
            });

            preloader.hide();

            this.preloader = preloader;

            if (o.logo !== "") {
                $("<img>")
                    .css({
                        height: o.logoHeight,
                        width: o.logoWidth
                    })
                    .attr("src", o.logo).appendTo(logo);
            }

            if (o.src !== null) {
                this._setSource(o.src);
            }

            element[0].className = "";

            this.player = player;
        },

        _setSource: function(src){
            var element = this.element;

            element.find("source").remove();
            element.removeAttr("src");
            if (Array.isArray(src)) {
                $.each(src, function(){
                    var item = this;
                    if (item.src === undefined) return ;
                    $("<source>").attr('src', item.src).attr('type', item.type !== undefined ? item.type : '').appendTo(element);
                });
            } else {
                element.attr("src", src);
            }
        },

        _createControls: function(){
            var that = this, element = this.element, o = this.options, video = this.elem;

            var controls = $("<div>").addClass("controls").addClass(o.clsControls).insertAfter(element);

            var stream = $("<div>").addClass("stream").appendTo(controls);
            var streamSlider = $("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);

            var volume = $("<div>").addClass("volume").appendTo(controls);
            var volumeSlider = $("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);

            var infoBox = $("<div>").addClass("info-box").appendTo(controls);

            if (o.showInfo !== true) {
                infoBox.hide();
            }

            Metro.makePlugin(streamSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                clsComplete: "bg-cyan",
                hint: true,
                onStart: function(){
                    if (!video.paused) video.pause();
                },
                onStop: function(val){
                    if (video.seekable.length > 0) {
                        video.currentTime = (that.duration * val / 100).toFixed(0);
                    }
                    if (video.paused && video.currentTime > 0) {
                        video.play();
                    }
                }
            });

            this.stream = streamSlider;

            if (o.showStream !== true) {
                stream.hide();
            }

            Metro.makePlugin(volumeSlider, "slider", {
                clsMarker: "bg-red",
                clsHint: "bg-cyan fg-white",
                hint: true,
                value: o.volume * 100,
                onChangeValue: function(val){
                    video.volume = val / 100;
                }
            });

            this.volume = volumeSlider;

            if (o.showVolume !== true) {
                volume.hide();
            }

            var loop;

            if (o.showLoop === true) loop = $("<button>").attr("type", "button").addClass("button square loop").html(o.loopIcon).appendTo(controls);
            if (o.showPlay === true) $("<button>").attr("type", "button").addClass("button square play").html(o.playIcon).appendTo(controls);
            if (o.showStop === true) $("<button>").attr("type", "button").addClass("button square stop").html(o.stopIcon).appendTo(controls);
            if (o.showMute === true) $("<button>").attr("type", "button").addClass("button square mute").html(o.muteIcon).appendTo(controls);
            if (o.showFull === true) $("<button>").attr("type", "button").addClass("button square full").html(o.screenMoreIcon).appendTo(controls);

            if (o.loop === true) {
                loop.addClass("active");
                element.attr("loop", "loop");
            }

            this._setVolume();

            if (o.muted) {
                that.volumeBackup = video.volume;
                Metro.getPlugin(that.volume, 'slider').val(0);
                video.volume = 0;
            }

            infoBox.html("00:00 / 00:00");
        },

        _createEvents: function(){
            var that = this, element = this.element, o = this.options, video = this.elem, player = this.player;

            element.on("loadstart", function(){
                that.preloader.show();
            });

            element.on("loadedmetadata", function(){
                that.duration = video.duration.toFixed(0);
                that._setInfo(0, that.duration);
                Utils.exec(o.onMetadata, [video, player], element[0]);
            });

            element.on("canplay", function(){
                that._setBuffer();
                that.preloader.hide();
            });

            element.on("progress", function(){
                that._setBuffer();
            });

            element.on("timeupdate", function(){
                var position = Math.round(video.currentTime * 100 / that.duration);
                that._setInfo(video.currentTime, that.duration);
                Metro.getPlugin(that.stream, 'slider').val(position);
                Utils.exec(o.onTime, [video.currentTime, that.duration, video, player], element[0]);
            });

            element.on("waiting", function(){
                that.preloader.show();
            });

            element.on("loadeddata", function(){

            });

            element.on("play", function(){
                player.find(".play").html(o.pauseIcon);
                Utils.exec(o.onPlay, [video, player], element[0]);
                that._onMouse();
            });

            element.on("pause", function(){
                player.find(".play").html(o.playIcon);
                Utils.exec(o.onPause, [video, player], element[0]);
                that._offMouse();
            });

            element.on("stop", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onStop, [video, player], element[0]);
                that._offMouse();
            });

            element.on("ended", function(){
                Metro.getPlugin(that.stream, 'slider').val(0);
                Utils.exec(o.onEnd, [video, player], element[0]);
                that._offMouse();
            });

            element.on("volumechange", function(){
                that._setVolume();
            });

            player.on(Metro.events.click, ".play", function(){
                if (video.paused) {
                    that.play();
                } else {
                    that.pause();
                }
            });

            player.on(Metro.events.click, ".stop", function(){
                that.stop();
            });

            player.on(Metro.events.click, ".mute", function(){
                that._toggleMute();
            });

            player.on(Metro.events.click, ".loop", function(){
                that._toggleLoop();
            });

            player.on(Metro.events.click, ".full", function(){
                that.fullscreen = !that.fullscreen;
                player.find(".full").html(that.fullscreen === true ? o.screenLessIcon : o.screenMoreIcon);
                if (o.fullScreenMode === Metro.fullScreenMode.WINDOW) {
                    if (that.fullscreen === true) {
                        player.addClass("full-screen");
                    } else {
                        player.removeClass("full-screen");
                    }
                } else {
                    if (that.fullscreen === true) {

                        Metro.requestFullScreen(video);

                        if (that.fullScreenInterval === false) that.fullScreenInterval = setInterval(function(){
                            if (Metro.inFullScreen() === false) {
                                that.fullscreen = false;
                                clearInterval(that.fullScreenInterval);
                                that.fullScreenInterval = false;
                                player.find(".full").html(o.screenMoreIcon);
                            }

                        }, 1000);
                    } else {
                        Metro.exitFullScreen();
                    }
                }

                // if (that.fullscreen === true) {
                //     $(document).on(Metro.events.keyup + ".video-player", function(e){
                //         if (e.keyCode === 27) {
                //             player.find(".full").click();
                //         }
                //     });
                // } else {
                //     $(document).off(Metro.events.keyup + ".video-player");
                // }
            });

            $(window).on(Metro.events.keyup, function(e){
                if (that.fullscreen && e.keyCode === 27) {
                    player.find(".full").click();
                }
            }, {ns: this.id});

            $(window).on(Metro.events.resize, function(){
                that._setAspectRatio();
            }, {ns: this.id});

        },

        _onMouse: function(){
            var o = this.options, player = this.player;

            player.on(Metro.events.enter, function(){
                var controls = player.find(".controls");
                if (o.controlsHide > 0 && controls.style('display') === 'none') {
                    controls.stop(true).fadeIn(500, function(){
                        controls.css("display", "flex");
                    });
                }
            });

            player.on(Metro.events.leave, function(){
                var controls = player.find(".controls");
                if (o.controlsHide > 0 && parseInt(controls.style('opacity')) === 1) {
                    setTimeout(function () {
                        controls.stop(true).fadeOut(500);
                    }, o.controlsHide);
                }
            });
        },

        _offMouse: function(){
            var player = this.player, o = this.options;
            var controls = player.find(".controls");

            player.off(Metro.events.enter);
            player.off(Metro.events.leave);

            if (o.controlsHide > 0 && controls.style('display') === 'none') {
                controls.stop(true).fadeIn(500, function(){
                    controls.css("display", "flex");
                });
            }
        },

        _toggleLoop: function(){
            var loop = this.player.find(".loop");
            if (loop.length === 0) return ;
            loop.toggleClass("active");
            if (loop.hasClass("active")) {
                this.element.attr("loop", "loop");
            } else {
                this.element.removeAttr("loop");
            }
        },

        _toggleMute: function(){
            this.muted = !this.muted;
            if (this.muted === false) {
                this.video.volume = this.volumeBackup;
            } else {
                this.volumeBackup = this.video.volume;
                this.video.volume = 0;
            }
            Metro.getPlugin(this.volume, 'slider').val(this.muted === false ? this.volumeBackup * 100 : 0);
        },

        _setInfo: function(a, b){
            this.player.find(".info-box").html(Utils.secondsToFormattedString(Math.round(a)) + " / " + Utils.secondsToFormattedString(Math.round(b)));
        },

        _setBuffer: function(){
            var buffer = this.video.buffered.length ? Math.round(Math.floor(this.video.buffered.end(0)) / Math.floor(this.video.duration) * 100) : 0;
            Metro.getPlugin(this.stream, 'slider').buff(buffer);
        },

        _setVolume: function(){
            var video = this.video, player = this.player, o = this.options;

            var volumeButton = player.find(".mute");
            var volume = video.volume * 100;
            if (volume > 1 && volume < 30) {
                volumeButton.html(o.volumeLowIcon);
            } else if (volume >= 30 && volume < 60) {
                volumeButton.html(o.volumeMediumIcon);
            } else if (volume >= 60 && volume <= 100) {
                volumeButton.html(o.volumeHighIcon);
            } else {
                volumeButton.html(o.muteIcon);
            }
        },

        _setAspectRatio: function(){
            var player = this.player, o = this.options;
            var width = player.outerWidth();
            var height;

            switch (o.aspectRatio) {
                case Metro.aspectRatio.SD: height = Utils.aspectRatioH(width, "4/3"); break;
                case Metro.aspectRatio.CINEMA: height = Utils.aspectRatioH(width, "21/9"); break;
                default: height = Utils.aspectRatioH(width, "16/9");
            }

            player.outerHeight(height);
        },

        aspectRatio: function(ratio){
            this.options.aspectRatio = ratio;
            this._setAspectRatio();
        },

        play: function(src){
            if (src !== undefined) {
                this._setSource(src);
            }

            if (this.element.attr("src") === undefined && this.element.find("source").length === 0) {
                return ;
            }

            this.isPlaying = true;

            this.video.play();
        },

        pause: function(){
            this.isPlaying = false;
            this.video.pause();
        },

        resume: function(){
            if (this.video.paused) {
                this.play();
            }
        },

        stop: function(){
            this.isPlaying = false;
            this.video.pause();
            this.video.currentTime = 0;
            Metro.getPlugin(this.stream, 'slider').val(0);
            this._offMouse();
        },

        setVolume: function(v){
            if (v === undefined) {
                return this.video.volume;
            }

            if (v > 1) {
                v /= 100;
            }

            this.video.volume = v;
            Metro.getPlugin(this.volume[0], 'slider').val(v*100);
        },

        loop: function(){
            this._toggleLoop();
        },

        mute: function(){
            this._toggleMute();
        },

        changeAspectRatio: function(){
            this.options.aspectRatio = this.element.attr("data-aspect-ratio");
            this._setAspectRatio();
        },

        changeSource: function(){
            var src = JSON.parse(this.element.attr('data-src'));
            this.play(src);
        },

        changeVolume: function(){
            var volume = this.element.attr("data-volume");
            this.setVolume(volume);
        },

        changeAttribute: function(attributeName){
            switch (attributeName) {
                case "data-aspect-ratio": this.changeAspectRatio(); break;
                case "data-src": this.changeSource(); break;
                case "data-volume": this.changeVolume(); break;
            }
        },

        destroy: function(){
            var element = this.element, player = this.player;

            Metro.getPlugin(this.stream, "slider").destroy();
            Metro.getPlugin(this.volume, "slider").destroy();

            element.off("loadstart");
            element.off("loadedmetadata");
            element.off("canplay");
            element.off("progress");
            element.off("timeupdate");
            element.off("waiting");
            element.off("loadeddata");
            element.off("play");
            element.off("pause");
            element.off("stop");
            element.off("ended");
            element.off("volumechange");

            player.off(Metro.events.click, ".play");
            player.off(Metro.events.click, ".stop");
            player.off(Metro.events.click, ".mute");
            player.off(Metro.events.click, ".loop");
            player.off(Metro.events.click, ".full");

            $(window).off(Metro.events.keyup,{ns: this.id});
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';

    var Utils = Metro.utils;
    var ViewportCheckDefaultConfig = {
        onViewport: Metro.noop,
        onViewportEnter: Metro.noop,
        onViewportLeave: Metro.noop,
        onViewportCheckCreate: Metro.noop
    };

    Metro.viewportCheckSetup = function (options) {
        ViewportCheckDefaultConfig = $.extend({}, ViewportCheckDefaultConfig, options);
    };

    if (typeof window["metroViewportCheckSetup"] !== undefined) {
        Metro.viewportCheckSetup(window["metroViewportCheckSetup"]);
    }

    Metro.Component('viewport-check', {
        init: function( options, elem ) {
            this._super(elem, options, ViewportCheckDefaultConfig, {
                // define instance vars here
                inViewport: false,
                id: Utils.elementId("viewport-check")
            });
            return this;
        },

        _create: function(){
            this.inViewport = Utils.inViewport(this.elem);

            this._createEvents();

            this._fireEvent('viewport-check-create');
        },

        _createEvents: function(){
            var that = this, elem = this.elem;

            $(window).on(Metro.events.scroll, function(){
                var oldState = that.inViewport;

                that.inViewport = Utils.inViewport(elem);

                if (oldState !== that.inViewport) {
                    if (that.inViewport) {
                        that._fireEvent("viewport-enter");
                    } else {
                        that._fireEvent("viewport-leave");
                    }
                }

                that._fireEvent("viewport", {
                    state: that.inViewport
                });
            }, {ns: that.id});
        },

        state: function(){
            return this.inViewport;
        },

        destroy: function(){
            $(window).off(Metro.events.scroll, {ns: this.id});

            return this.element;
        }
    });
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var WindowDefaultConfig = {
        windowDeferred: 0,
        hidden: false,
        width: "auto",
        height: "auto",
        btnClose: true,
        btnMin: true,
        btnMax: true,
        draggable: true,
        dragElement: ".window-caption .icon, .window-caption .title",
        dragArea: "parent",
        shadow: false,
        icon: "",
        title: "Window",
        content: null,
        resizable: true,
        overlay: false,
        overlayColor: 'transparent',
        overlayAlpha: .5,
        modal: false,
        position: "absolute",
        checkEmbed: true,
        top: "auto",
        left: "auto",
        place: "auto",
        closeAction: Metro.actions.REMOVE,
        customButtons: null,

        clsCustomButton: "",
        clsCaption: "",
        clsContent: "",
        clsWindow: "",

        _runtime: false,

        minWidth: 0,
        minHeight: 0,
        maxWidth: 0,
        maxHeight: 0,
        onDragStart: Metro.noop,
        onDragStop: Metro.noop,
        onDragMove: Metro.noop,
        onCaptionDblClick: Metro.noop,
        onCloseClick: Metro.noop,
        onMaxClick: Metro.noop,
        onMinClick: Metro.noop,
        onResizeStart: Metro.noop,
        onResizeStop: Metro.noop,
        onResize: Metro.noop,
        onWindowCreate: Metro.noop,
        onShow: Metro.noop,
        onWindowDestroy: Metro.noop,
        onCanClose: Metro.noop_true,
        onClose: Metro.noop
    };

    Metro.windowSetup = function (options) {
        WindowDefaultConfig = $.extend({}, WindowDefaultConfig, options);
    };

    if (typeof window["metroWindowSetup"] !== undefined) {
        Metro.windowSetup(window["metroWindowSetup"]);
    }

    Metro.Component('window', {
        init: function( options, elem ) {
            this._super(elem, options, WindowDefaultConfig, {
                win: null,
                overlay: null,
                position: {
                    top: 0,
                    left: 0
                },
                hidden: false,
                content: null
            });

            return this;
        },

        _create: function(){
            var that = this, element = this.element, o = this.options;
            var win, overlay;
            var parent = o.dragArea === "parent" ? element.parent() : $(o.dragArea);
            var _content;

            if (o.modal === true) {
                o.btnMax = false;
                o.btnMin = false;
                o.resizable = false;
            }

            if (Utils.isNull(o.content)) {
                o.content = element;
            } else {
                if (Utils.isUrl(o.content) && Utils.isVideoUrl(o.content)) {
                    o.content = Utils.embedUrl(o.content);
                    element.css({
                        height: "100%"
                    });
                } else

                if (!Utils.isQ(o.content) && Utils.isFunc(o.content)) {
                    o.content = Utils.exec(o.content);
                }

                _content = $(o.content);
                if (_content.length === 0) {
                    element.appendText(o.content);
                } else {
                    element.append(_content);
                }
                o.content = element;
            }

            if (o._runtime === true) {
                this._runtime(element, "window");
            }

            win = this._window(o);
            win.addClass("no-visible");

            parent.append(win);

            if (o.overlay === true) {
                overlay = this._overlay();
                overlay.appendTo(win.parent());
                this.overlay = overlay;
            }

            this.win = win;

            this._fireEvent("window-create", {
                win: this.win[0],
                element: element
            });

            setTimeout(function(){
                that._setPosition();

                if (o.hidden !== true) {
                    that.win.removeClass("no-visible");
                }

                that._fireEvent("show", {
                    win: that.win[0],
                    element: element
                });
            }, 100);
        },

        _setPosition: function(){
            var o = this.options;
            var win = this.win;
            var parent = o.dragArea === "parent" ? win.parent() : $(o.dragArea);
            var top_center = parent.height() / 2 - win[0].offsetHeight / 2;
            var left_center = parent.width() / 2 - win[0].offsetWidth / 2;
            var top, left, right, bottom;

            if (o.place !== 'auto') {

                switch (o.place.toLowerCase()) {
                    case "top-left": top = 0; left = 0; right = "auto"; bottom = "auto"; break;
                    case "top-center": top = 0; left = left_center; right = "auto"; bottom = "auto"; break;
                    case "top-right": top = 0; right = 0; left = "auto"; bottom = "auto"; break;
                    case "right-center": top = top_center; right = 0; left = "auto"; bottom = "auto"; break;
                    case "bottom-right": bottom = 0; right = 0; left = "auto"; top = "auto"; break;
                    case "bottom-center": bottom = 0; left = left_center; right = "auto"; top = "auto"; break;
                    case "bottom-left": bottom = 0; left = 0; right = "auto"; top = "auto"; break;
                    case "left-center": top = top_center; left = 0; right = "auto"; bottom = "auto"; break;
                    default: top = top_center; left = left_center; bottom = "auto"; right = "auto";
                }

                win.css({
                    top: top,
                    left: left,
                    bottom: bottom,
                    right: right
                });
            }
        },

        _window: function(o){
            var that = this;
            var win, caption, content, icon, title, buttons, btnClose, btnMin, btnMax, resizer, status;
            var width = o.width, height = o.height;

            win = $("<div>").addClass("window");

            if (o.modal === true) {
                win.addClass("modal");
            }

            caption = $("<div>").addClass("window-caption");
            content = $("<div>").addClass("window-content");

            win.append(caption);
            win.append(content);

            if (o.status === true) {
                status = $("<div>").addClass("window-status");
                win.append(status);
            }

            if (o.shadow === true) {
                win.addClass("win-shadow");
            }

            if (Utils.isValue(o.icon)) {
                icon = $("<span>").addClass("icon").html(o.icon);
                icon.appendTo(caption);
            }

            title = $("<span>").addClass("title").html(Utils.isValue(o.title) ? o.title : "&nbsp;");
            title.appendTo(caption);

            if (!Utils.isNull(o.content)) {
                if (Utils.isQ(o.content)) {
                    o.content.appendTo(content);
                } else {
                    content.html(o.content);
                }
            }

            buttons = $("<div>").addClass("buttons");
            buttons.appendTo(caption);

            if (o.btnMax === true) {
                btnMax = $("<span>").addClass("button btn-max sys-button");
                btnMax.appendTo(buttons);
            }

            if (o.btnMin === true) {
                btnMin = $("<span>").addClass("button btn-min sys-button");
                btnMin.appendTo(buttons);
            }

            if (o.btnClose === true) {
                btnClose = $("<span>").addClass("button btn-close sys-button");
                btnClose.appendTo(buttons);
            }

            if (Utils.isValue(o.customButtons)) {
                var customButtons = [];

                if (Utils.isObject(o.customButtons) !== false) {
                    o.customButtons = Utils.isObject(o.customButtons);
                }

                if (typeof o.customButtons === "string" && o.customButtons.indexOf("{") > -1) {
                    customButtons = JSON.parse(o.customButtons);
                } else if (typeof o.customButtons === "object" && Utils.objectLength(o.customButtons) > 0) {
                    customButtons = o.customButtons;
                } else {
                    console.warn("Unknown format for custom buttons");
                }

                $.each(customButtons, function(){
                    var item = this;
                    var customButton = $("<span>");

                    customButton
                        .addClass("button btn-custom")
                        .addClass(o.clsCustomButton)
                        .addClass(item.cls)
                        .attr("tabindex", -1)
                        .html(item.html);

                    if (item.attr && typeof item.attr === 'object') {
                        $.each(item.attr, function(k, v){
                            customButton.attr(Cake.dashedName(k), v);
                        });
                    }

                    customButton.data("action", item.onclick);

                    buttons.prepend(customButton);
                });
            }

            caption.on(Metro.events.stop, ".btn-custom", function(e){
                if (Utils.isRightMouse(e)) return;
                var button = $(this);
                var action = button.data("action");
                Utils.exec(action, [button], this);
            });

            win.attr("id", o.id === undefined ? Utils.elementId("window") : o.id);

            win.on(Metro.events.dblclick, ".window-caption", function(e){
                that.maximized(e);
            });

            caption.on(Metro.events.click, ".btn-max, .btn-min, .btn-close", function(e){
                if (Utils.isRightMouse(e)) return;
                var target = $(e.target);
                if (target.hasClass("btn-max")) that.maximized(e);
                if (target.hasClass("btn-min")) that.minimized(e);
                if (target.hasClass("btn-close")) that.close(e);
            });

            if (o.draggable === true) {
                Metro.makePlugin(win, "draggable", {
                    dragContext: win[0],
                    dragElement: o.dragElement,
                    dragArea: o.dragArea,
                    onDragStart: o.onDragStart,
                    onDragStop: o.onDragStop,
                    onDragMove: o.onDragMove
                });
            }

            win.addClass(o.clsWindow);
            caption.addClass(o.clsCaption);
            content.addClass(o.clsContent);

            if (o.minWidth === 0) {
                o.minWidth = 34;
                $.each(buttons.children(".btn-custom"), function(){
                    o.minWidth += Utils.hiddenElementSize(this).width;
                });
                if (o.btnMax) o.minWidth += 34;
                if (o.btnMin) o.minWidth += 34;
                if (o.btnClose) o.minWidth += 34;
            }

            if (o.minWidth > 0 && !isNaN(o.width) && o.width < o.minWidth) {
                width = o.minWidth;
            }
            if (o.minHeight > 0 && !isNaN(o.height) && o.height > o.minHeight) {
                height = o.minHeight;
            }

            if (o.resizable === true) {
                resizer = $("<span>").addClass("resize-element");
                resizer.appendTo(win);
                win.addClass("resizable");

                Metro.makePlugin(win, "resizable", {
                    minWidth: o.minWidth,
                    minHeight: o.minHeight,
                    maxWidth: o.maxWidth,
                    maxHeight: o.maxHeight,
                    resizeElement: ".resize-element",
                    onResizeStart: o.onResizeStart,
                    onResizeStop: o.onResizeStop,
                    onResize: o.onResize
                });
            }

            win.css({
                width: width,
                height: height,
                position: o.position,
                top: o.top,
                left: o.left
            });

            return win;
        },

        _overlay: function(){
            var o = this.options;

            var overlay = $("<div>");
            overlay.addClass("overlay");

            if (o.overlayColor === 'transparent') {
                overlay.addClass("transparent");
            } else {
                overlay.css({
                    background: Metro.colors.toRGBA(o.overlayColor, o.overlayAlpha)
                });
            }

            return overlay;
        },

        width: function(v){
            var win = this.win;

            if (!Utils.isValue(v)) {
                return win.width();
            }

            win.css("width", parseInt(v));

            return this;
        },

        height: function(v){
            var win = this.win;

            if (!Utils.isValue(v)) {
                return win.height();
            }

            win.css("height", parseInt(v));

            return this;
        },

        maximized: function(e){
            var win = this.win, o = this.options;
            var target = $(e.target);

            if (o.btnMax) {
                win.removeClass("minimized");
                win.toggleClass("maximized");
            }

            if (target.hasClass && target.hasClass("title")) {

                this._fireEvent("caption-dbl-click", {
                    win: win[0]
                });

            } else {

                this._fireEvent("max-click", {
                    win: win[0]
                });

            }
        },

        minimized: function(){
            var win = this.win, o = this.options;

            if (o.btnMin) {
                win.removeClass("maximized");
                win.toggleClass("minimized");
            }

            this._fireEvent("min-click", {
                win: win[0]
            });
        },

        close: function(){
            var that = this, win = this.win,  o = this.options;

            if (Utils.exec(o.onCanClose, [win]) === false) {
                return false;
            }

            var timeout = 0;

            if (o.onClose !== Metro.noop) {
                timeout = 500;
            }

            this._fireEvent("close", {
                win: win[0]
            });

            setTimeout(function(){
                if (o.modal === true) {
                    win.siblings(".overlay").remove();
                }

                that._fireEvent("close-click", {
                    win: win[0]
                });

                if (o.closeAction === Metro.actions.REMOVE) {
                    that._fireEvent("window-destroy", {
                        win: win[0]
                    });
                    win.remove();
                } else {
                    that.hide();
                }

            }, timeout);
        },

        hide: function(){
            var win = this.win;

            win.css({
                display: "none"
            });

            this._fireEvent("hide", {
                win: win[0]
            });
        },

        show: function(){
            var win = this.win;

            win
                .removeClass("no-visible")
                .css({
                    display: "flex"
                });

            this._fireEvent("show", {
                win: win[0]
            });

        },

        toggle: function(){
            if (this.win.css("display") === "none" || this.win.hasClass("no-visible")) {
                this.show();
            } else {
                this.hide();
            }
        },

        isOpen: function(){
            return this.win.hasClass("no-visible");
        },

        min: function(a){
            a ? this.win.addClass("minimized") : this.win.removeClass("minimized");
        },

        max: function(a){
            a ? this.win.addClass("maximized") : this.win.removeClass("maximized");
        },

        changeClass: function(a){
            var element = this.element, win = this.win, o = this.options;

            if (a === "data-cls-window") {
                win[0].className = "window " + (o.resizable ? " resizable " : " ") + element.attr("data-cls-window");
            }
            if (a === "data-cls-caption") {
                win.find(".window-caption")[0].className = "window-caption " + element.attr("data-cls-caption");
            }
            if (a === "data-cls-content") {
                win.find(".window-content")[0].className = "window-content " + element.attr("data-cls-content");
            }
        },

        toggleShadow: function(){
            var element = this.element, win = this.win;
            var flag = JSON.parse(element.attr("data-shadow"));
            if (flag === true) {
                win.addClass("win-shadow");
            } else {
                win.removeClass("win-shadow");
            }
        },

        setContent: function(c){
            var element = this.element, win = this.win;
            var content = Utils.isValue(c) ? c : element.attr("data-content");
            var result;

            if (!Utils.isQ(content) && Utils.isFunc(content)) {
                result = Utils.exec(content);
            } else if (Utils.isQ(content)) {
                result = content.html();
            } else {
                result = content;
            }

            win.find(".window-content").html(result);
        },

        setTitle: function(t){
            var element = this.element, win = this.win;
            var title = Utils.isValue(t) ? t : element.attr("data-title");
            win.find(".window-caption .title").html(title);
        },

        setIcon: function(i){
            var element = this.element, win = this.win;
            var icon = Utils.isValue(i) ? i : element.attr("data-icon");
            win.find(".window-caption .icon").html(icon);
        },

        getIcon: function(){
            return this.win.find(".window-caption .icon").html();
        },

        getTitle: function(){
            return this.win.find(".window-caption .title").html();
        },

        toggleDraggable: function(f){
            var win = this.win;
            var flag = Utils.bool(f);
            var drag = Metro.getPlugin(win, "draggable");
            if (flag === true) {
                drag.on();
            } else {
                drag.off();
            }
        },

        toggleResizable: function(f){
            var win = this.win;
            var flag = Utils.bool(f);
            var resize = Metro.getPlugin(win, "resizable");
            if (flag === true) {
                resize.on();
                win.find(".resize-element").removeClass("resize-element-disabled");
            } else {
                resize.off();
                win.find(".resize-element").addClass("resize-element-disabled");
            }
        },

        changePlace: function (p) {
            var element = this.element, win = this.win;
            var place = Utils.isValue(p) ? p : element.attr("data-place");
            win.addClass(place);
        },

        pos: function(top, left){
            var win = this.win;
            win.css({
                top: top,
                left: left
            });
            return this;
        },

        top: function(v){
            this.win.css({
                top: v
            });
            return this;
        },

        left: function(v){
            this.win.css({
                left: v
            });
            return this;
        },

        changeAttribute: function(attr, value){
            var changePos = function(a, v){
                var win = this.win;
                var pos;
                if (a === "data-top") {
                    pos = parseInt(v);
                    if (!isNaN(pos)) {
                        return ;
                    }
                    win.css("top", pos);
                }
                if (a === "data-left") {
                    pos = parseInt(v);
                    if (!isNaN(pos)) {
                        return ;
                    }
                    win.css("left", pos);
                }
            };

            var toggleButtons = function(a, v) {
                var win = this.win;
                var btnClose = win.find(".btn-close");
                var btnMin = win.find(".btn-min");
                var btnMax = win.find(".btn-max");
                var _v = Utils.bool(v);
                var func = _v ? "show" : "hide";

                switch (a) {
                    case "data-btn-close": btnClose[func](); break;
                    case "data-btn-min": btnMin[func](); break;
                    case "data-btn-max": btnMax[func](); break;
                }
            };

            var changeSize = function(a, v){
                var win = this.win;
                if (a === "data-width") {
                    win.css("width", +v);
                }
                if (a === "data-height") {
                    win.css("height", +v);
                }
            };

            switch (attr) {
                case "data-btn-close":
                case "data-btn-min":
                case "data-btn-max": toggleButtons(attr, value); break;
                case "data-width":
                case "data-height": changeSize(attr, value); break;
                case "data-cls-window":
                case "data-cls-caption":
                case "data-cls-content": this.changeClass(attr); break;
                case "data-shadow": this.toggleShadow(); break;
                case "data-icon": this.setIcon(); break;
                case "data-title": this.setTitle(); break;
                case "data-content": this.setContent(); break;
                case "data-draggable": this.toggleDraggable(value); break;
                case "data-resizable": this.toggleResizable(value); break;
                case "data-top":
                case "data-left": changePos(attr, value); break;
                case "data-place": this.changePlace(); break;
            }
        },

        destroy: function(){
            return this.element;
        }
    });

    Metro['window'] = {

        isWindow: function(el){
            return Utils.isMetroObject(el, "window");
        },

        min: function(el, a){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el,"window").min(a);
        },

        max: function(el, a){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").max(a);
        },

        show: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").show();
        },

        hide: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").hide();
        },

        toggle: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").toggle();
        },

        isOpen: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            var win = Metro.getPlugin(el,"window");
            return win.isOpen();
        },

        close: function(el){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").close();
        },

        pos: function(el, top, left){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").pos(top, left);
        },

        top: function(el, top){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").top(top);
        },

        left: function(el, left){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").left(left);
        },

        width: function(el, width){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").width(width);
        },

        height: function(el, height){
            if (!this.isWindow(el)) {
                return false;
            }
            Metro.getPlugin(el, "window").height(height);
        },

        create: function(options, parent){
            var w;

            w = $("<div>").appendTo(parent ? $(parent) : $("body"));

            var w_options = $.extend({
                _runtime: true
            }, (options ? options : {}));

            return Metro.makePlugin(w, "window", w_options);
        }
    };
}(Metro, m4q));

(function(Metro, $) {
    'use strict';
    var Utils = Metro.utils;
    var WizardDefaultConfig = {
        wizardDeferred: 0,
        start: 1,
        finish: 0,
        iconHelp: "<span class='default-icon-help'></span>",
        iconPrev: "<span class='default-icon-left-arrow'></span>",
        iconNext: "<span class='default-icon-right-arrow'></span>",
        iconFinish: "<span class='default-icon-check'></span>",

        buttonMode: "cycle", // default, cycle, square
        buttonOutline: true,
        duration: 300,

        clsWizard: "",
        clsActions: "",
        clsHelp: "",
        clsPrev: "",
        clsNext: "",
        clsFinish: "",

        onPage: Metro.noop,
        onNextPage: Metro.noop,
        onPrevPage: Metro.noop,
        onFirstPage: Metro.noop,
        onLastPage: Metro.noop,
        onFinishPage: Metro.noop,
        onHelpClick: Metro.noop,
        onPrevClick: Metro.noop,
        onNextClick: Metro.noop,
        onFinishClick: Metro.noop,
        onBeforePrev: Metro.noop_true,
        onBeforeNext: Metro.noop_true,
        onWizardCreate: Metro.noop
    };

    Metro.wizardSetup = function (options) {
        WizardDefaultConfig = $.extend({}, WizardDefaultConfig, options);
    };

    if (typeof window["metroWizardSetup"] !== undefined) {
        Metro.wizardSetup(window["metroWizardSetup"]);
    }

    Metro.Component('wizard', {
        init: function( options, elem ) {
            this._super(elem, options, WizardDefaultConfig, {
                id: Utils.elementId('wizard')
            });

            return this;
        },

        _create: function(){
            var element = this.element;

            this._createWizard();
            this._createEvents();

            this._fireEvent("wizard-create", {
                element: element
            });
        },

        _createWizard: function(){
            var element = this.element, o = this.options;
            var bar;

            element.addClass("wizard").addClass(o.view).addClass(o.clsWizard);

            bar = $("<div>").addClass("action-bar").addClass(o.clsActions).appendTo(element);

            var buttonMode = o.buttonMode === "button" ? "" : o.buttonMode;
            if (o.buttonOutline === true) {
                buttonMode += " outline";
            }

            if (o.iconHelp !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-help").addClass(buttonMode).addClass(o.clsHelp).html(Utils.isTag(o.iconHelp) ? o.iconHelp : $("<img>").attr('src', o.iconHelp)).appendTo(bar);
            if (o.iconPrev !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-prev").addClass(buttonMode).addClass(o.clsPrev).html(Utils.isTag(o.iconPrev) ? o.iconPrev : $("<img>").attr('src', o.iconPrev)).appendTo(bar);
            if (o.iconNext !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-next").addClass(buttonMode).addClass(o.clsNext).html(Utils.isTag(o.iconNext) ? o.iconNext : $("<img>").attr('src', o.iconNext)).appendTo(bar);
            if (o.iconFinish !== false) $("<button>").attr("type", "button").addClass("button wizard-btn-finish").addClass(buttonMode).addClass(o.clsFinish).html(Utils.isTag(o.iconFinish) ? o.iconFinish : $("<img>").attr('src', o.iconFinish)).appendTo(bar);

            this.toPage(o.start);

            this._setHeight();
        },

        _setHeight: function(){
            var element = this.element;
            var pages = element.children("section");
            var max_height = 0;

            pages.children(".page-content").css("max-height", "none");

            $.each(pages, function(){
                var h = $(this).height();
                if (max_height < parseInt(h)) {
                    max_height = h;
                }
            });

            element.height(max_height);
        },

        _createEvents: function(){
            var that = this, element = this.element;

            element.on(Metro.events.click, ".wizard-btn-help", function(){
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("help-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-prev", function(){
                that.prev();
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("prev-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-next", function(){
                that.next();
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("next-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".wizard-btn-finish", function(){
                var pages = element.children("section");
                var page = pages.get(that.current - 1);

                that._fireEvent("finish-click", {
                    index: that.current,
                    page: page
                });
            });

            element.on(Metro.events.click, ".complete", function(){
                var index = $(this).index() + 1;
                that.toPage(index);
            });

            $(window).on(Metro.events.resize, function(){
                that._setHeight();
            }, {ns: this.id});
        },

        next: function(){
            var that = this, element = this.element, o = this.options;
            var pages = element.children("section");
            var page = $(element.children("section").get(this.current - 1));

            if (this.current + 1 > pages.length || Utils.exec(o.onBeforeNext, [this.current, page, element]) === false) {
                return ;
            }

            this.current++;

            this.toPage(this.current);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("next-page", {
                index: that.current,
                page: page[0]
            });
        },

        prev: function(){
            var that = this, element = this.element, o = this.options;
            var page = $(element.children("section").get(this.current - 1));

            if (this.current - 1 === 0 || Utils.exec(o.onBeforePrev, [this.current, page, element]) === false) {
                return ;
            }

            this.current--;

            this.toPage(this.current);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("prev-page", {
                index: that.current,
                page: page[0]
            });
        },

        last: function(){
            var that = this, element = this.element;
            var page;

            this.toPage(element.children("section").length);

            page = $(element.children("section").get(this.current - 1));

            this._fireEvent("last-page", {
                index: that.current,
                page: page[0]
            });
        },

        first: function(){
            var that = this, element = this.element;
            var page;

            this.toPage(1);

            page = $(element.children("section").get(0));

            this._fireEvent("first-page", {
                index: that.current,
                page: page[0]
            });
        },

        toPage: function(page){
            var element = this.element, o = this.options;
            var target = $(element.children("section").get(page - 1));
            var sections = element.children("section");
            var actions = element.find(".action-bar");

            if (target.length === 0) {
                return ;
            }

            var finish = element.find(".wizard-btn-finish").addClass("disabled");
            var next = element.find(".wizard-btn-next").addClass("disabled");
            var prev = element.find(".wizard-btn-prev").addClass("disabled");

            this.current = page;

            element.children("section")
                .removeClass("complete current")
                .removeClass(o.clsCurrent)
                .removeClass(o.clsComplete);

            target.addClass("current").addClass(o.clsCurrent);
            target.prevAll().addClass("complete").addClass(o.clsComplete);

            var border_size = element.children("section.complete").length === 0 ? 0 : parseInt(Utils.getStyleOne(element.children("section.complete")[0], "border-left-width"));

            actions.animate({
                draw: {
                    left: element.children("section.complete").length * border_size + 41
                },
                dur: o.duration
            });

            if (
                (this.current === sections.length) || (o.finish > 0 && this.current >= o.finish)
            ) {
                finish.removeClass("disabled");
            }

            if (parseInt(o.finish) > 0 && this.current === parseInt(o.finish)) {

                this._fireEvent("finish-page", {
                    index: this.current,
                    page: target[0]
                });
            }

            if (this.current < sections.length) {
                next.removeClass("disabled");
            }

            if (this.current > 1) {
                prev.removeClass("disabled");
            }

            this._fireEvent("page", {
                index: this.current,
                page: target[0]
            });
        },

        changeAttribute: function(){
        },

        destroy: function(){
            var element = this.element;

            element.off(Metro.events.click, ".wizard-btn-help");
            element.off(Metro.events.click, ".wizard-btn-prev");
            element.off(Metro.events.click, ".wizard-btn-next");
            element.off(Metro.events.click, ".wizard-btn-finish");
            element.off(Metro.events.click, ".complete");
            $(window).off(Metro.events.resize,{ns: this.id});

            return element;
        }
    });
}(Metro, m4q));